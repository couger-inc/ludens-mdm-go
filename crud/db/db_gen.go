// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"fmt"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"mysql","activeProvider":"mysql","url":{"fromEnvVar":"DATABASE_URL","value":""},"config":null}]`

const schema = `generator db {
  provider        = "go run github.com/steebchen/prisma-client-go"
  previewFeatures = ["relationJoins"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  uid       String    @id @db.VarChar(255)
  role      String?   @db.VarChar(20)
  name      String    @default("") @db.VarChar(255)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())
  synchedAt DateTime?
  deletedAt DateTime?
}

model AccessKey {
  name      String   @id @db.VarChar(20)
  value     String   @db.VarChar(100)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
}

model Import {
  id           Int      @id @default(autoincrement()) @db.UnsignedInt
  resourceType String   @db.VarChar(100)
  status       String   @db.VarChar(20)
  output       String?  @db.Text
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now())
  objectKey    String   @db.VarChar(255)
}

model Product {
  id          String   @id @db.VarChar(128)
  name        String   @db.VarChar(200)
  categoryId1 String   @default("") @db.VarChar(30)
  categoryId2 String   @default("") @db.VarChar(30)
  categoryId3 String   @default("") @db.VarChar(30)
  categoryId4 String   @default("") @db.VarChar(30)
  categoryId5 String   @default("") @db.VarChar(30)
  note        String   @default("") @db.VarChar(1020)
  price       Int?     @db.UnsignedInt
  custom1     String   @default("") @db.VarChar(100)
  custom2     String   @default("") @db.VarChar(100)
  description String   @default("") @db.VarChar(255)
  details     String   @default("") @db.VarChar(1000)
  imageUrl1   String   @default("") @db.VarChar(255)
  imageUrl2   String   @default("") @db.VarChar(255)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())
}

model Category {
  categoryId1             String                  @default("") @db.VarChar(50)
  categoryName1           String                  @default("") @db.VarChar(100)
  categoryId2             String                  @default("") @db.VarChar(50)
  categoryName2           String                  @default("") @db.VarChar(100)
  categoryId3             String                  @default("") @db.VarChar(50)
  categoryName3           String                  @default("") @db.VarChar(100)
  categoryId4             String                  @default("") @db.VarChar(50)
  categoryName4           String                  @default("") @db.VarChar(100)
  categoryId5             String                  @default("") @db.VarChar(50)
  categoryName5           String                  @default("") @db.VarChar(100)
  categoryGroupCategories CategoryGroupCategory[]

  @@unique([categoryId1, categoryId2, categoryId3, categoryId4, categoryId5])
}

model CategoryGroup {
  id                      String                  @id @db.VarChar(50)
  name                    String                  @db.VarChar(50)
  level                   Int                     @db.UnsignedInt
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @default(now())
  categoryGroupCategories CategoryGroupCategory[]
}

model CategoryGroupCategory {
  categoryId1     String        @default("") @db.VarChar(50)
  categoryId2     String        @default("") @db.VarChar(50)
  categoryId3     String        @default("") @db.VarChar(50)
  categoryId4     String        @default("") @db.VarChar(50)
  categoryId5     String        @default("") @db.VarChar(50)
  categoryGroupId String        @db.VarChar(50)
  category        Category      @relation(fields: [categoryId1, categoryId2, categoryId3, categoryId4, categoryId5], references: [categoryId1, categoryId2, categoryId3, categoryId4, categoryId5])
  categoryGroup   CategoryGroup @relation(fields: [categoryGroupId], references: [id])

  @@unique([categoryId1, categoryId2, categoryId3, categoryId4, categoryId5, categoryGroupId])
}

model Store {
  id             String   @id @db.VarChar(16)
  name           String   @db.VarChar(64)
  salesFloorArea Float?   @db.Float
  createdAt      DateTime @default(now())
  updatedAt      DateTime @default(now())

  userStore UserStore[]
}

model UserStore {
  email     String   @db.VarChar(255)
  name      String   @db.VarChar(255)
  storeId   String   @db.VarChar(16)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  store Store @relation(fields: [storeId], references: [id])

  @@unique([email, storeId])
}

model Holiday {
  date DateTime @id @db.Date
  name String   @db.VarChar(255)
}

model StoreStatus {
  storeId    String   @db.VarChar(16)
  date       DateTime @db.Date
  isOpen     Boolean  @default(false)
  isExisting Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now())

  @@id([storeId, date])
}
`
const schemaDatasourceURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set " + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}
	c.AccessKey = accessKeyActions{client: c}
	c.Import = importActions{client: c}
	c.Product = productActions{client: c}
	c.Category = categoryActions{client: c}
	c.CategoryGroup = categoryGroupActions{client: c}
	c.CategoryGroupCategory = categoryGroupCategoryActions{client: c}
	c.Store = storeActions{client: c}
	c.UserStore = userStoreActions{client: c}
	c.Holiday = holidayActions{client: c}
	c.StoreStatus = storeStatusActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
	// AccessKey provides access to CRUD methods.
	AccessKey accessKeyActions
	// Import provides access to CRUD methods.
	Import importActions
	// Product provides access to CRUD methods.
	Product productActions
	// Category provides access to CRUD methods.
	Category categoryActions
	// CategoryGroup provides access to CRUD methods.
	CategoryGroup categoryGroupActions
	// CategoryGroupCategory provides access to CRUD methods.
	CategoryGroupCategory categoryGroupCategoryActions
	// Store provides access to CRUD methods.
	Store storeActions
	// UserStore provides access to CRUD methods.
	UserStore userStoreActions
	// Holiday provides access to CRUD methods.
	Holiday holidayActions
	// StoreStatus provides access to CRUD methods.
	StoreStatus storeStatusActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumUID       UserScalarFieldEnum = "uid"
	UserScalarFieldEnumRole      UserScalarFieldEnum = "role"
	UserScalarFieldEnumName      UserScalarFieldEnum = "name"
	UserScalarFieldEnumCreatedAt UserScalarFieldEnum = "createdAt"
	UserScalarFieldEnumUpdatedAt UserScalarFieldEnum = "updatedAt"
	UserScalarFieldEnumSynchedAt UserScalarFieldEnum = "synchedAt"
	UserScalarFieldEnumDeletedAt UserScalarFieldEnum = "deletedAt"
)

type RelationLoadStrategy string

const (
	RelationLoadStrategyQuery RelationLoadStrategy = "query"
	RelationLoadStrategyJoin  RelationLoadStrategy = "join"
)

type AccessKeyScalarFieldEnum string

const (
	AccessKeyScalarFieldEnumName      AccessKeyScalarFieldEnum = "name"
	AccessKeyScalarFieldEnumValue     AccessKeyScalarFieldEnum = "value"
	AccessKeyScalarFieldEnumCreatedAt AccessKeyScalarFieldEnum = "createdAt"
	AccessKeyScalarFieldEnumUpdatedAt AccessKeyScalarFieldEnum = "updatedAt"
)

type ImportScalarFieldEnum string

const (
	ImportScalarFieldEnumID           ImportScalarFieldEnum = "id"
	ImportScalarFieldEnumResourceType ImportScalarFieldEnum = "resourceType"
	ImportScalarFieldEnumStatus       ImportScalarFieldEnum = "status"
	ImportScalarFieldEnumOutput       ImportScalarFieldEnum = "output"
	ImportScalarFieldEnumCreatedAt    ImportScalarFieldEnum = "createdAt"
	ImportScalarFieldEnumUpdatedAt    ImportScalarFieldEnum = "updatedAt"
	ImportScalarFieldEnumObjectKey    ImportScalarFieldEnum = "objectKey"
)

type ProductScalarFieldEnum string

const (
	ProductScalarFieldEnumID          ProductScalarFieldEnum = "id"
	ProductScalarFieldEnumName        ProductScalarFieldEnum = "name"
	ProductScalarFieldEnumCategoryID1 ProductScalarFieldEnum = "categoryId1"
	ProductScalarFieldEnumCategoryID2 ProductScalarFieldEnum = "categoryId2"
	ProductScalarFieldEnumCategoryID3 ProductScalarFieldEnum = "categoryId3"
	ProductScalarFieldEnumCategoryID4 ProductScalarFieldEnum = "categoryId4"
	ProductScalarFieldEnumCategoryID5 ProductScalarFieldEnum = "categoryId5"
	ProductScalarFieldEnumNote        ProductScalarFieldEnum = "note"
	ProductScalarFieldEnumPrice       ProductScalarFieldEnum = "price"
	ProductScalarFieldEnumCustom1     ProductScalarFieldEnum = "custom1"
	ProductScalarFieldEnumCustom2     ProductScalarFieldEnum = "custom2"
	ProductScalarFieldEnumDescription ProductScalarFieldEnum = "description"
	ProductScalarFieldEnumDetails     ProductScalarFieldEnum = "details"
	ProductScalarFieldEnumImageURL1   ProductScalarFieldEnum = "imageUrl1"
	ProductScalarFieldEnumImageURL2   ProductScalarFieldEnum = "imageUrl2"
	ProductScalarFieldEnumCreatedAt   ProductScalarFieldEnum = "createdAt"
	ProductScalarFieldEnumUpdatedAt   ProductScalarFieldEnum = "updatedAt"
)

type CategoryScalarFieldEnum string

const (
	CategoryScalarFieldEnumCategoryID1   CategoryScalarFieldEnum = "categoryId1"
	CategoryScalarFieldEnumCategoryName1 CategoryScalarFieldEnum = "categoryName1"
	CategoryScalarFieldEnumCategoryID2   CategoryScalarFieldEnum = "categoryId2"
	CategoryScalarFieldEnumCategoryName2 CategoryScalarFieldEnum = "categoryName2"
	CategoryScalarFieldEnumCategoryID3   CategoryScalarFieldEnum = "categoryId3"
	CategoryScalarFieldEnumCategoryName3 CategoryScalarFieldEnum = "categoryName3"
	CategoryScalarFieldEnumCategoryID4   CategoryScalarFieldEnum = "categoryId4"
	CategoryScalarFieldEnumCategoryName4 CategoryScalarFieldEnum = "categoryName4"
	CategoryScalarFieldEnumCategoryID5   CategoryScalarFieldEnum = "categoryId5"
	CategoryScalarFieldEnumCategoryName5 CategoryScalarFieldEnum = "categoryName5"
)

type CategoryGroupScalarFieldEnum string

const (
	CategoryGroupScalarFieldEnumID        CategoryGroupScalarFieldEnum = "id"
	CategoryGroupScalarFieldEnumName      CategoryGroupScalarFieldEnum = "name"
	CategoryGroupScalarFieldEnumLevel     CategoryGroupScalarFieldEnum = "level"
	CategoryGroupScalarFieldEnumCreatedAt CategoryGroupScalarFieldEnum = "createdAt"
	CategoryGroupScalarFieldEnumUpdatedAt CategoryGroupScalarFieldEnum = "updatedAt"
)

type CategoryGroupCategoryScalarFieldEnum string

const (
	CategoryGroupCategoryScalarFieldEnumCategoryID1     CategoryGroupCategoryScalarFieldEnum = "categoryId1"
	CategoryGroupCategoryScalarFieldEnumCategoryID2     CategoryGroupCategoryScalarFieldEnum = "categoryId2"
	CategoryGroupCategoryScalarFieldEnumCategoryID3     CategoryGroupCategoryScalarFieldEnum = "categoryId3"
	CategoryGroupCategoryScalarFieldEnumCategoryID4     CategoryGroupCategoryScalarFieldEnum = "categoryId4"
	CategoryGroupCategoryScalarFieldEnumCategoryID5     CategoryGroupCategoryScalarFieldEnum = "categoryId5"
	CategoryGroupCategoryScalarFieldEnumCategoryGroupID CategoryGroupCategoryScalarFieldEnum = "categoryGroupId"
)

type StoreScalarFieldEnum string

const (
	StoreScalarFieldEnumID             StoreScalarFieldEnum = "id"
	StoreScalarFieldEnumName           StoreScalarFieldEnum = "name"
	StoreScalarFieldEnumSalesFloorArea StoreScalarFieldEnum = "salesFloorArea"
	StoreScalarFieldEnumCreatedAt      StoreScalarFieldEnum = "createdAt"
	StoreScalarFieldEnumUpdatedAt      StoreScalarFieldEnum = "updatedAt"
)

type UserStoreScalarFieldEnum string

const (
	UserStoreScalarFieldEnumEmail     UserStoreScalarFieldEnum = "email"
	UserStoreScalarFieldEnumName      UserStoreScalarFieldEnum = "name"
	UserStoreScalarFieldEnumStoreID   UserStoreScalarFieldEnum = "storeId"
	UserStoreScalarFieldEnumCreatedAt UserStoreScalarFieldEnum = "createdAt"
	UserStoreScalarFieldEnumUpdatedAt UserStoreScalarFieldEnum = "updatedAt"
)

type HolidayScalarFieldEnum string

const (
	HolidayScalarFieldEnumDate HolidayScalarFieldEnum = "date"
	HolidayScalarFieldEnumName HolidayScalarFieldEnum = "name"
)

type StoreStatusScalarFieldEnum string

const (
	StoreStatusScalarFieldEnumStoreID    StoreStatusScalarFieldEnum = "storeId"
	StoreStatusScalarFieldEnumDate       StoreStatusScalarFieldEnum = "date"
	StoreStatusScalarFieldEnumIsOpen     StoreStatusScalarFieldEnum = "isOpen"
	StoreStatusScalarFieldEnumIsExisting StoreStatusScalarFieldEnum = "isExisting"
	StoreStatusScalarFieldEnumCreatedAt  StoreStatusScalarFieldEnum = "createdAt"
	StoreStatusScalarFieldEnumUpdatedAt  StoreStatusScalarFieldEnum = "updatedAt"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

type UserOrderByRelevanceFieldEnum string

const (
	UserOrderByRelevanceFieldEnumUID  UserOrderByRelevanceFieldEnum = "uid"
	UserOrderByRelevanceFieldEnumRole UserOrderByRelevanceFieldEnum = "role"
	UserOrderByRelevanceFieldEnumName UserOrderByRelevanceFieldEnum = "name"
)

type AccessKeyOrderByRelevanceFieldEnum string

const (
	AccessKeyOrderByRelevanceFieldEnumName  AccessKeyOrderByRelevanceFieldEnum = "name"
	AccessKeyOrderByRelevanceFieldEnumValue AccessKeyOrderByRelevanceFieldEnum = "value"
)

type ImportOrderByRelevanceFieldEnum string

const (
	ImportOrderByRelevanceFieldEnumResourceType ImportOrderByRelevanceFieldEnum = "resourceType"
	ImportOrderByRelevanceFieldEnumStatus       ImportOrderByRelevanceFieldEnum = "status"
	ImportOrderByRelevanceFieldEnumOutput       ImportOrderByRelevanceFieldEnum = "output"
	ImportOrderByRelevanceFieldEnumObjectKey    ImportOrderByRelevanceFieldEnum = "objectKey"
)

type ProductOrderByRelevanceFieldEnum string

const (
	ProductOrderByRelevanceFieldEnumID          ProductOrderByRelevanceFieldEnum = "id"
	ProductOrderByRelevanceFieldEnumName        ProductOrderByRelevanceFieldEnum = "name"
	ProductOrderByRelevanceFieldEnumCategoryID1 ProductOrderByRelevanceFieldEnum = "categoryId1"
	ProductOrderByRelevanceFieldEnumCategoryID2 ProductOrderByRelevanceFieldEnum = "categoryId2"
	ProductOrderByRelevanceFieldEnumCategoryID3 ProductOrderByRelevanceFieldEnum = "categoryId3"
	ProductOrderByRelevanceFieldEnumCategoryID4 ProductOrderByRelevanceFieldEnum = "categoryId4"
	ProductOrderByRelevanceFieldEnumCategoryID5 ProductOrderByRelevanceFieldEnum = "categoryId5"
	ProductOrderByRelevanceFieldEnumNote        ProductOrderByRelevanceFieldEnum = "note"
	ProductOrderByRelevanceFieldEnumCustom1     ProductOrderByRelevanceFieldEnum = "custom1"
	ProductOrderByRelevanceFieldEnumCustom2     ProductOrderByRelevanceFieldEnum = "custom2"
	ProductOrderByRelevanceFieldEnumDescription ProductOrderByRelevanceFieldEnum = "description"
	ProductOrderByRelevanceFieldEnumDetails     ProductOrderByRelevanceFieldEnum = "details"
	ProductOrderByRelevanceFieldEnumImageURL1   ProductOrderByRelevanceFieldEnum = "imageUrl1"
	ProductOrderByRelevanceFieldEnumImageURL2   ProductOrderByRelevanceFieldEnum = "imageUrl2"
)

type CategoryOrderByRelevanceFieldEnum string

const (
	CategoryOrderByRelevanceFieldEnumCategoryID1   CategoryOrderByRelevanceFieldEnum = "categoryId1"
	CategoryOrderByRelevanceFieldEnumCategoryName1 CategoryOrderByRelevanceFieldEnum = "categoryName1"
	CategoryOrderByRelevanceFieldEnumCategoryID2   CategoryOrderByRelevanceFieldEnum = "categoryId2"
	CategoryOrderByRelevanceFieldEnumCategoryName2 CategoryOrderByRelevanceFieldEnum = "categoryName2"
	CategoryOrderByRelevanceFieldEnumCategoryID3   CategoryOrderByRelevanceFieldEnum = "categoryId3"
	CategoryOrderByRelevanceFieldEnumCategoryName3 CategoryOrderByRelevanceFieldEnum = "categoryName3"
	CategoryOrderByRelevanceFieldEnumCategoryID4   CategoryOrderByRelevanceFieldEnum = "categoryId4"
	CategoryOrderByRelevanceFieldEnumCategoryName4 CategoryOrderByRelevanceFieldEnum = "categoryName4"
	CategoryOrderByRelevanceFieldEnumCategoryID5   CategoryOrderByRelevanceFieldEnum = "categoryId5"
	CategoryOrderByRelevanceFieldEnumCategoryName5 CategoryOrderByRelevanceFieldEnum = "categoryName5"
)

type CategoryGroupOrderByRelevanceFieldEnum string

const (
	CategoryGroupOrderByRelevanceFieldEnumID   CategoryGroupOrderByRelevanceFieldEnum = "id"
	CategoryGroupOrderByRelevanceFieldEnumName CategoryGroupOrderByRelevanceFieldEnum = "name"
)

type CategoryGroupCategoryOrderByRelevanceFieldEnum string

const (
	CategoryGroupCategoryOrderByRelevanceFieldEnumCategoryID1     CategoryGroupCategoryOrderByRelevanceFieldEnum = "categoryId1"
	CategoryGroupCategoryOrderByRelevanceFieldEnumCategoryID2     CategoryGroupCategoryOrderByRelevanceFieldEnum = "categoryId2"
	CategoryGroupCategoryOrderByRelevanceFieldEnumCategoryID3     CategoryGroupCategoryOrderByRelevanceFieldEnum = "categoryId3"
	CategoryGroupCategoryOrderByRelevanceFieldEnumCategoryID4     CategoryGroupCategoryOrderByRelevanceFieldEnum = "categoryId4"
	CategoryGroupCategoryOrderByRelevanceFieldEnumCategoryID5     CategoryGroupCategoryOrderByRelevanceFieldEnum = "categoryId5"
	CategoryGroupCategoryOrderByRelevanceFieldEnumCategoryGroupID CategoryGroupCategoryOrderByRelevanceFieldEnum = "categoryGroupId"
)

type StoreOrderByRelevanceFieldEnum string

const (
	StoreOrderByRelevanceFieldEnumID   StoreOrderByRelevanceFieldEnum = "id"
	StoreOrderByRelevanceFieldEnumName StoreOrderByRelevanceFieldEnum = "name"
)

type UserStoreOrderByRelevanceFieldEnum string

const (
	UserStoreOrderByRelevanceFieldEnumEmail   UserStoreOrderByRelevanceFieldEnum = "email"
	UserStoreOrderByRelevanceFieldEnumName    UserStoreOrderByRelevanceFieldEnum = "name"
	UserStoreOrderByRelevanceFieldEnumStoreID UserStoreOrderByRelevanceFieldEnum = "storeId"
)

type HolidayOrderByRelevanceFieldEnum string

const (
	HolidayOrderByRelevanceFieldEnumName HolidayOrderByRelevanceFieldEnum = "name"
)

type StoreStatusOrderByRelevanceFieldEnum string

const (
	StoreStatusOrderByRelevanceFieldEnumStoreID StoreStatusOrderByRelevanceFieldEnum = "storeId"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type userPrismaFields = prismaFields

const userFieldUID userPrismaFields = "uid"

const userFieldRole userPrismaFields = "role"

const userFieldName userPrismaFields = "name"

const userFieldCreatedAt userPrismaFields = "createdAt"

const userFieldUpdatedAt userPrismaFields = "updatedAt"

const userFieldSynchedAt userPrismaFields = "synchedAt"

const userFieldDeletedAt userPrismaFields = "deletedAt"

const userFieldRelevance userPrismaFields = "relevance"

type accessKeyPrismaFields = prismaFields

const accessKeyFieldName accessKeyPrismaFields = "name"

const accessKeyFieldValue accessKeyPrismaFields = "value"

const accessKeyFieldCreatedAt accessKeyPrismaFields = "createdAt"

const accessKeyFieldUpdatedAt accessKeyPrismaFields = "updatedAt"

const accessKeyFieldRelevance accessKeyPrismaFields = "relevance"

type importPrismaFields = prismaFields

const importFieldID importPrismaFields = "id"

const importFieldResourceType importPrismaFields = "resourceType"

const importFieldStatus importPrismaFields = "status"

const importFieldOutput importPrismaFields = "output"

const importFieldCreatedAt importPrismaFields = "createdAt"

const importFieldUpdatedAt importPrismaFields = "updatedAt"

const importFieldObjectKey importPrismaFields = "objectKey"

const importFieldRelevance importPrismaFields = "relevance"

type productPrismaFields = prismaFields

const productFieldID productPrismaFields = "id"

const productFieldName productPrismaFields = "name"

const productFieldCategoryID1 productPrismaFields = "categoryId1"

const productFieldCategoryID2 productPrismaFields = "categoryId2"

const productFieldCategoryID3 productPrismaFields = "categoryId3"

const productFieldCategoryID4 productPrismaFields = "categoryId4"

const productFieldCategoryID5 productPrismaFields = "categoryId5"

const productFieldNote productPrismaFields = "note"

const productFieldPrice productPrismaFields = "price"

const productFieldCustom1 productPrismaFields = "custom1"

const productFieldCustom2 productPrismaFields = "custom2"

const productFieldDescription productPrismaFields = "description"

const productFieldDetails productPrismaFields = "details"

const productFieldImageURL1 productPrismaFields = "imageUrl1"

const productFieldImageURL2 productPrismaFields = "imageUrl2"

const productFieldCreatedAt productPrismaFields = "createdAt"

const productFieldUpdatedAt productPrismaFields = "updatedAt"

const productFieldRelevance productPrismaFields = "relevance"

type categoryPrismaFields = prismaFields

const categoryFieldCategoryID1 categoryPrismaFields = "categoryId1"

const categoryFieldCategoryName1 categoryPrismaFields = "categoryName1"

const categoryFieldCategoryID2 categoryPrismaFields = "categoryId2"

const categoryFieldCategoryName2 categoryPrismaFields = "categoryName2"

const categoryFieldCategoryID3 categoryPrismaFields = "categoryId3"

const categoryFieldCategoryName3 categoryPrismaFields = "categoryName3"

const categoryFieldCategoryID4 categoryPrismaFields = "categoryId4"

const categoryFieldCategoryName4 categoryPrismaFields = "categoryName4"

const categoryFieldCategoryID5 categoryPrismaFields = "categoryId5"

const categoryFieldCategoryName5 categoryPrismaFields = "categoryName5"

const categoryFieldCategoryGroupCategories categoryPrismaFields = "categoryGroupCategories"

const categoryFieldRelevance categoryPrismaFields = "relevance"

type categoryGroupPrismaFields = prismaFields

const categoryGroupFieldID categoryGroupPrismaFields = "id"

const categoryGroupFieldName categoryGroupPrismaFields = "name"

const categoryGroupFieldLevel categoryGroupPrismaFields = "level"

const categoryGroupFieldCreatedAt categoryGroupPrismaFields = "createdAt"

const categoryGroupFieldUpdatedAt categoryGroupPrismaFields = "updatedAt"

const categoryGroupFieldCategoryGroupCategories categoryGroupPrismaFields = "categoryGroupCategories"

const categoryGroupFieldRelevance categoryGroupPrismaFields = "relevance"

type categoryGroupCategoryPrismaFields = prismaFields

const categoryGroupCategoryFieldCategoryID1 categoryGroupCategoryPrismaFields = "categoryId1"

const categoryGroupCategoryFieldCategoryID2 categoryGroupCategoryPrismaFields = "categoryId2"

const categoryGroupCategoryFieldCategoryID3 categoryGroupCategoryPrismaFields = "categoryId3"

const categoryGroupCategoryFieldCategoryID4 categoryGroupCategoryPrismaFields = "categoryId4"

const categoryGroupCategoryFieldCategoryID5 categoryGroupCategoryPrismaFields = "categoryId5"

const categoryGroupCategoryFieldCategoryGroupID categoryGroupCategoryPrismaFields = "categoryGroupId"

const categoryGroupCategoryFieldCategory categoryGroupCategoryPrismaFields = "category"

const categoryGroupCategoryFieldCategoryGroup categoryGroupCategoryPrismaFields = "categoryGroup"

const categoryGroupCategoryFieldRelevance categoryGroupCategoryPrismaFields = "relevance"

type storePrismaFields = prismaFields

const storeFieldID storePrismaFields = "id"

const storeFieldName storePrismaFields = "name"

const storeFieldSalesFloorArea storePrismaFields = "salesFloorArea"

const storeFieldCreatedAt storePrismaFields = "createdAt"

const storeFieldUpdatedAt storePrismaFields = "updatedAt"

const storeFieldUserStore storePrismaFields = "userStore"

const storeFieldRelevance storePrismaFields = "relevance"

type userStorePrismaFields = prismaFields

const userStoreFieldEmail userStorePrismaFields = "email"

const userStoreFieldName userStorePrismaFields = "name"

const userStoreFieldStoreID userStorePrismaFields = "storeId"

const userStoreFieldCreatedAt userStorePrismaFields = "createdAt"

const userStoreFieldUpdatedAt userStorePrismaFields = "updatedAt"

const userStoreFieldStore userStorePrismaFields = "store"

const userStoreFieldRelevance userStorePrismaFields = "relevance"

type holidayPrismaFields = prismaFields

const holidayFieldDate holidayPrismaFields = "date"

const holidayFieldName holidayPrismaFields = "name"

const holidayFieldRelevance holidayPrismaFields = "relevance"

type storeStatusPrismaFields = prismaFields

const storeStatusFieldStoreID storeStatusPrismaFields = "storeId"

const storeStatusFieldDate storeStatusPrismaFields = "date"

const storeStatusFieldIsOpen storeStatusPrismaFields = "isOpen"

const storeStatusFieldIsExisting storeStatusPrismaFields = "isExisting"

const storeStatusFieldCreatedAt storeStatusPrismaFields = "createdAt"

const storeStatusFieldUpdatedAt storeStatusPrismaFields = "updatedAt"

const storeStatusFieldRelevance storeStatusPrismaFields = "relevance"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	m.AccessKey = accessKeyMock{
		mock: m,
	}

	m.Import = importMock{
		mock: m,
	}

	m.Product = productMock{
		mock: m,
	}

	m.Category = categoryMock{
		mock: m,
	}

	m.CategoryGroup = categoryGroupMock{
		mock: m,
	}

	m.CategoryGroupCategory = categoryGroupCategoryMock{
		mock: m,
	}

	m.Store = storeMock{
		mock: m,
	}

	m.UserStore = userStoreMock{
		mock: m,
	}

	m.Holiday = holidayMock{
		mock: m,
	}

	m.StoreStatus = storeStatusMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock

	AccessKey accessKeyMock

	Import importMock

	Product productMock

	Category categoryMock

	CategoryGroup categoryGroupMock

	CategoryGroupCategory categoryGroupCategoryMock

	Store storeMock

	UserStore userStoreMock

	Holiday holidayMock

	StoreStatus storeStatusMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type accessKeyMock struct {
	mock *Mock
}

type AccessKeyMockExpectParam interface {
	ExtractQuery() builder.Query
	accessKeyModel()
}

func (m *accessKeyMock) Expect(query AccessKeyMockExpectParam) *accessKeyMockExec {
	return &accessKeyMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type accessKeyMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *accessKeyMockExec) Returns(v AccessKeyModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *accessKeyMockExec) ReturnsMany(v []AccessKeyModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *accessKeyMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type importMock struct {
	mock *Mock
}

type ImportMockExpectParam interface {
	ExtractQuery() builder.Query
	importModel()
}

func (m *importMock) Expect(query ImportMockExpectParam) *importMockExec {
	return &importMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type importMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *importMockExec) Returns(v ImportModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *importMockExec) ReturnsMany(v []ImportModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *importMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type productMock struct {
	mock *Mock
}

type ProductMockExpectParam interface {
	ExtractQuery() builder.Query
	productModel()
}

func (m *productMock) Expect(query ProductMockExpectParam) *productMockExec {
	return &productMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type productMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *productMockExec) Returns(v ProductModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *productMockExec) ReturnsMany(v []ProductModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *productMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type categoryMock struct {
	mock *Mock
}

type CategoryMockExpectParam interface {
	ExtractQuery() builder.Query
	categoryModel()
}

func (m *categoryMock) Expect(query CategoryMockExpectParam) *categoryMockExec {
	return &categoryMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type categoryMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *categoryMockExec) Returns(v CategoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *categoryMockExec) ReturnsMany(v []CategoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *categoryMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type categoryGroupMock struct {
	mock *Mock
}

type CategoryGroupMockExpectParam interface {
	ExtractQuery() builder.Query
	categoryGroupModel()
}

func (m *categoryGroupMock) Expect(query CategoryGroupMockExpectParam) *categoryGroupMockExec {
	return &categoryGroupMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type categoryGroupMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *categoryGroupMockExec) Returns(v CategoryGroupModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *categoryGroupMockExec) ReturnsMany(v []CategoryGroupModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *categoryGroupMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type categoryGroupCategoryMock struct {
	mock *Mock
}

type CategoryGroupCategoryMockExpectParam interface {
	ExtractQuery() builder.Query
	categoryGroupCategoryModel()
}

func (m *categoryGroupCategoryMock) Expect(query CategoryGroupCategoryMockExpectParam) *categoryGroupCategoryMockExec {
	return &categoryGroupCategoryMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type categoryGroupCategoryMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *categoryGroupCategoryMockExec) Returns(v CategoryGroupCategoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *categoryGroupCategoryMockExec) ReturnsMany(v []CategoryGroupCategoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *categoryGroupCategoryMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type storeMock struct {
	mock *Mock
}

type StoreMockExpectParam interface {
	ExtractQuery() builder.Query
	storeModel()
}

func (m *storeMock) Expect(query StoreMockExpectParam) *storeMockExec {
	return &storeMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type storeMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *storeMockExec) Returns(v StoreModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *storeMockExec) ReturnsMany(v []StoreModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *storeMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type userStoreMock struct {
	mock *Mock
}

type UserStoreMockExpectParam interface {
	ExtractQuery() builder.Query
	userStoreModel()
}

func (m *userStoreMock) Expect(query UserStoreMockExpectParam) *userStoreMockExec {
	return &userStoreMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userStoreMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userStoreMockExec) Returns(v UserStoreModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userStoreMockExec) ReturnsMany(v []UserStoreModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userStoreMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type holidayMock struct {
	mock *Mock
}

type HolidayMockExpectParam interface {
	ExtractQuery() builder.Query
	holidayModel()
}

func (m *holidayMock) Expect(query HolidayMockExpectParam) *holidayMockExec {
	return &holidayMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type holidayMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *holidayMockExec) Returns(v HolidayModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *holidayMockExec) ReturnsMany(v []HolidayModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *holidayMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type storeStatusMock struct {
	mock *Mock
}

type StoreStatusMockExpectParam interface {
	ExtractQuery() builder.Query
	storeStatusModel()
}

func (m *storeStatusMock) Expect(query StoreStatusMockExpectParam) *storeStatusMockExec {
	return &storeStatusMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type storeStatusMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *storeStatusMockExec) Returns(v StoreStatusModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *storeStatusMockExec) ReturnsMany(v []StoreStatusModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *storeStatusMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	UID       string    `json:"uid"`
	Role      *string   `json:"role,omitempty"`
	Name      string    `json:"name"`
	CreatedAt DateTime  `json:"createdAt"`
	UpdatedAt DateTime  `json:"updatedAt"`
	SynchedAt *DateTime `json:"synchedAt,omitempty"`
	DeletedAt *DateTime `json:"deletedAt,omitempty"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	UID       RawString    `json:"uid"`
	Role      *RawString   `json:"role,omitempty"`
	Name      RawString    `json:"name"`
	CreatedAt RawDateTime  `json:"createdAt"`
	UpdatedAt RawDateTime  `json:"updatedAt"`
	SynchedAt *RawDateTime `json:"synchedAt,omitempty"`
	DeletedAt *RawDateTime `json:"deletedAt,omitempty"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
}

func (r UserModel) Role() (value String, ok bool) {
	if r.InnerUser.Role == nil {
		return value, false
	}
	return *r.InnerUser.Role, true
}

func (r UserModel) SynchedAt() (value DateTime, ok bool) {
	if r.InnerUser.SynchedAt == nil {
		return value, false
	}
	return *r.InnerUser.SynchedAt, true
}

func (r UserModel) DeletedAt() (value DateTime, ok bool) {
	if r.InnerUser.DeletedAt == nil {
		return value, false
	}
	return *r.InnerUser.DeletedAt, true
}

// AccessKeyModel represents the AccessKey model and is a wrapper for accessing fields and methods
type AccessKeyModel struct {
	InnerAccessKey
	RelationsAccessKey
}

// InnerAccessKey holds the actual data
type InnerAccessKey struct {
	Name      string   `json:"name"`
	Value     string   `json:"value"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawAccessKeyModel is a struct for AccessKey when used in raw queries
type RawAccessKeyModel struct {
	Name      RawString   `json:"name"`
	Value     RawString   `json:"value"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsAccessKey holds the relation data separately
type RelationsAccessKey struct {
}

// ImportModel represents the Import model and is a wrapper for accessing fields and methods
type ImportModel struct {
	InnerImport
	RelationsImport
}

// InnerImport holds the actual data
type InnerImport struct {
	ID           int      `json:"id"`
	ResourceType string   `json:"resourceType"`
	Status       string   `json:"status"`
	Output       *string  `json:"output,omitempty"`
	CreatedAt    DateTime `json:"createdAt"`
	UpdatedAt    DateTime `json:"updatedAt"`
	ObjectKey    string   `json:"objectKey"`
}

// RawImportModel is a struct for Import when used in raw queries
type RawImportModel struct {
	ID           RawInt      `json:"id"`
	ResourceType RawString   `json:"resourceType"`
	Status       RawString   `json:"status"`
	Output       *RawString  `json:"output,omitempty"`
	CreatedAt    RawDateTime `json:"createdAt"`
	UpdatedAt    RawDateTime `json:"updatedAt"`
	ObjectKey    RawString   `json:"objectKey"`
}

// RelationsImport holds the relation data separately
type RelationsImport struct {
}

func (r ImportModel) Output() (value String, ok bool) {
	if r.InnerImport.Output == nil {
		return value, false
	}
	return *r.InnerImport.Output, true
}

// ProductModel represents the Product model and is a wrapper for accessing fields and methods
type ProductModel struct {
	InnerProduct
	RelationsProduct
}

// InnerProduct holds the actual data
type InnerProduct struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	CategoryID1 string   `json:"categoryId1"`
	CategoryID2 string   `json:"categoryId2"`
	CategoryID3 string   `json:"categoryId3"`
	CategoryID4 string   `json:"categoryId4"`
	CategoryID5 string   `json:"categoryId5"`
	Note        string   `json:"note"`
	Price       *int     `json:"price,omitempty"`
	Custom1     string   `json:"custom1"`
	Custom2     string   `json:"custom2"`
	Description string   `json:"description"`
	Details     string   `json:"details"`
	ImageURL1   string   `json:"imageUrl1"`
	ImageURL2   string   `json:"imageUrl2"`
	CreatedAt   DateTime `json:"createdAt"`
	UpdatedAt   DateTime `json:"updatedAt"`
}

// RawProductModel is a struct for Product when used in raw queries
type RawProductModel struct {
	ID          RawString   `json:"id"`
	Name        RawString   `json:"name"`
	CategoryID1 RawString   `json:"categoryId1"`
	CategoryID2 RawString   `json:"categoryId2"`
	CategoryID3 RawString   `json:"categoryId3"`
	CategoryID4 RawString   `json:"categoryId4"`
	CategoryID5 RawString   `json:"categoryId5"`
	Note        RawString   `json:"note"`
	Price       *RawInt     `json:"price,omitempty"`
	Custom1     RawString   `json:"custom1"`
	Custom2     RawString   `json:"custom2"`
	Description RawString   `json:"description"`
	Details     RawString   `json:"details"`
	ImageURL1   RawString   `json:"imageUrl1"`
	ImageURL2   RawString   `json:"imageUrl2"`
	CreatedAt   RawDateTime `json:"createdAt"`
	UpdatedAt   RawDateTime `json:"updatedAt"`
}

// RelationsProduct holds the relation data separately
type RelationsProduct struct {
}

func (r ProductModel) Price() (value Int, ok bool) {
	if r.InnerProduct.Price == nil {
		return value, false
	}
	return *r.InnerProduct.Price, true
}

// CategoryModel represents the Category model and is a wrapper for accessing fields and methods
type CategoryModel struct {
	InnerCategory
	RelationsCategory
}

// InnerCategory holds the actual data
type InnerCategory struct {
	CategoryID1   string `json:"categoryId1"`
	CategoryName1 string `json:"categoryName1"`
	CategoryID2   string `json:"categoryId2"`
	CategoryName2 string `json:"categoryName2"`
	CategoryID3   string `json:"categoryId3"`
	CategoryName3 string `json:"categoryName3"`
	CategoryID4   string `json:"categoryId4"`
	CategoryName4 string `json:"categoryName4"`
	CategoryID5   string `json:"categoryId5"`
	CategoryName5 string `json:"categoryName5"`
}

// RawCategoryModel is a struct for Category when used in raw queries
type RawCategoryModel struct {
	CategoryID1   RawString `json:"categoryId1"`
	CategoryName1 RawString `json:"categoryName1"`
	CategoryID2   RawString `json:"categoryId2"`
	CategoryName2 RawString `json:"categoryName2"`
	CategoryID3   RawString `json:"categoryId3"`
	CategoryName3 RawString `json:"categoryName3"`
	CategoryID4   RawString `json:"categoryId4"`
	CategoryName4 RawString `json:"categoryName4"`
	CategoryID5   RawString `json:"categoryId5"`
	CategoryName5 RawString `json:"categoryName5"`
}

// RelationsCategory holds the relation data separately
type RelationsCategory struct {
	CategoryGroupCategories []CategoryGroupCategoryModel `json:"categoryGroupCategories,omitempty"`
}

func (r CategoryModel) CategoryGroupCategories() (value []CategoryGroupCategoryModel) {
	if r.RelationsCategory.CategoryGroupCategories == nil {
		panic("attempted to access categoryGroupCategories but did not fetch it using the .With() syntax")
	}
	return r.RelationsCategory.CategoryGroupCategories
}

// CategoryGroupModel represents the CategoryGroup model and is a wrapper for accessing fields and methods
type CategoryGroupModel struct {
	InnerCategoryGroup
	RelationsCategoryGroup
}

// InnerCategoryGroup holds the actual data
type InnerCategoryGroup struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Level     int      `json:"level"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawCategoryGroupModel is a struct for CategoryGroup when used in raw queries
type RawCategoryGroupModel struct {
	ID        RawString   `json:"id"`
	Name      RawString   `json:"name"`
	Level     RawInt      `json:"level"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsCategoryGroup holds the relation data separately
type RelationsCategoryGroup struct {
	CategoryGroupCategories []CategoryGroupCategoryModel `json:"categoryGroupCategories,omitempty"`
}

func (r CategoryGroupModel) CategoryGroupCategories() (value []CategoryGroupCategoryModel) {
	if r.RelationsCategoryGroup.CategoryGroupCategories == nil {
		panic("attempted to access categoryGroupCategories but did not fetch it using the .With() syntax")
	}
	return r.RelationsCategoryGroup.CategoryGroupCategories
}

// CategoryGroupCategoryModel represents the CategoryGroupCategory model and is a wrapper for accessing fields and methods
type CategoryGroupCategoryModel struct {
	InnerCategoryGroupCategory
	RelationsCategoryGroupCategory
}

// InnerCategoryGroupCategory holds the actual data
type InnerCategoryGroupCategory struct {
	CategoryID1     string `json:"categoryId1"`
	CategoryID2     string `json:"categoryId2"`
	CategoryID3     string `json:"categoryId3"`
	CategoryID4     string `json:"categoryId4"`
	CategoryID5     string `json:"categoryId5"`
	CategoryGroupID string `json:"categoryGroupId"`
}

// RawCategoryGroupCategoryModel is a struct for CategoryGroupCategory when used in raw queries
type RawCategoryGroupCategoryModel struct {
	CategoryID1     RawString `json:"categoryId1"`
	CategoryID2     RawString `json:"categoryId2"`
	CategoryID3     RawString `json:"categoryId3"`
	CategoryID4     RawString `json:"categoryId4"`
	CategoryID5     RawString `json:"categoryId5"`
	CategoryGroupID RawString `json:"categoryGroupId"`
}

// RelationsCategoryGroupCategory holds the relation data separately
type RelationsCategoryGroupCategory struct {
	Category      *CategoryModel      `json:"category,omitempty"`
	CategoryGroup *CategoryGroupModel `json:"categoryGroup,omitempty"`
}

func (r CategoryGroupCategoryModel) Category() (value *CategoryModel) {
	if r.RelationsCategoryGroupCategory.Category == nil {
		panic("attempted to access category but did not fetch it using the .With() syntax")
	}
	return r.RelationsCategoryGroupCategory.Category
}

func (r CategoryGroupCategoryModel) CategoryGroup() (value *CategoryGroupModel) {
	if r.RelationsCategoryGroupCategory.CategoryGroup == nil {
		panic("attempted to access categoryGroup but did not fetch it using the .With() syntax")
	}
	return r.RelationsCategoryGroupCategory.CategoryGroup
}

// StoreModel represents the Store model and is a wrapper for accessing fields and methods
type StoreModel struct {
	InnerStore
	RelationsStore
}

// InnerStore holds the actual data
type InnerStore struct {
	ID             string   `json:"id"`
	Name           string   `json:"name"`
	SalesFloorArea *float64 `json:"salesFloorArea,omitempty"`
	CreatedAt      DateTime `json:"createdAt"`
	UpdatedAt      DateTime `json:"updatedAt"`
}

// RawStoreModel is a struct for Store when used in raw queries
type RawStoreModel struct {
	ID             RawString   `json:"id"`
	Name           RawString   `json:"name"`
	SalesFloorArea *RawFloat   `json:"salesFloorArea,omitempty"`
	CreatedAt      RawDateTime `json:"createdAt"`
	UpdatedAt      RawDateTime `json:"updatedAt"`
}

// RelationsStore holds the relation data separately
type RelationsStore struct {
	UserStore []UserStoreModel `json:"userStore,omitempty"`
}

func (r StoreModel) SalesFloorArea() (value Float, ok bool) {
	if r.InnerStore.SalesFloorArea == nil {
		return value, false
	}
	return *r.InnerStore.SalesFloorArea, true
}

func (r StoreModel) UserStore() (value []UserStoreModel) {
	if r.RelationsStore.UserStore == nil {
		panic("attempted to access userStore but did not fetch it using the .With() syntax")
	}
	return r.RelationsStore.UserStore
}

// UserStoreModel represents the UserStore model and is a wrapper for accessing fields and methods
type UserStoreModel struct {
	InnerUserStore
	RelationsUserStore
}

// InnerUserStore holds the actual data
type InnerUserStore struct {
	Email     string   `json:"email"`
	Name      string   `json:"name"`
	StoreID   string   `json:"storeId"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
}

// RawUserStoreModel is a struct for UserStore when used in raw queries
type RawUserStoreModel struct {
	Email     RawString   `json:"email"`
	Name      RawString   `json:"name"`
	StoreID   RawString   `json:"storeId"`
	CreatedAt RawDateTime `json:"createdAt"`
	UpdatedAt RawDateTime `json:"updatedAt"`
}

// RelationsUserStore holds the relation data separately
type RelationsUserStore struct {
	Store *StoreModel `json:"store,omitempty"`
}

func (r UserStoreModel) Store() (value *StoreModel) {
	if r.RelationsUserStore.Store == nil {
		panic("attempted to access store but did not fetch it using the .With() syntax")
	}
	return r.RelationsUserStore.Store
}

// HolidayModel represents the Holiday model and is a wrapper for accessing fields and methods
type HolidayModel struct {
	InnerHoliday
	RelationsHoliday
}

// InnerHoliday holds the actual data
type InnerHoliday struct {
	Date DateTime `json:"date"`
	Name string   `json:"name"`
}

// RawHolidayModel is a struct for Holiday when used in raw queries
type RawHolidayModel struct {
	Date RawDateTime `json:"date"`
	Name RawString   `json:"name"`
}

// RelationsHoliday holds the relation data separately
type RelationsHoliday struct {
}

// StoreStatusModel represents the StoreStatus model and is a wrapper for accessing fields and methods
type StoreStatusModel struct {
	InnerStoreStatus
	RelationsStoreStatus
}

// InnerStoreStatus holds the actual data
type InnerStoreStatus struct {
	StoreID    string   `json:"storeId"`
	Date       DateTime `json:"date"`
	IsOpen     bool     `json:"isOpen"`
	IsExisting bool     `json:"isExisting"`
	CreatedAt  DateTime `json:"createdAt"`
	UpdatedAt  DateTime `json:"updatedAt"`
}

// RawStoreStatusModel is a struct for StoreStatus when used in raw queries
type RawStoreStatusModel struct {
	StoreID    RawString   `json:"storeId"`
	Date       RawDateTime `json:"date"`
	IsOpen     RawBoolean  `json:"isOpen"`
	IsExisting RawBoolean  `json:"isExisting"`
	CreatedAt  RawDateTime `json:"createdAt"`
	UpdatedAt  RawDateTime `json:"updatedAt"`
}

// RelationsStoreStatus holds the relation data separately
type RelationsStoreStatus struct {
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// UID
	//
	// @required
	UID userQueryUIDString

	// Role
	//
	// @optional
	Role userQueryRoleString

	// Name
	//
	// @required
	Name userQueryNameString

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userQueryUpdatedAtDateTime

	// SynchedAt
	//
	// @optional
	SynchedAt userQuerySynchedAtDateTime

	// DeletedAt
	//
	// @optional
	DeletedAt userQueryDeletedAtDateTime

	// Relevance_
	//
	// @optional
	Relevance_ userQueryRelevanceUserOrderByRelevanceInput
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryUIDString struct{}

// Set the required value of UID
func (r userQueryUIDString) Set(value string) userWithPrismaUIDSetParam {

	return userWithPrismaUIDSetParam{
		data: builder.Field{
			Name:  "uid",
			Value: value,
		},
	}

}

// Set the optional value of UID dynamically
func (r userQueryUIDString) SetIfPresent(value *String) userWithPrismaUIDSetParam {
	if value == nil {
		return userWithPrismaUIDSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUIDString) Equals(value string) userWithPrismaUIDEqualsUniqueParam {

	return userWithPrismaUIDEqualsUniqueParam{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) EqualsIfPresent(value *string) userWithPrismaUIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaUIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "uid",
			Value: direction,
		},
	}
}

func (r userQueryUIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "uid",
			Value: cursor,
		},
	}
}

func (r userQueryUIDString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryUIDString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryUIDString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryUIDString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryUIDString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryUIDString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryUIDString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryUIDString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryUIDString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryUIDString) Search(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) SearchIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Search(*value)
}

func (r userQueryUIDString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryUIDString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryUIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryUIDString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "uid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryUIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryUIDString) Field() userPrismaFields {
	return userFieldUID
}

// base struct
type userQueryRoleString struct{}

// Set the optional value of Role
func (r userQueryRoleString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "role",
			Value: value,
		},
	}

}

// Set the optional value of Role dynamically
func (r userQueryRoleString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Role dynamically
func (r userQueryRoleString) SetOptional(value *String) userSetParam {
	if value == nil {

		var v *string
		return userSetParam{
			data: builder.Field{
				Name:  "role",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r userQueryRoleString) Equals(value string) userWithPrismaRoleEqualsParam {

	return userWithPrismaRoleEqualsParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) EqualsIfPresent(value *string) userWithPrismaRoleEqualsParam {
	if value == nil {
		return userWithPrismaRoleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryRoleString) EqualsOptional(value *String) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) IsNull() userDefaultParam {
	var str *string = nil
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r userQueryRoleString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "role",
			Value: direction,
		},
	}
}

func (r userQueryRoleString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "role",
			Value: cursor,
		},
	}
}

func (r userQueryRoleString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryRoleString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryRoleString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryRoleString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryRoleString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryRoleString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryRoleString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryRoleString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryRoleString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryRoleString) Search(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) SearchIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Search(*value)
}

func (r userQueryRoleString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRoleString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryRoleString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryRoleString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryRoleString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryRoleString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryRoleString) Field() userPrismaFields {
	return userFieldRole
}

// base struct
type userQueryNameString struct{}

// Set the required value of Name
func (r userQueryNameString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r userQueryNameString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryNameString) Equals(value string) userWithPrismaNameEqualsParam {

	return userWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) EqualsIfPresent(value *string) userWithPrismaNameEqualsParam {
	if value == nil {
		return userWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r userQueryNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r userQueryNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryNameString) Search(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) SearchIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Search(*value)
}

func (r userQueryNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryNameString) Field() userPrismaFields {
	return userFieldName
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userWithPrismaCreatedAtEqualsParam {

	return userWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCreatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCreatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCreatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCreatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCreatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCreatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCreatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryCreatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryCreatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryCreatedAtDateTime) Field() userPrismaFields {
	return userFieldCreatedAt
}

// base struct
type userQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userQueryUpdatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUpdatedAtDateTime) Equals(value DateTime) userWithPrismaUpdatedAtEqualsParam {

	return userWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUpdatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r userQueryUpdatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r userQueryUpdatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUpdatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUpdatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUpdatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUpdatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUpdatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUpdatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryUpdatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryUpdatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryUpdatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryUpdatedAtDateTime) Field() userPrismaFields {
	return userFieldUpdatedAt
}

// base struct
type userQuerySynchedAtDateTime struct{}

// Set the optional value of SynchedAt
func (r userQuerySynchedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "synchedAt",
			Value: value,
		},
	}

}

// Set the optional value of SynchedAt dynamically
func (r userQuerySynchedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of SynchedAt dynamically
func (r userQuerySynchedAtDateTime) SetOptional(value *DateTime) userSetParam {
	if value == nil {

		var v *DateTime
		return userSetParam{
			data: builder.Field{
				Name:  "synchedAt",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r userQuerySynchedAtDateTime) Equals(value DateTime) userWithPrismaSynchedAtEqualsParam {

	return userWithPrismaSynchedAtEqualsParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaSynchedAtEqualsParam {
	if value == nil {
		return userWithPrismaSynchedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQuerySynchedAtDateTime) EqualsOptional(value *DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) IsNull() userDefaultParam {
	var str *string = nil
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "synchedAt",
			Value: direction,
		},
	}
}

func (r userQuerySynchedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "synchedAt",
			Value: cursor,
		},
	}
}

func (r userQuerySynchedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQuerySynchedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQuerySynchedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQuerySynchedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQuerySynchedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQuerySynchedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQuerySynchedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySynchedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQuerySynchedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQuerySynchedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQuerySynchedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQuerySynchedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQuerySynchedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQuerySynchedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQuerySynchedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "synchedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQuerySynchedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQuerySynchedAtDateTime) Field() userPrismaFields {
	return userFieldSynchedAt
}

// base struct
type userQueryDeletedAtDateTime struct{}

// Set the optional value of DeletedAt
func (r userQueryDeletedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "deletedAt",
			Value: value,
		},
	}

}

// Set the optional value of DeletedAt dynamically
func (r userQueryDeletedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of DeletedAt dynamically
func (r userQueryDeletedAtDateTime) SetOptional(value *DateTime) userSetParam {
	if value == nil {

		var v *DateTime
		return userSetParam{
			data: builder.Field{
				Name:  "deletedAt",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r userQueryDeletedAtDateTime) Equals(value DateTime) userWithPrismaDeletedAtEqualsParam {

	return userWithPrismaDeletedAtEqualsParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaDeletedAtEqualsParam {
	if value == nil {
		return userWithPrismaDeletedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryDeletedAtDateTime) EqualsOptional(value *DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) IsNull() userDefaultParam {
	var str *string = nil
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "deletedAt",
			Value: direction,
		},
	}
}

func (r userQueryDeletedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "deletedAt",
			Value: cursor,
		},
	}
}

func (r userQueryDeletedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryDeletedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryDeletedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryDeletedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryDeletedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryDeletedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryDeletedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDeletedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryDeletedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryDeletedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryDeletedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryDeletedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryDeletedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryDeletedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryDeletedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "deletedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryDeletedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryDeletedAtDateTime) Field() userPrismaFields {
	return userFieldDeletedAt
}

// base struct
type userQueryRelevanceUserOrderByRelevanceInput struct{}

func (r userQueryRelevanceUserOrderByRelevanceInput) Fields(value []UserOrderByRelevanceFieldEnum) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRelevanceUserOrderByRelevanceInput) FieldsIfPresent(value []UserOrderByRelevanceFieldEnum) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Fields(value)
}

func (r userQueryRelevanceUserOrderByRelevanceInput) Sort(value SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRelevanceUserOrderByRelevanceInput) SortIfPresent(value *SortOrder) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Sort(*value)
}

func (r userQueryRelevanceUserOrderByRelevanceInput) Search(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryRelevanceUserOrderByRelevanceInput) SearchIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Search(*value)
}

func (r userQueryRelevanceUserOrderByRelevanceInput) Field() userPrismaFields {
	return userFieldRelevance
}

// AccessKey acts as a namespaces to access query methods for the AccessKey model
var AccessKey = accessKeyQuery{}

// accessKeyQuery exposes query functions for the accessKey model
type accessKeyQuery struct {

	// Name
	//
	// @required
	Name accessKeyQueryNameString

	// Value
	//
	// @required
	Value accessKeyQueryValueString

	// CreatedAt
	//
	// @required
	CreatedAt accessKeyQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt accessKeyQueryUpdatedAtDateTime

	// Relevance_
	//
	// @optional
	Relevance_ accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput
}

func (accessKeyQuery) Not(params ...AccessKeyWhereParam) accessKeyDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return accessKeyDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (accessKeyQuery) Or(params ...AccessKeyWhereParam) accessKeyDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return accessKeyDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (accessKeyQuery) And(params ...AccessKeyWhereParam) accessKeyDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return accessKeyDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type accessKeyQueryNameString struct{}

// Set the required value of Name
func (r accessKeyQueryNameString) Set(value string) accessKeyWithPrismaNameSetParam {

	return accessKeyWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r accessKeyQueryNameString) SetIfPresent(value *String) accessKeyWithPrismaNameSetParam {
	if value == nil {
		return accessKeyWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r accessKeyQueryNameString) Equals(value string) accessKeyWithPrismaNameEqualsUniqueParam {

	return accessKeyWithPrismaNameEqualsUniqueParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) EqualsIfPresent(value *string) accessKeyWithPrismaNameEqualsUniqueParam {
	if value == nil {
		return accessKeyWithPrismaNameEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r accessKeyQueryNameString) Order(direction SortOrder) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r accessKeyQueryNameString) Cursor(cursor string) accessKeyCursorParam {
	return accessKeyCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r accessKeyQueryNameString) In(value []string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) InIfPresent(value []string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.In(value)
}

func (r accessKeyQueryNameString) NotIn(value []string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) NotInIfPresent(value []string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.NotIn(value)
}

func (r accessKeyQueryNameString) Lt(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) LtIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.Lt(*value)
}

func (r accessKeyQueryNameString) Lte(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) LteIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.Lte(*value)
}

func (r accessKeyQueryNameString) Gt(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) GtIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.Gt(*value)
}

func (r accessKeyQueryNameString) Gte(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) GteIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.Gte(*value)
}

func (r accessKeyQueryNameString) Contains(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) ContainsIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.Contains(*value)
}

func (r accessKeyQueryNameString) StartsWith(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) StartsWithIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r accessKeyQueryNameString) EndsWith(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) EndsWithIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r accessKeyQueryNameString) Search(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) SearchIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.Search(*value)
}

func (r accessKeyQueryNameString) Not(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryNameString) NotIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r accessKeyQueryNameString) HasPrefix(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r accessKeyQueryNameString) HasPrefixIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r accessKeyQueryNameString) HasSuffix(value string) accessKeyParamUnique {
	return accessKeyParamUnique{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r accessKeyQueryNameString) HasSuffixIfPresent(value *string) accessKeyParamUnique {
	if value == nil {
		return accessKeyParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r accessKeyQueryNameString) Field() accessKeyPrismaFields {
	return accessKeyFieldName
}

// base struct
type accessKeyQueryValueString struct{}

// Set the required value of Value
func (r accessKeyQueryValueString) Set(value string) accessKeyWithPrismaValueSetParam {

	return accessKeyWithPrismaValueSetParam{
		data: builder.Field{
			Name:  "value",
			Value: value,
		},
	}

}

// Set the optional value of Value dynamically
func (r accessKeyQueryValueString) SetIfPresent(value *String) accessKeyWithPrismaValueSetParam {
	if value == nil {
		return accessKeyWithPrismaValueSetParam{}
	}

	return r.Set(*value)
}

func (r accessKeyQueryValueString) Equals(value string) accessKeyWithPrismaValueEqualsParam {

	return accessKeyWithPrismaValueEqualsParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) EqualsIfPresent(value *string) accessKeyWithPrismaValueEqualsParam {
	if value == nil {
		return accessKeyWithPrismaValueEqualsParam{}
	}
	return r.Equals(*value)
}

func (r accessKeyQueryValueString) Order(direction SortOrder) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name:  "value",
			Value: direction,
		},
	}
}

func (r accessKeyQueryValueString) Cursor(cursor string) accessKeyCursorParam {
	return accessKeyCursorParam{
		data: builder.Field{
			Name:  "value",
			Value: cursor,
		},
	}
}

func (r accessKeyQueryValueString) In(value []string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) InIfPresent(value []string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.In(value)
}

func (r accessKeyQueryValueString) NotIn(value []string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) NotInIfPresent(value []string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.NotIn(value)
}

func (r accessKeyQueryValueString) Lt(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) LtIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Lt(*value)
}

func (r accessKeyQueryValueString) Lte(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) LteIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Lte(*value)
}

func (r accessKeyQueryValueString) Gt(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) GtIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Gt(*value)
}

func (r accessKeyQueryValueString) Gte(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) GteIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Gte(*value)
}

func (r accessKeyQueryValueString) Contains(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) ContainsIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Contains(*value)
}

func (r accessKeyQueryValueString) StartsWith(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) StartsWithIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r accessKeyQueryValueString) EndsWith(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) EndsWithIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r accessKeyQueryValueString) Search(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) SearchIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Search(*value)
}

func (r accessKeyQueryValueString) Not(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryValueString) NotIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r accessKeyQueryValueString) HasPrefix(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r accessKeyQueryValueString) HasPrefixIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r accessKeyQueryValueString) HasSuffix(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "value",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r accessKeyQueryValueString) HasSuffixIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r accessKeyQueryValueString) Field() accessKeyPrismaFields {
	return accessKeyFieldValue
}

// base struct
type accessKeyQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r accessKeyQueryCreatedAtDateTime) Set(value DateTime) accessKeySetParam {

	return accessKeySetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r accessKeyQueryCreatedAtDateTime) SetIfPresent(value *DateTime) accessKeySetParam {
	if value == nil {
		return accessKeySetParam{}
	}

	return r.Set(*value)
}

func (r accessKeyQueryCreatedAtDateTime) Equals(value DateTime) accessKeyWithPrismaCreatedAtEqualsParam {

	return accessKeyWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) accessKeyWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return accessKeyWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r accessKeyQueryCreatedAtDateTime) Order(direction SortOrder) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) Cursor(cursor DateTime) accessKeyCursorParam {
	return accessKeyCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) In(value []DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) InIfPresent(value []DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.In(value)
}

func (r accessKeyQueryCreatedAtDateTime) NotIn(value []DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.NotIn(value)
}

func (r accessKeyQueryCreatedAtDateTime) Lt(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) LtIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Lt(*value)
}

func (r accessKeyQueryCreatedAtDateTime) Lte(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) LteIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Lte(*value)
}

func (r accessKeyQueryCreatedAtDateTime) Gt(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) GtIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Gt(*value)
}

func (r accessKeyQueryCreatedAtDateTime) Gte(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) GteIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Gte(*value)
}

func (r accessKeyQueryCreatedAtDateTime) Not(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryCreatedAtDateTime) NotIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r accessKeyQueryCreatedAtDateTime) Before(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r accessKeyQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r accessKeyQueryCreatedAtDateTime) After(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r accessKeyQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r accessKeyQueryCreatedAtDateTime) BeforeEquals(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r accessKeyQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r accessKeyQueryCreatedAtDateTime) AfterEquals(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r accessKeyQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r accessKeyQueryCreatedAtDateTime) Field() accessKeyPrismaFields {
	return accessKeyFieldCreatedAt
}

// base struct
type accessKeyQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r accessKeyQueryUpdatedAtDateTime) Set(value DateTime) accessKeySetParam {

	return accessKeySetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r accessKeyQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) accessKeySetParam {
	if value == nil {
		return accessKeySetParam{}
	}

	return r.Set(*value)
}

func (r accessKeyQueryUpdatedAtDateTime) Equals(value DateTime) accessKeyWithPrismaUpdatedAtEqualsParam {

	return accessKeyWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) accessKeyWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return accessKeyWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r accessKeyQueryUpdatedAtDateTime) Order(direction SortOrder) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) Cursor(cursor DateTime) accessKeyCursorParam {
	return accessKeyCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) In(value []DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) InIfPresent(value []DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.In(value)
}

func (r accessKeyQueryUpdatedAtDateTime) NotIn(value []DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.NotIn(value)
}

func (r accessKeyQueryUpdatedAtDateTime) Lt(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Lt(*value)
}

func (r accessKeyQueryUpdatedAtDateTime) Lte(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Lte(*value)
}

func (r accessKeyQueryUpdatedAtDateTime) Gt(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Gt(*value)
}

func (r accessKeyQueryUpdatedAtDateTime) Gte(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Gte(*value)
}

func (r accessKeyQueryUpdatedAtDateTime) Not(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r accessKeyQueryUpdatedAtDateTime) Before(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r accessKeyQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r accessKeyQueryUpdatedAtDateTime) After(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r accessKeyQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r accessKeyQueryUpdatedAtDateTime) BeforeEquals(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r accessKeyQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r accessKeyQueryUpdatedAtDateTime) AfterEquals(value DateTime) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r accessKeyQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r accessKeyQueryUpdatedAtDateTime) Field() accessKeyPrismaFields {
	return accessKeyFieldUpdatedAt
}

// base struct
type accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput struct{}

func (r accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput) Fields(value []AccessKeyOrderByRelevanceFieldEnum) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput) FieldsIfPresent(value []AccessKeyOrderByRelevanceFieldEnum) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Fields(value)
}

func (r accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput) Sort(value SortOrder) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput) SortIfPresent(value *SortOrder) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Sort(*value)
}

func (r accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput) Search(value string) accessKeyDefaultParam {
	return accessKeyDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput) SearchIfPresent(value *string) accessKeyDefaultParam {
	if value == nil {
		return accessKeyDefaultParam{}
	}
	return r.Search(*value)
}

func (r accessKeyQueryRelevanceAccessKeyOrderByRelevanceInput) Field() accessKeyPrismaFields {
	return accessKeyFieldRelevance
}

// Import acts as a namespaces to access query methods for the Import model
var Import = importQuery{}

// importQuery exposes query functions for the import model
type importQuery struct {

	// ID
	//
	// @required
	ID importQueryIDInt

	// ResourceType
	//
	// @required
	ResourceType importQueryResourceTypeString

	// Status
	//
	// @required
	Status importQueryStatusString

	// Output
	//
	// @optional
	Output importQueryOutputString

	// CreatedAt
	//
	// @required
	CreatedAt importQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt importQueryUpdatedAtDateTime

	// ObjectKey
	//
	// @required
	ObjectKey importQueryObjectKeyString

	// Relevance_
	//
	// @optional
	Relevance_ importQueryRelevanceImportOrderByRelevanceInput
}

func (importQuery) Not(params ...ImportWhereParam) importDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return importDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (importQuery) Or(params ...ImportWhereParam) importDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return importDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (importQuery) And(params ...ImportWhereParam) importDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return importDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type importQueryIDInt struct{}

// Set the required value of ID
func (r importQueryIDInt) Set(value int) importSetParam {

	return importSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r importQueryIDInt) SetIfPresent(value *Int) importSetParam {
	if value == nil {
		return importSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r importQueryIDInt) Increment(value int) importSetParam {
	return importSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) IncrementIfPresent(value *int) importSetParam {
	if value == nil {
		return importSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r importQueryIDInt) Decrement(value int) importSetParam {
	return importSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) DecrementIfPresent(value *int) importSetParam {
	if value == nil {
		return importSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r importQueryIDInt) Multiply(value int) importSetParam {
	return importSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) MultiplyIfPresent(value *int) importSetParam {
	if value == nil {
		return importSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r importQueryIDInt) Divide(value int) importSetParam {
	return importSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) DivideIfPresent(value *int) importSetParam {
	if value == nil {
		return importSetParam{}
	}
	return r.Divide(*value)
}

func (r importQueryIDInt) Equals(value int) importWithPrismaIDEqualsUniqueParam {

	return importWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) EqualsIfPresent(value *int) importWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return importWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r importQueryIDInt) Order(direction SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r importQueryIDInt) Cursor(cursor int) importCursorParam {
	return importCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r importQueryIDInt) In(value []int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) InIfPresent(value []int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.In(value)
}

func (r importQueryIDInt) NotIn(value []int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) NotInIfPresent(value []int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.NotIn(value)
}

func (r importQueryIDInt) Lt(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) LtIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.Lt(*value)
}

func (r importQueryIDInt) Lte(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) LteIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.Lte(*value)
}

func (r importQueryIDInt) Gt(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) GtIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.Gt(*value)
}

func (r importQueryIDInt) Gte(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) GteIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.Gte(*value)
}

func (r importQueryIDInt) Not(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryIDInt) NotIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r importQueryIDInt) LT(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r importQueryIDInt) LTIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r importQueryIDInt) LTE(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r importQueryIDInt) LTEIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r importQueryIDInt) GT(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r importQueryIDInt) GTIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r importQueryIDInt) GTE(value int) importParamUnique {
	return importParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r importQueryIDInt) GTEIfPresent(value *int) importParamUnique {
	if value == nil {
		return importParamUnique{}
	}
	return r.GTE(*value)
}

func (r importQueryIDInt) Field() importPrismaFields {
	return importFieldID
}

// base struct
type importQueryResourceTypeString struct{}

// Set the required value of ResourceType
func (r importQueryResourceTypeString) Set(value string) importWithPrismaResourceTypeSetParam {

	return importWithPrismaResourceTypeSetParam{
		data: builder.Field{
			Name:  "resourceType",
			Value: value,
		},
	}

}

// Set the optional value of ResourceType dynamically
func (r importQueryResourceTypeString) SetIfPresent(value *String) importWithPrismaResourceTypeSetParam {
	if value == nil {
		return importWithPrismaResourceTypeSetParam{}
	}

	return r.Set(*value)
}

func (r importQueryResourceTypeString) Equals(value string) importWithPrismaResourceTypeEqualsParam {

	return importWithPrismaResourceTypeEqualsParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) EqualsIfPresent(value *string) importWithPrismaResourceTypeEqualsParam {
	if value == nil {
		return importWithPrismaResourceTypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r importQueryResourceTypeString) Order(direction SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name:  "resourceType",
			Value: direction,
		},
	}
}

func (r importQueryResourceTypeString) Cursor(cursor string) importCursorParam {
	return importCursorParam{
		data: builder.Field{
			Name:  "resourceType",
			Value: cursor,
		},
	}
}

func (r importQueryResourceTypeString) In(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) InIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.In(value)
}

func (r importQueryResourceTypeString) NotIn(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) NotInIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.NotIn(value)
}

func (r importQueryResourceTypeString) Lt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) LtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lt(*value)
}

func (r importQueryResourceTypeString) Lte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) LteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lte(*value)
}

func (r importQueryResourceTypeString) Gt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) GtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gt(*value)
}

func (r importQueryResourceTypeString) Gte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) GteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gte(*value)
}

func (r importQueryResourceTypeString) Contains(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) ContainsIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Contains(*value)
}

func (r importQueryResourceTypeString) StartsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) StartsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r importQueryResourceTypeString) EndsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) EndsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r importQueryResourceTypeString) Search(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) SearchIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Search(*value)
}

func (r importQueryResourceTypeString) Not(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryResourceTypeString) NotIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r importQueryResourceTypeString) HasPrefix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r importQueryResourceTypeString) HasPrefixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r importQueryResourceTypeString) HasSuffix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "resourceType",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r importQueryResourceTypeString) HasSuffixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r importQueryResourceTypeString) Field() importPrismaFields {
	return importFieldResourceType
}

// base struct
type importQueryStatusString struct{}

// Set the required value of Status
func (r importQueryStatusString) Set(value string) importWithPrismaStatusSetParam {

	return importWithPrismaStatusSetParam{
		data: builder.Field{
			Name:  "status",
			Value: value,
		},
	}

}

// Set the optional value of Status dynamically
func (r importQueryStatusString) SetIfPresent(value *String) importWithPrismaStatusSetParam {
	if value == nil {
		return importWithPrismaStatusSetParam{}
	}

	return r.Set(*value)
}

func (r importQueryStatusString) Equals(value string) importWithPrismaStatusEqualsParam {

	return importWithPrismaStatusEqualsParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) EqualsIfPresent(value *string) importWithPrismaStatusEqualsParam {
	if value == nil {
		return importWithPrismaStatusEqualsParam{}
	}
	return r.Equals(*value)
}

func (r importQueryStatusString) Order(direction SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name:  "status",
			Value: direction,
		},
	}
}

func (r importQueryStatusString) Cursor(cursor string) importCursorParam {
	return importCursorParam{
		data: builder.Field{
			Name:  "status",
			Value: cursor,
		},
	}
}

func (r importQueryStatusString) In(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) InIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.In(value)
}

func (r importQueryStatusString) NotIn(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) NotInIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.NotIn(value)
}

func (r importQueryStatusString) Lt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) LtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lt(*value)
}

func (r importQueryStatusString) Lte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) LteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lte(*value)
}

func (r importQueryStatusString) Gt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) GtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gt(*value)
}

func (r importQueryStatusString) Gte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) GteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gte(*value)
}

func (r importQueryStatusString) Contains(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) ContainsIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Contains(*value)
}

func (r importQueryStatusString) StartsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) StartsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r importQueryStatusString) EndsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) EndsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r importQueryStatusString) Search(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) SearchIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Search(*value)
}

func (r importQueryStatusString) Not(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryStatusString) NotIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r importQueryStatusString) HasPrefix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r importQueryStatusString) HasPrefixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r importQueryStatusString) HasSuffix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r importQueryStatusString) HasSuffixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r importQueryStatusString) Field() importPrismaFields {
	return importFieldStatus
}

// base struct
type importQueryOutputString struct{}

// Set the optional value of Output
func (r importQueryOutputString) Set(value string) importSetParam {

	return importSetParam{
		data: builder.Field{
			Name:  "output",
			Value: value,
		},
	}

}

// Set the optional value of Output dynamically
func (r importQueryOutputString) SetIfPresent(value *String) importSetParam {
	if value == nil {
		return importSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Output dynamically
func (r importQueryOutputString) SetOptional(value *String) importSetParam {
	if value == nil {

		var v *string
		return importSetParam{
			data: builder.Field{
				Name:  "output",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r importQueryOutputString) Equals(value string) importWithPrismaOutputEqualsParam {

	return importWithPrismaOutputEqualsParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) EqualsIfPresent(value *string) importWithPrismaOutputEqualsParam {
	if value == nil {
		return importWithPrismaOutputEqualsParam{}
	}
	return r.Equals(*value)
}

func (r importQueryOutputString) EqualsOptional(value *String) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) IsNull() importDefaultParam {
	var str *string = nil
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r importQueryOutputString) Order(direction SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name:  "output",
			Value: direction,
		},
	}
}

func (r importQueryOutputString) Cursor(cursor string) importCursorParam {
	return importCursorParam{
		data: builder.Field{
			Name:  "output",
			Value: cursor,
		},
	}
}

func (r importQueryOutputString) In(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) InIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.In(value)
}

func (r importQueryOutputString) NotIn(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) NotInIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.NotIn(value)
}

func (r importQueryOutputString) Lt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) LtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lt(*value)
}

func (r importQueryOutputString) Lte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) LteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lte(*value)
}

func (r importQueryOutputString) Gt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) GtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gt(*value)
}

func (r importQueryOutputString) Gte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) GteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gte(*value)
}

func (r importQueryOutputString) Contains(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) ContainsIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Contains(*value)
}

func (r importQueryOutputString) StartsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) StartsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r importQueryOutputString) EndsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) EndsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r importQueryOutputString) Search(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) SearchIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Search(*value)
}

func (r importQueryOutputString) Not(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryOutputString) NotIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r importQueryOutputString) HasPrefix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r importQueryOutputString) HasPrefixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r importQueryOutputString) HasSuffix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "output",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r importQueryOutputString) HasSuffixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r importQueryOutputString) Field() importPrismaFields {
	return importFieldOutput
}

// base struct
type importQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r importQueryCreatedAtDateTime) Set(value DateTime) importSetParam {

	return importSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r importQueryCreatedAtDateTime) SetIfPresent(value *DateTime) importSetParam {
	if value == nil {
		return importSetParam{}
	}

	return r.Set(*value)
}

func (r importQueryCreatedAtDateTime) Equals(value DateTime) importWithPrismaCreatedAtEqualsParam {

	return importWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) importWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return importWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r importQueryCreatedAtDateTime) Order(direction SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r importQueryCreatedAtDateTime) Cursor(cursor DateTime) importCursorParam {
	return importCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r importQueryCreatedAtDateTime) In(value []DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) InIfPresent(value []DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.In(value)
}

func (r importQueryCreatedAtDateTime) NotIn(value []DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.NotIn(value)
}

func (r importQueryCreatedAtDateTime) Lt(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) LtIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lt(*value)
}

func (r importQueryCreatedAtDateTime) Lte(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) LteIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lte(*value)
}

func (r importQueryCreatedAtDateTime) Gt(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) GtIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gt(*value)
}

func (r importQueryCreatedAtDateTime) Gte(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) GteIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gte(*value)
}

func (r importQueryCreatedAtDateTime) Not(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryCreatedAtDateTime) NotIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r importQueryCreatedAtDateTime) Before(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r importQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r importQueryCreatedAtDateTime) After(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r importQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r importQueryCreatedAtDateTime) BeforeEquals(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r importQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r importQueryCreatedAtDateTime) AfterEquals(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r importQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r importQueryCreatedAtDateTime) Field() importPrismaFields {
	return importFieldCreatedAt
}

// base struct
type importQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r importQueryUpdatedAtDateTime) Set(value DateTime) importSetParam {

	return importSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r importQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) importSetParam {
	if value == nil {
		return importSetParam{}
	}

	return r.Set(*value)
}

func (r importQueryUpdatedAtDateTime) Equals(value DateTime) importWithPrismaUpdatedAtEqualsParam {

	return importWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) importWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return importWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r importQueryUpdatedAtDateTime) Order(direction SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r importQueryUpdatedAtDateTime) Cursor(cursor DateTime) importCursorParam {
	return importCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r importQueryUpdatedAtDateTime) In(value []DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) InIfPresent(value []DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.In(value)
}

func (r importQueryUpdatedAtDateTime) NotIn(value []DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.NotIn(value)
}

func (r importQueryUpdatedAtDateTime) Lt(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lt(*value)
}

func (r importQueryUpdatedAtDateTime) Lte(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lte(*value)
}

func (r importQueryUpdatedAtDateTime) Gt(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gt(*value)
}

func (r importQueryUpdatedAtDateTime) Gte(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gte(*value)
}

func (r importQueryUpdatedAtDateTime) Not(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r importQueryUpdatedAtDateTime) Before(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r importQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r importQueryUpdatedAtDateTime) After(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r importQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r importQueryUpdatedAtDateTime) BeforeEquals(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r importQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r importQueryUpdatedAtDateTime) AfterEquals(value DateTime) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r importQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r importQueryUpdatedAtDateTime) Field() importPrismaFields {
	return importFieldUpdatedAt
}

// base struct
type importQueryObjectKeyString struct{}

// Set the required value of ObjectKey
func (r importQueryObjectKeyString) Set(value string) importWithPrismaObjectKeySetParam {

	return importWithPrismaObjectKeySetParam{
		data: builder.Field{
			Name:  "objectKey",
			Value: value,
		},
	}

}

// Set the optional value of ObjectKey dynamically
func (r importQueryObjectKeyString) SetIfPresent(value *String) importWithPrismaObjectKeySetParam {
	if value == nil {
		return importWithPrismaObjectKeySetParam{}
	}

	return r.Set(*value)
}

func (r importQueryObjectKeyString) Equals(value string) importWithPrismaObjectKeyEqualsParam {

	return importWithPrismaObjectKeyEqualsParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) EqualsIfPresent(value *string) importWithPrismaObjectKeyEqualsParam {
	if value == nil {
		return importWithPrismaObjectKeyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r importQueryObjectKeyString) Order(direction SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name:  "objectKey",
			Value: direction,
		},
	}
}

func (r importQueryObjectKeyString) Cursor(cursor string) importCursorParam {
	return importCursorParam{
		data: builder.Field{
			Name:  "objectKey",
			Value: cursor,
		},
	}
}

func (r importQueryObjectKeyString) In(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) InIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.In(value)
}

func (r importQueryObjectKeyString) NotIn(value []string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) NotInIfPresent(value []string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.NotIn(value)
}

func (r importQueryObjectKeyString) Lt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) LtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lt(*value)
}

func (r importQueryObjectKeyString) Lte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) LteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Lte(*value)
}

func (r importQueryObjectKeyString) Gt(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) GtIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gt(*value)
}

func (r importQueryObjectKeyString) Gte(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) GteIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Gte(*value)
}

func (r importQueryObjectKeyString) Contains(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) ContainsIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Contains(*value)
}

func (r importQueryObjectKeyString) StartsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) StartsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r importQueryObjectKeyString) EndsWith(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) EndsWithIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r importQueryObjectKeyString) Search(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) SearchIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Search(*value)
}

func (r importQueryObjectKeyString) Not(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryObjectKeyString) NotIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r importQueryObjectKeyString) HasPrefix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r importQueryObjectKeyString) HasPrefixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r importQueryObjectKeyString) HasSuffix(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "objectKey",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r importQueryObjectKeyString) HasSuffixIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r importQueryObjectKeyString) Field() importPrismaFields {
	return importFieldObjectKey
}

// base struct
type importQueryRelevanceImportOrderByRelevanceInput struct{}

func (r importQueryRelevanceImportOrderByRelevanceInput) Fields(value []ImportOrderByRelevanceFieldEnum) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryRelevanceImportOrderByRelevanceInput) FieldsIfPresent(value []ImportOrderByRelevanceFieldEnum) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Fields(value)
}

func (r importQueryRelevanceImportOrderByRelevanceInput) Sort(value SortOrder) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryRelevanceImportOrderByRelevanceInput) SortIfPresent(value *SortOrder) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Sort(*value)
}

func (r importQueryRelevanceImportOrderByRelevanceInput) Search(value string) importDefaultParam {
	return importDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r importQueryRelevanceImportOrderByRelevanceInput) SearchIfPresent(value *string) importDefaultParam {
	if value == nil {
		return importDefaultParam{}
	}
	return r.Search(*value)
}

func (r importQueryRelevanceImportOrderByRelevanceInput) Field() importPrismaFields {
	return importFieldRelevance
}

// Product acts as a namespaces to access query methods for the Product model
var Product = productQuery{}

// productQuery exposes query functions for the product model
type productQuery struct {

	// ID
	//
	// @required
	ID productQueryIDString

	// Name
	//
	// @required
	Name productQueryNameString

	// CategoryID1
	//
	// @required
	CategoryID1 productQueryCategoryID1String

	// CategoryID2
	//
	// @required
	CategoryID2 productQueryCategoryID2String

	// CategoryID3
	//
	// @required
	CategoryID3 productQueryCategoryID3String

	// CategoryID4
	//
	// @required
	CategoryID4 productQueryCategoryID4String

	// CategoryID5
	//
	// @required
	CategoryID5 productQueryCategoryID5String

	// Note
	//
	// @required
	Note productQueryNoteString

	// Price
	//
	// @optional
	Price productQueryPriceInt

	// Custom1
	//
	// @required
	Custom1 productQueryCustom1String

	// Custom2
	//
	// @required
	Custom2 productQueryCustom2String

	// Description
	//
	// @required
	Description productQueryDescriptionString

	// Details
	//
	// @required
	Details productQueryDetailsString

	// ImageURL1
	//
	// @required
	ImageURL1 productQueryImageURL1String

	// ImageURL2
	//
	// @required
	ImageURL2 productQueryImageURL2String

	// CreatedAt
	//
	// @required
	CreatedAt productQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt productQueryUpdatedAtDateTime

	// Relevance_
	//
	// @optional
	Relevance_ productQueryRelevanceProductOrderByRelevanceInput
}

func (productQuery) Not(params ...ProductWhereParam) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (productQuery) Or(params ...ProductWhereParam) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (productQuery) And(params ...ProductWhereParam) productDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return productDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type productQueryIDString struct{}

// Set the required value of ID
func (r productQueryIDString) Set(value string) productWithPrismaIDSetParam {

	return productWithPrismaIDSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r productQueryIDString) SetIfPresent(value *String) productWithPrismaIDSetParam {
	if value == nil {
		return productWithPrismaIDSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryIDString) Equals(value string) productWithPrismaIDEqualsUniqueParam {

	return productWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) EqualsIfPresent(value *string) productWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return productWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r productQueryIDString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r productQueryIDString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r productQueryIDString) In(value []string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) InIfPresent(value []string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.In(value)
}

func (r productQueryIDString) NotIn(value []string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) NotInIfPresent(value []string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.NotIn(value)
}

func (r productQueryIDString) Lt(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) LtIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Lt(*value)
}

func (r productQueryIDString) Lte(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) LteIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Lte(*value)
}

func (r productQueryIDString) Gt(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) GtIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Gt(*value)
}

func (r productQueryIDString) Gte(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) GteIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Gte(*value)
}

func (r productQueryIDString) Contains(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) ContainsIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Contains(*value)
}

func (r productQueryIDString) StartsWith(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) StartsWithIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r productQueryIDString) EndsWith(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) EndsWithIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r productQueryIDString) Search(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) SearchIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Search(*value)
}

func (r productQueryIDString) Not(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryIDString) NotIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryIDString) HasPrefix(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryIDString) HasPrefixIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryIDString) HasSuffix(value string) productParamUnique {
	return productParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryIDString) HasSuffixIfPresent(value *string) productParamUnique {
	if value == nil {
		return productParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryIDString) Field() productPrismaFields {
	return productFieldID
}

// base struct
type productQueryNameString struct{}

// Set the required value of Name
func (r productQueryNameString) Set(value string) productWithPrismaNameSetParam {

	return productWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r productQueryNameString) SetIfPresent(value *String) productWithPrismaNameSetParam {
	if value == nil {
		return productWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryNameString) Equals(value string) productWithPrismaNameEqualsParam {

	return productWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) EqualsIfPresent(value *string) productWithPrismaNameEqualsParam {
	if value == nil {
		return productWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryNameString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r productQueryNameString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r productQueryNameString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryNameString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryNameString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryNameString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryNameString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryNameString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryNameString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryNameString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryNameString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryNameString) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryNameString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNameString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryNameString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryNameString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryNameString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryNameString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryNameString) Field() productPrismaFields {
	return productFieldName
}

// base struct
type productQueryCategoryID1String struct{}

// Set the required value of CategoryID1
func (r productQueryCategoryID1String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID1 dynamically
func (r productQueryCategoryID1String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCategoryID1String) Equals(value string) productWithPrismaCategoryID1EqualsParam {

	return productWithPrismaCategoryID1EqualsParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) EqualsIfPresent(value *string) productWithPrismaCategoryID1EqualsParam {
	if value == nil {
		return productWithPrismaCategoryID1EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCategoryID1String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: direction,
		},
	}
}

func (r productQueryCategoryID1String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: cursor,
		},
	}
}

func (r productQueryCategoryID1String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCategoryID1String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCategoryID1String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCategoryID1String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCategoryID1String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCategoryID1String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCategoryID1String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCategoryID1String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCategoryID1String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCategoryID1String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryCategoryID1String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID1String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCategoryID1String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCategoryID1String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCategoryID1String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCategoryID1String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCategoryID1String) Field() productPrismaFields {
	return productFieldCategoryID1
}

// base struct
type productQueryCategoryID2String struct{}

// Set the required value of CategoryID2
func (r productQueryCategoryID2String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID2 dynamically
func (r productQueryCategoryID2String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCategoryID2String) Equals(value string) productWithPrismaCategoryID2EqualsParam {

	return productWithPrismaCategoryID2EqualsParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) EqualsIfPresent(value *string) productWithPrismaCategoryID2EqualsParam {
	if value == nil {
		return productWithPrismaCategoryID2EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCategoryID2String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: direction,
		},
	}
}

func (r productQueryCategoryID2String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: cursor,
		},
	}
}

func (r productQueryCategoryID2String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCategoryID2String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCategoryID2String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCategoryID2String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCategoryID2String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCategoryID2String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCategoryID2String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCategoryID2String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCategoryID2String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCategoryID2String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryCategoryID2String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID2String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCategoryID2String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCategoryID2String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCategoryID2String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCategoryID2String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCategoryID2String) Field() productPrismaFields {
	return productFieldCategoryID2
}

// base struct
type productQueryCategoryID3String struct{}

// Set the required value of CategoryID3
func (r productQueryCategoryID3String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID3 dynamically
func (r productQueryCategoryID3String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCategoryID3String) Equals(value string) productWithPrismaCategoryID3EqualsParam {

	return productWithPrismaCategoryID3EqualsParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) EqualsIfPresent(value *string) productWithPrismaCategoryID3EqualsParam {
	if value == nil {
		return productWithPrismaCategoryID3EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCategoryID3String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: direction,
		},
	}
}

func (r productQueryCategoryID3String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: cursor,
		},
	}
}

func (r productQueryCategoryID3String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCategoryID3String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCategoryID3String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCategoryID3String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCategoryID3String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCategoryID3String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCategoryID3String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCategoryID3String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCategoryID3String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCategoryID3String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryCategoryID3String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID3String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCategoryID3String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCategoryID3String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCategoryID3String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCategoryID3String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCategoryID3String) Field() productPrismaFields {
	return productFieldCategoryID3
}

// base struct
type productQueryCategoryID4String struct{}

// Set the required value of CategoryID4
func (r productQueryCategoryID4String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID4 dynamically
func (r productQueryCategoryID4String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCategoryID4String) Equals(value string) productWithPrismaCategoryID4EqualsParam {

	return productWithPrismaCategoryID4EqualsParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) EqualsIfPresent(value *string) productWithPrismaCategoryID4EqualsParam {
	if value == nil {
		return productWithPrismaCategoryID4EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCategoryID4String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: direction,
		},
	}
}

func (r productQueryCategoryID4String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: cursor,
		},
	}
}

func (r productQueryCategoryID4String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCategoryID4String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCategoryID4String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCategoryID4String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCategoryID4String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCategoryID4String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCategoryID4String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCategoryID4String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCategoryID4String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCategoryID4String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryCategoryID4String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID4String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCategoryID4String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCategoryID4String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCategoryID4String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCategoryID4String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCategoryID4String) Field() productPrismaFields {
	return productFieldCategoryID4
}

// base struct
type productQueryCategoryID5String struct{}

// Set the required value of CategoryID5
func (r productQueryCategoryID5String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID5 dynamically
func (r productQueryCategoryID5String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCategoryID5String) Equals(value string) productWithPrismaCategoryID5EqualsParam {

	return productWithPrismaCategoryID5EqualsParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) EqualsIfPresent(value *string) productWithPrismaCategoryID5EqualsParam {
	if value == nil {
		return productWithPrismaCategoryID5EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCategoryID5String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: direction,
		},
	}
}

func (r productQueryCategoryID5String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: cursor,
		},
	}
}

func (r productQueryCategoryID5String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCategoryID5String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCategoryID5String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCategoryID5String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCategoryID5String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCategoryID5String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCategoryID5String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCategoryID5String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCategoryID5String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCategoryID5String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryCategoryID5String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCategoryID5String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCategoryID5String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCategoryID5String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCategoryID5String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCategoryID5String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCategoryID5String) Field() productPrismaFields {
	return productFieldCategoryID5
}

// base struct
type productQueryNoteString struct{}

// Set the required value of Note
func (r productQueryNoteString) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "note",
			Value: value,
		},
	}

}

// Set the optional value of Note dynamically
func (r productQueryNoteString) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryNoteString) Equals(value string) productWithPrismaNoteEqualsParam {

	return productWithPrismaNoteEqualsParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) EqualsIfPresent(value *string) productWithPrismaNoteEqualsParam {
	if value == nil {
		return productWithPrismaNoteEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryNoteString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "note",
			Value: direction,
		},
	}
}

func (r productQueryNoteString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "note",
			Value: cursor,
		},
	}
}

func (r productQueryNoteString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryNoteString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryNoteString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryNoteString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryNoteString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryNoteString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryNoteString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryNoteString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryNoteString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryNoteString) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryNoteString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryNoteString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryNoteString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryNoteString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryNoteString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "note",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryNoteString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryNoteString) Field() productPrismaFields {
	return productFieldNote
}

// base struct
type productQueryPriceInt struct{}

// Set the optional value of Price
func (r productQueryPriceInt) Set(value int) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "price",
			Value: value,
		},
	}

}

// Set the optional value of Price dynamically
func (r productQueryPriceInt) SetIfPresent(value *Int) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Price dynamically
func (r productQueryPriceInt) SetOptional(value *Int) productSetParam {
	if value == nil {

		var v *int
		return productSetParam{
			data: builder.Field{
				Name:  "price",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

// Increment the optional value of Price
func (r productQueryPriceInt) Increment(value int) productSetParam {
	return productSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) IncrementIfPresent(value *int) productSetParam {
	if value == nil {
		return productSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the optional value of Price
func (r productQueryPriceInt) Decrement(value int) productSetParam {
	return productSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) DecrementIfPresent(value *int) productSetParam {
	if value == nil {
		return productSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the optional value of Price
func (r productQueryPriceInt) Multiply(value int) productSetParam {
	return productSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) MultiplyIfPresent(value *int) productSetParam {
	if value == nil {
		return productSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the optional value of Price
func (r productQueryPriceInt) Divide(value int) productSetParam {
	return productSetParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) DivideIfPresent(value *int) productSetParam {
	if value == nil {
		return productSetParam{}
	}
	return r.Divide(*value)
}

func (r productQueryPriceInt) Equals(value int) productWithPrismaPriceEqualsParam {

	return productWithPrismaPriceEqualsParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) EqualsIfPresent(value *int) productWithPrismaPriceEqualsParam {
	if value == nil {
		return productWithPrismaPriceEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryPriceInt) EqualsOptional(value *Int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) IsNull() productDefaultParam {
	var str *string = nil
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r productQueryPriceInt) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "price",
			Value: direction,
		},
	}
}

func (r productQueryPriceInt) Cursor(cursor int) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "price",
			Value: cursor,
		},
	}
}

func (r productQueryPriceInt) In(value []int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) InIfPresent(value []int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryPriceInt) NotIn(value []int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) NotInIfPresent(value []int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryPriceInt) Lt(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) LtIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryPriceInt) Lte(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) LteIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryPriceInt) Gt(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) GtIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryPriceInt) Gte(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) GteIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryPriceInt) Not(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryPriceInt) NotIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r productQueryPriceInt) LT(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r productQueryPriceInt) LTIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r productQueryPriceInt) LTE(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r productQueryPriceInt) LTEIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r productQueryPriceInt) GT(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r productQueryPriceInt) GTIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r productQueryPriceInt) GTE(value int) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "price",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r productQueryPriceInt) GTEIfPresent(value *int) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.GTE(*value)
}

func (r productQueryPriceInt) Field() productPrismaFields {
	return productFieldPrice
}

// base struct
type productQueryCustom1String struct{}

// Set the required value of Custom1
func (r productQueryCustom1String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "custom1",
			Value: value,
		},
	}

}

// Set the optional value of Custom1 dynamically
func (r productQueryCustom1String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCustom1String) Equals(value string) productWithPrismaCustom1EqualsParam {

	return productWithPrismaCustom1EqualsParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) EqualsIfPresent(value *string) productWithPrismaCustom1EqualsParam {
	if value == nil {
		return productWithPrismaCustom1EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCustom1String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "custom1",
			Value: direction,
		},
	}
}

func (r productQueryCustom1String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "custom1",
			Value: cursor,
		},
	}
}

func (r productQueryCustom1String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCustom1String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCustom1String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCustom1String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCustom1String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCustom1String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCustom1String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCustom1String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCustom1String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCustom1String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryCustom1String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom1String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCustom1String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCustom1String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCustom1String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom1",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCustom1String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCustom1String) Field() productPrismaFields {
	return productFieldCustom1
}

// base struct
type productQueryCustom2String struct{}

// Set the required value of Custom2
func (r productQueryCustom2String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "custom2",
			Value: value,
		},
	}

}

// Set the optional value of Custom2 dynamically
func (r productQueryCustom2String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCustom2String) Equals(value string) productWithPrismaCustom2EqualsParam {

	return productWithPrismaCustom2EqualsParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) EqualsIfPresent(value *string) productWithPrismaCustom2EqualsParam {
	if value == nil {
		return productWithPrismaCustom2EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCustom2String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "custom2",
			Value: direction,
		},
	}
}

func (r productQueryCustom2String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "custom2",
			Value: cursor,
		},
	}
}

func (r productQueryCustom2String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCustom2String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCustom2String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCustom2String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCustom2String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCustom2String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCustom2String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryCustom2String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryCustom2String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryCustom2String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryCustom2String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCustom2String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryCustom2String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryCustom2String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryCustom2String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "custom2",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryCustom2String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryCustom2String) Field() productPrismaFields {
	return productFieldCustom2
}

// base struct
type productQueryDescriptionString struct{}

// Set the required value of Description
func (r productQueryDescriptionString) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r productQueryDescriptionString) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryDescriptionString) Equals(value string) productWithPrismaDescriptionEqualsParam {

	return productWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) EqualsIfPresent(value *string) productWithPrismaDescriptionEqualsParam {
	if value == nil {
		return productWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryDescriptionString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r productQueryDescriptionString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r productQueryDescriptionString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryDescriptionString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryDescriptionString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryDescriptionString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryDescriptionString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryDescriptionString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryDescriptionString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryDescriptionString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryDescriptionString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryDescriptionString) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryDescriptionString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDescriptionString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryDescriptionString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryDescriptionString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryDescriptionString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryDescriptionString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryDescriptionString) Field() productPrismaFields {
	return productFieldDescription
}

// base struct
type productQueryDetailsString struct{}

// Set the required value of Details
func (r productQueryDetailsString) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "details",
			Value: value,
		},
	}

}

// Set the optional value of Details dynamically
func (r productQueryDetailsString) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryDetailsString) Equals(value string) productWithPrismaDetailsEqualsParam {

	return productWithPrismaDetailsEqualsParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) EqualsIfPresent(value *string) productWithPrismaDetailsEqualsParam {
	if value == nil {
		return productWithPrismaDetailsEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryDetailsString) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "details",
			Value: direction,
		},
	}
}

func (r productQueryDetailsString) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "details",
			Value: cursor,
		},
	}
}

func (r productQueryDetailsString) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryDetailsString) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryDetailsString) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryDetailsString) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryDetailsString) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryDetailsString) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryDetailsString) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryDetailsString) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryDetailsString) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryDetailsString) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryDetailsString) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryDetailsString) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryDetailsString) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryDetailsString) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryDetailsString) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "details",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryDetailsString) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryDetailsString) Field() productPrismaFields {
	return productFieldDetails
}

// base struct
type productQueryImageURL1String struct{}

// Set the required value of ImageURL1
func (r productQueryImageURL1String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "imageUrl1",
			Value: value,
		},
	}

}

// Set the optional value of ImageURL1 dynamically
func (r productQueryImageURL1String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryImageURL1String) Equals(value string) productWithPrismaImageURL1EqualsParam {

	return productWithPrismaImageURL1EqualsParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) EqualsIfPresent(value *string) productWithPrismaImageURL1EqualsParam {
	if value == nil {
		return productWithPrismaImageURL1EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryImageURL1String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "imageUrl1",
			Value: direction,
		},
	}
}

func (r productQueryImageURL1String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "imageUrl1",
			Value: cursor,
		},
	}
}

func (r productQueryImageURL1String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryImageURL1String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryImageURL1String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryImageURL1String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryImageURL1String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryImageURL1String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryImageURL1String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryImageURL1String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryImageURL1String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryImageURL1String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryImageURL1String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL1String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryImageURL1String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryImageURL1String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryImageURL1String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl1",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryImageURL1String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryImageURL1String) Field() productPrismaFields {
	return productFieldImageURL1
}

// base struct
type productQueryImageURL2String struct{}

// Set the required value of ImageURL2
func (r productQueryImageURL2String) Set(value string) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "imageUrl2",
			Value: value,
		},
	}

}

// Set the optional value of ImageURL2 dynamically
func (r productQueryImageURL2String) SetIfPresent(value *String) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryImageURL2String) Equals(value string) productWithPrismaImageURL2EqualsParam {

	return productWithPrismaImageURL2EqualsParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) EqualsIfPresent(value *string) productWithPrismaImageURL2EqualsParam {
	if value == nil {
		return productWithPrismaImageURL2EqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryImageURL2String) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "imageUrl2",
			Value: direction,
		},
	}
}

func (r productQueryImageURL2String) Cursor(cursor string) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "imageUrl2",
			Value: cursor,
		},
	}
}

func (r productQueryImageURL2String) In(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) InIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryImageURL2String) NotIn(value []string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) NotInIfPresent(value []string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryImageURL2String) Lt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) LtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryImageURL2String) Lte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) LteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryImageURL2String) Gt(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) GtIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryImageURL2String) Gte(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) GteIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryImageURL2String) Contains(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) ContainsIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Contains(*value)
}

func (r productQueryImageURL2String) StartsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) StartsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r productQueryImageURL2String) EndsWith(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) EndsWithIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r productQueryImageURL2String) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryImageURL2String) Not(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryImageURL2String) NotIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r productQueryImageURL2String) HasPrefix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r productQueryImageURL2String) HasPrefixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r productQueryImageURL2String) HasSuffix(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "imageUrl2",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r productQueryImageURL2String) HasSuffixIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r productQueryImageURL2String) Field() productPrismaFields {
	return productFieldImageURL2
}

// base struct
type productQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r productQueryCreatedAtDateTime) Set(value DateTime) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r productQueryCreatedAtDateTime) SetIfPresent(value *DateTime) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryCreatedAtDateTime) Equals(value DateTime) productWithPrismaCreatedAtEqualsParam {

	return productWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) productWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return productWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryCreatedAtDateTime) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r productQueryCreatedAtDateTime) Cursor(cursor DateTime) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r productQueryCreatedAtDateTime) In(value []DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) InIfPresent(value []DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryCreatedAtDateTime) NotIn(value []DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryCreatedAtDateTime) Lt(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) LtIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryCreatedAtDateTime) Lte(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) LteIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryCreatedAtDateTime) Gt(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) GtIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryCreatedAtDateTime) Gte(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) GteIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryCreatedAtDateTime) Not(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryCreatedAtDateTime) NotIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r productQueryCreatedAtDateTime) Before(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r productQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r productQueryCreatedAtDateTime) After(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r productQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r productQueryCreatedAtDateTime) BeforeEquals(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r productQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r productQueryCreatedAtDateTime) AfterEquals(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r productQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r productQueryCreatedAtDateTime) Field() productPrismaFields {
	return productFieldCreatedAt
}

// base struct
type productQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r productQueryUpdatedAtDateTime) Set(value DateTime) productSetParam {

	return productSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r productQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) productSetParam {
	if value == nil {
		return productSetParam{}
	}

	return r.Set(*value)
}

func (r productQueryUpdatedAtDateTime) Equals(value DateTime) productWithPrismaUpdatedAtEqualsParam {

	return productWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) productWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return productWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r productQueryUpdatedAtDateTime) Order(direction SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r productQueryUpdatedAtDateTime) Cursor(cursor DateTime) productCursorParam {
	return productCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r productQueryUpdatedAtDateTime) In(value []DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) InIfPresent(value []DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.In(value)
}

func (r productQueryUpdatedAtDateTime) NotIn(value []DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.NotIn(value)
}

func (r productQueryUpdatedAtDateTime) Lt(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lt(*value)
}

func (r productQueryUpdatedAtDateTime) Lte(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Lte(*value)
}

func (r productQueryUpdatedAtDateTime) Gt(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gt(*value)
}

func (r productQueryUpdatedAtDateTime) Gte(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Gte(*value)
}

func (r productQueryUpdatedAtDateTime) Not(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r productQueryUpdatedAtDateTime) Before(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r productQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r productQueryUpdatedAtDateTime) After(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r productQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r productQueryUpdatedAtDateTime) BeforeEquals(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r productQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r productQueryUpdatedAtDateTime) AfterEquals(value DateTime) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r productQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r productQueryUpdatedAtDateTime) Field() productPrismaFields {
	return productFieldUpdatedAt
}

// base struct
type productQueryRelevanceProductOrderByRelevanceInput struct{}

func (r productQueryRelevanceProductOrderByRelevanceInput) Fields(value []ProductOrderByRelevanceFieldEnum) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryRelevanceProductOrderByRelevanceInput) FieldsIfPresent(value []ProductOrderByRelevanceFieldEnum) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Fields(value)
}

func (r productQueryRelevanceProductOrderByRelevanceInput) Sort(value SortOrder) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryRelevanceProductOrderByRelevanceInput) SortIfPresent(value *SortOrder) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Sort(*value)
}

func (r productQueryRelevanceProductOrderByRelevanceInput) Search(value string) productDefaultParam {
	return productDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r productQueryRelevanceProductOrderByRelevanceInput) SearchIfPresent(value *string) productDefaultParam {
	if value == nil {
		return productDefaultParam{}
	}
	return r.Search(*value)
}

func (r productQueryRelevanceProductOrderByRelevanceInput) Field() productPrismaFields {
	return productFieldRelevance
}

// Category acts as a namespaces to access query methods for the Category model
var Category = categoryQuery{}

// categoryQuery exposes query functions for the category model
type categoryQuery struct {

	// CategoryID1
	//
	// @required
	CategoryID1 categoryQueryCategoryID1String

	// CategoryName1
	//
	// @required
	CategoryName1 categoryQueryCategoryName1String

	// CategoryID2
	//
	// @required
	CategoryID2 categoryQueryCategoryID2String

	// CategoryName2
	//
	// @required
	CategoryName2 categoryQueryCategoryName2String

	// CategoryID3
	//
	// @required
	CategoryID3 categoryQueryCategoryID3String

	// CategoryName3
	//
	// @required
	CategoryName3 categoryQueryCategoryName3String

	// CategoryID4
	//
	// @required
	CategoryID4 categoryQueryCategoryID4String

	// CategoryName4
	//
	// @required
	CategoryName4 categoryQueryCategoryName4String

	// CategoryID5
	//
	// @required
	CategoryID5 categoryQueryCategoryID5String

	// CategoryName5
	//
	// @required
	CategoryName5 categoryQueryCategoryName5String

	CategoryGroupCategories categoryQueryCategoryGroupCategoriesRelations

	// Relevance_
	//
	// @optional
	Relevance_ categoryQueryRelevanceCategoryOrderByRelevanceInput
}

func (categoryQuery) Not(params ...CategoryWhereParam) categoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryQuery) Or(params ...CategoryWhereParam) categoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryQuery) And(params ...CategoryWhereParam) categoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryQuery) CategoryID1CategoryID2CategoryID3CategoryID4CategoryID5(
	_categoryID1 CategoryWithPrismaCategoryID1WhereParam,

	_categoryID2 CategoryWithPrismaCategoryID2WhereParam,

	_categoryID3 CategoryWithPrismaCategoryID3WhereParam,

	_categoryID4 CategoryWithPrismaCategoryID4WhereParam,

	_categoryID5 CategoryWithPrismaCategoryID5WhereParam,
) CategoryEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _categoryID1.field())
	fields = append(fields, _categoryID2.field())
	fields = append(fields, _categoryID3.field())
	fields = append(fields, _categoryID4.field())
	fields = append(fields, _categoryID5.field())

	return categoryEqualsUniqueParam{
		data: builder.Field{
			Name:   "categoryId1_categoryId2_categoryId3_categoryId4_categoryId5",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type categoryQueryCategoryID1String struct{}

// Set the required value of CategoryID1
func (r categoryQueryCategoryID1String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID1 dynamically
func (r categoryQueryCategoryID1String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryID1String) Equals(value string) categoryWithPrismaCategoryID1EqualsParam {

	return categoryWithPrismaCategoryID1EqualsParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) EqualsIfPresent(value *string) categoryWithPrismaCategoryID1EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryID1EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryID1String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryID1String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryID1String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryID1String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryID1String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryID1String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryID1String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryID1String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryID1String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryID1String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryID1String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryID1String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryID1String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID1String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryID1String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryID1String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryID1String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryID1String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryID1String) Field() categoryPrismaFields {
	return categoryFieldCategoryID1
}

// base struct
type categoryQueryCategoryName1String struct{}

// Set the required value of CategoryName1
func (r categoryQueryCategoryName1String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryName1",
			Value: value,
		},
	}

}

// Set the optional value of CategoryName1 dynamically
func (r categoryQueryCategoryName1String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryName1String) Equals(value string) categoryWithPrismaCategoryName1EqualsParam {

	return categoryWithPrismaCategoryName1EqualsParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) EqualsIfPresent(value *string) categoryWithPrismaCategoryName1EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryName1EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryName1String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryName1",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryName1String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryName1",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryName1String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryName1String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryName1String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryName1String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryName1String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryName1String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryName1String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryName1String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryName1String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryName1String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryName1String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName1String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryName1String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryName1String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryName1String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName1",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryName1String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryName1String) Field() categoryPrismaFields {
	return categoryFieldCategoryName1
}

// base struct
type categoryQueryCategoryID2String struct{}

// Set the required value of CategoryID2
func (r categoryQueryCategoryID2String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID2 dynamically
func (r categoryQueryCategoryID2String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryID2String) Equals(value string) categoryWithPrismaCategoryID2EqualsParam {

	return categoryWithPrismaCategoryID2EqualsParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) EqualsIfPresent(value *string) categoryWithPrismaCategoryID2EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryID2EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryID2String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryID2String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryID2String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryID2String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryID2String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryID2String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryID2String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryID2String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryID2String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryID2String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryID2String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryID2String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryID2String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID2String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryID2String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryID2String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryID2String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryID2String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryID2String) Field() categoryPrismaFields {
	return categoryFieldCategoryID2
}

// base struct
type categoryQueryCategoryName2String struct{}

// Set the required value of CategoryName2
func (r categoryQueryCategoryName2String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryName2",
			Value: value,
		},
	}

}

// Set the optional value of CategoryName2 dynamically
func (r categoryQueryCategoryName2String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryName2String) Equals(value string) categoryWithPrismaCategoryName2EqualsParam {

	return categoryWithPrismaCategoryName2EqualsParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) EqualsIfPresent(value *string) categoryWithPrismaCategoryName2EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryName2EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryName2String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryName2",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryName2String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryName2",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryName2String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryName2String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryName2String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryName2String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryName2String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryName2String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryName2String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryName2String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryName2String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryName2String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryName2String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName2String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryName2String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryName2String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryName2String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName2",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryName2String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryName2String) Field() categoryPrismaFields {
	return categoryFieldCategoryName2
}

// base struct
type categoryQueryCategoryID3String struct{}

// Set the required value of CategoryID3
func (r categoryQueryCategoryID3String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID3 dynamically
func (r categoryQueryCategoryID3String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryID3String) Equals(value string) categoryWithPrismaCategoryID3EqualsParam {

	return categoryWithPrismaCategoryID3EqualsParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) EqualsIfPresent(value *string) categoryWithPrismaCategoryID3EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryID3EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryID3String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryID3String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryID3String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryID3String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryID3String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryID3String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryID3String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryID3String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryID3String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryID3String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryID3String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryID3String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryID3String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID3String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryID3String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryID3String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryID3String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryID3String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryID3String) Field() categoryPrismaFields {
	return categoryFieldCategoryID3
}

// base struct
type categoryQueryCategoryName3String struct{}

// Set the required value of CategoryName3
func (r categoryQueryCategoryName3String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryName3",
			Value: value,
		},
	}

}

// Set the optional value of CategoryName3 dynamically
func (r categoryQueryCategoryName3String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryName3String) Equals(value string) categoryWithPrismaCategoryName3EqualsParam {

	return categoryWithPrismaCategoryName3EqualsParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) EqualsIfPresent(value *string) categoryWithPrismaCategoryName3EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryName3EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryName3String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryName3",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryName3String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryName3",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryName3String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryName3String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryName3String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryName3String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryName3String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryName3String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryName3String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryName3String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryName3String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryName3String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryName3String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName3String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryName3String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryName3String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryName3String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName3",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryName3String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryName3String) Field() categoryPrismaFields {
	return categoryFieldCategoryName3
}

// base struct
type categoryQueryCategoryID4String struct{}

// Set the required value of CategoryID4
func (r categoryQueryCategoryID4String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID4 dynamically
func (r categoryQueryCategoryID4String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryID4String) Equals(value string) categoryWithPrismaCategoryID4EqualsParam {

	return categoryWithPrismaCategoryID4EqualsParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) EqualsIfPresent(value *string) categoryWithPrismaCategoryID4EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryID4EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryID4String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryID4String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryID4String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryID4String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryID4String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryID4String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryID4String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryID4String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryID4String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryID4String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryID4String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryID4String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryID4String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID4String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryID4String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryID4String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryID4String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryID4String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryID4String) Field() categoryPrismaFields {
	return categoryFieldCategoryID4
}

// base struct
type categoryQueryCategoryName4String struct{}

// Set the required value of CategoryName4
func (r categoryQueryCategoryName4String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryName4",
			Value: value,
		},
	}

}

// Set the optional value of CategoryName4 dynamically
func (r categoryQueryCategoryName4String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryName4String) Equals(value string) categoryWithPrismaCategoryName4EqualsParam {

	return categoryWithPrismaCategoryName4EqualsParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) EqualsIfPresent(value *string) categoryWithPrismaCategoryName4EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryName4EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryName4String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryName4",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryName4String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryName4",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryName4String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryName4String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryName4String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryName4String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryName4String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryName4String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryName4String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryName4String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryName4String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryName4String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryName4String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName4String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryName4String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryName4String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryName4String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName4",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryName4String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryName4String) Field() categoryPrismaFields {
	return categoryFieldCategoryName4
}

// base struct
type categoryQueryCategoryID5String struct{}

// Set the required value of CategoryID5
func (r categoryQueryCategoryID5String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID5 dynamically
func (r categoryQueryCategoryID5String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryID5String) Equals(value string) categoryWithPrismaCategoryID5EqualsParam {

	return categoryWithPrismaCategoryID5EqualsParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) EqualsIfPresent(value *string) categoryWithPrismaCategoryID5EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryID5EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryID5String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryID5String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryID5String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryID5String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryID5String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryID5String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryID5String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryID5String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryID5String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryID5String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryID5String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryID5String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryID5String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryID5String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryID5String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryID5String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryID5String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryID5String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryID5String) Field() categoryPrismaFields {
	return categoryFieldCategoryID5
}

// base struct
type categoryQueryCategoryName5String struct{}

// Set the required value of CategoryName5
func (r categoryQueryCategoryName5String) Set(value string) categorySetParam {

	return categorySetParam{
		data: builder.Field{
			Name:  "categoryName5",
			Value: value,
		},
	}

}

// Set the optional value of CategoryName5 dynamically
func (r categoryQueryCategoryName5String) SetIfPresent(value *String) categorySetParam {
	if value == nil {
		return categorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryQueryCategoryName5String) Equals(value string) categoryWithPrismaCategoryName5EqualsParam {

	return categoryWithPrismaCategoryName5EqualsParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) EqualsIfPresent(value *string) categoryWithPrismaCategoryName5EqualsParam {
	if value == nil {
		return categoryWithPrismaCategoryName5EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryQueryCategoryName5String) Order(direction SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name:  "categoryName5",
			Value: direction,
		},
	}
}

func (r categoryQueryCategoryName5String) Cursor(cursor string) categoryCursorParam {
	return categoryCursorParam{
		data: builder.Field{
			Name:  "categoryName5",
			Value: cursor,
		},
	}
}

func (r categoryQueryCategoryName5String) In(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) InIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryQueryCategoryName5String) NotIn(value []string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) NotInIfPresent(value []string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryQueryCategoryName5String) Lt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) LtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryQueryCategoryName5String) Lte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) LteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryQueryCategoryName5String) Gt(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) GtIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryQueryCategoryName5String) Gte(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) GteIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryQueryCategoryName5String) Contains(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) ContainsIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryQueryCategoryName5String) StartsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) StartsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryQueryCategoryName5String) EndsWith(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) EndsWithIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryQueryCategoryName5String) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryCategoryName5String) Not(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryCategoryName5String) NotIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryQueryCategoryName5String) HasPrefix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryQueryCategoryName5String) HasPrefixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryQueryCategoryName5String) HasSuffix(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryName5",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryQueryCategoryName5String) HasSuffixIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryQueryCategoryName5String) Field() categoryPrismaFields {
	return categoryFieldCategoryName5
}

// base struct
type categoryQueryCategoryGroupCategoriesCategoryGroupCategory struct{}

type categoryQueryCategoryGroupCategoriesRelations struct{}

// Category -> CategoryGroupCategories
//
// @relation
// @required
func (categoryQueryCategoryGroupCategoriesRelations) Some(
	params ...CategoryGroupCategoryWhereParam,
) categoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Category -> CategoryGroupCategories
//
// @relation
// @required
func (categoryQueryCategoryGroupCategoriesRelations) Every(
	params ...CategoryGroupCategoryWhereParam,
) categoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Category -> CategoryGroupCategories
//
// @relation
// @required
func (categoryQueryCategoryGroupCategoriesRelations) None(
	params ...CategoryGroupCategoryWhereParam,
) categoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (categoryQueryCategoryGroupCategoriesRelations) Fetch(

	params ...CategoryGroupCategoryWhereParam,

) categoryToCategoryGroupCategoriesFindMany {
	var v categoryToCategoryGroupCategoriesFindMany

	v.query.Operation = "query"
	v.query.Method = "categoryGroupCategories"
	v.query.Outputs = categoryGroupCategoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryQueryCategoryGroupCategoriesRelations) Link(
	params ...CategoryGroupCategoryWhereParam,
) categorySetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categorySetParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r categoryQueryCategoryGroupCategoriesRelations) Unlink(
	params ...CategoryGroupCategoryWhereParam,
) categorySetParam {
	var v categorySetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = categorySetParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r categoryQueryCategoryGroupCategoriesCategoryGroupCategory) Field() categoryPrismaFields {
	return categoryFieldCategoryGroupCategories
}

// base struct
type categoryQueryRelevanceCategoryOrderByRelevanceInput struct{}

func (r categoryQueryRelevanceCategoryOrderByRelevanceInput) Fields(value []CategoryOrderByRelevanceFieldEnum) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryRelevanceCategoryOrderByRelevanceInput) FieldsIfPresent(value []CategoryOrderByRelevanceFieldEnum) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Fields(value)
}

func (r categoryQueryRelevanceCategoryOrderByRelevanceInput) Sort(value SortOrder) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryRelevanceCategoryOrderByRelevanceInput) SortIfPresent(value *SortOrder) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Sort(*value)
}

func (r categoryQueryRelevanceCategoryOrderByRelevanceInput) Search(value string) categoryDefaultParam {
	return categoryDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryQueryRelevanceCategoryOrderByRelevanceInput) SearchIfPresent(value *string) categoryDefaultParam {
	if value == nil {
		return categoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryQueryRelevanceCategoryOrderByRelevanceInput) Field() categoryPrismaFields {
	return categoryFieldRelevance
}

// CategoryGroup acts as a namespaces to access query methods for the CategoryGroup model
var CategoryGroup = categoryGroupQuery{}

// categoryGroupQuery exposes query functions for the categoryGroup model
type categoryGroupQuery struct {

	// ID
	//
	// @required
	ID categoryGroupQueryIDString

	// Name
	//
	// @required
	Name categoryGroupQueryNameString

	// Level
	//
	// @required
	Level categoryGroupQueryLevelInt

	// CreatedAt
	//
	// @required
	CreatedAt categoryGroupQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt categoryGroupQueryUpdatedAtDateTime

	CategoryGroupCategories categoryGroupQueryCategoryGroupCategoriesRelations

	// Relevance_
	//
	// @optional
	Relevance_ categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput
}

func (categoryGroupQuery) Not(params ...CategoryGroupWhereParam) categoryGroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryGroupQuery) Or(params ...CategoryGroupWhereParam) categoryGroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryGroupQuery) And(params ...CategoryGroupWhereParam) categoryGroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type categoryGroupQueryIDString struct{}

// Set the required value of ID
func (r categoryGroupQueryIDString) Set(value string) categoryGroupWithPrismaIDSetParam {

	return categoryGroupWithPrismaIDSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r categoryGroupQueryIDString) SetIfPresent(value *String) categoryGroupWithPrismaIDSetParam {
	if value == nil {
		return categoryGroupWithPrismaIDSetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupQueryIDString) Equals(value string) categoryGroupWithPrismaIDEqualsUniqueParam {

	return categoryGroupWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) EqualsIfPresent(value *string) categoryGroupWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return categoryGroupWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupQueryIDString) Order(direction SortOrder) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r categoryGroupQueryIDString) Cursor(cursor string) categoryGroupCursorParam {
	return categoryGroupCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r categoryGroupQueryIDString) In(value []string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) InIfPresent(value []string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.In(value)
}

func (r categoryGroupQueryIDString) NotIn(value []string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) NotInIfPresent(value []string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.NotIn(value)
}

func (r categoryGroupQueryIDString) Lt(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) LtIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.Lt(*value)
}

func (r categoryGroupQueryIDString) Lte(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) LteIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.Lte(*value)
}

func (r categoryGroupQueryIDString) Gt(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) GtIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.Gt(*value)
}

func (r categoryGroupQueryIDString) Gte(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) GteIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.Gte(*value)
}

func (r categoryGroupQueryIDString) Contains(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) ContainsIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.Contains(*value)
}

func (r categoryGroupQueryIDString) StartsWith(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) StartsWithIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupQueryIDString) EndsWith(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) EndsWithIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupQueryIDString) Search(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) SearchIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.Search(*value)
}

func (r categoryGroupQueryIDString) Not(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryIDString) NotIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupQueryIDString) HasPrefix(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupQueryIDString) HasPrefixIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupQueryIDString) HasSuffix(value string) categoryGroupParamUnique {
	return categoryGroupParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupQueryIDString) HasSuffixIfPresent(value *string) categoryGroupParamUnique {
	if value == nil {
		return categoryGroupParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupQueryIDString) Field() categoryGroupPrismaFields {
	return categoryGroupFieldID
}

// base struct
type categoryGroupQueryNameString struct{}

// Set the required value of Name
func (r categoryGroupQueryNameString) Set(value string) categoryGroupWithPrismaNameSetParam {

	return categoryGroupWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r categoryGroupQueryNameString) SetIfPresent(value *String) categoryGroupWithPrismaNameSetParam {
	if value == nil {
		return categoryGroupWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupQueryNameString) Equals(value string) categoryGroupWithPrismaNameEqualsParam {

	return categoryGroupWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) EqualsIfPresent(value *string) categoryGroupWithPrismaNameEqualsParam {
	if value == nil {
		return categoryGroupWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupQueryNameString) Order(direction SortOrder) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r categoryGroupQueryNameString) Cursor(cursor string) categoryGroupCursorParam {
	return categoryGroupCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r categoryGroupQueryNameString) In(value []string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) InIfPresent(value []string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupQueryNameString) NotIn(value []string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) NotInIfPresent(value []string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupQueryNameString) Lt(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) LtIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupQueryNameString) Lte(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) LteIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupQueryNameString) Gt(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) GtIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupQueryNameString) Gte(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) GteIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupQueryNameString) Contains(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) ContainsIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryGroupQueryNameString) StartsWith(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) StartsWithIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupQueryNameString) EndsWith(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) EndsWithIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupQueryNameString) Search(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) SearchIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupQueryNameString) Not(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryNameString) NotIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupQueryNameString) HasPrefix(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupQueryNameString) HasPrefixIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupQueryNameString) HasSuffix(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupQueryNameString) HasSuffixIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupQueryNameString) Field() categoryGroupPrismaFields {
	return categoryGroupFieldName
}

// base struct
type categoryGroupQueryLevelInt struct{}

// Set the required value of Level
func (r categoryGroupQueryLevelInt) Set(value int) categoryGroupWithPrismaLevelSetParam {

	return categoryGroupWithPrismaLevelSetParam{
		data: builder.Field{
			Name:  "level",
			Value: value,
		},
	}

}

// Set the optional value of Level dynamically
func (r categoryGroupQueryLevelInt) SetIfPresent(value *Int) categoryGroupWithPrismaLevelSetParam {
	if value == nil {
		return categoryGroupWithPrismaLevelSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Level
func (r categoryGroupQueryLevelInt) Increment(value int) categoryGroupWithPrismaLevelSetParam {
	return categoryGroupWithPrismaLevelSetParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) IncrementIfPresent(value *int) categoryGroupWithPrismaLevelSetParam {
	if value == nil {
		return categoryGroupWithPrismaLevelSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Level
func (r categoryGroupQueryLevelInt) Decrement(value int) categoryGroupWithPrismaLevelSetParam {
	return categoryGroupWithPrismaLevelSetParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) DecrementIfPresent(value *int) categoryGroupWithPrismaLevelSetParam {
	if value == nil {
		return categoryGroupWithPrismaLevelSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Level
func (r categoryGroupQueryLevelInt) Multiply(value int) categoryGroupWithPrismaLevelSetParam {
	return categoryGroupWithPrismaLevelSetParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) MultiplyIfPresent(value *int) categoryGroupWithPrismaLevelSetParam {
	if value == nil {
		return categoryGroupWithPrismaLevelSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Level
func (r categoryGroupQueryLevelInt) Divide(value int) categoryGroupWithPrismaLevelSetParam {
	return categoryGroupWithPrismaLevelSetParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) DivideIfPresent(value *int) categoryGroupWithPrismaLevelSetParam {
	if value == nil {
		return categoryGroupWithPrismaLevelSetParam{}
	}
	return r.Divide(*value)
}

func (r categoryGroupQueryLevelInt) Equals(value int) categoryGroupWithPrismaLevelEqualsParam {

	return categoryGroupWithPrismaLevelEqualsParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) EqualsIfPresent(value *int) categoryGroupWithPrismaLevelEqualsParam {
	if value == nil {
		return categoryGroupWithPrismaLevelEqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupQueryLevelInt) Order(direction SortOrder) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:  "level",
			Value: direction,
		},
	}
}

func (r categoryGroupQueryLevelInt) Cursor(cursor int) categoryGroupCursorParam {
	return categoryGroupCursorParam{
		data: builder.Field{
			Name:  "level",
			Value: cursor,
		},
	}
}

func (r categoryGroupQueryLevelInt) In(value []int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) InIfPresent(value []int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupQueryLevelInt) NotIn(value []int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) NotInIfPresent(value []int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupQueryLevelInt) Lt(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) LtIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupQueryLevelInt) Lte(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) LteIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupQueryLevelInt) Gt(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) GtIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupQueryLevelInt) Gte(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) GteIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupQueryLevelInt) Not(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryLevelInt) NotIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r categoryGroupQueryLevelInt) LT(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r categoryGroupQueryLevelInt) LTIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r categoryGroupQueryLevelInt) LTE(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r categoryGroupQueryLevelInt) LTEIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r categoryGroupQueryLevelInt) GT(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r categoryGroupQueryLevelInt) GTIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r categoryGroupQueryLevelInt) GTE(value int) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "level",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r categoryGroupQueryLevelInt) GTEIfPresent(value *int) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.GTE(*value)
}

func (r categoryGroupQueryLevelInt) Field() categoryGroupPrismaFields {
	return categoryGroupFieldLevel
}

// base struct
type categoryGroupQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r categoryGroupQueryCreatedAtDateTime) Set(value DateTime) categoryGroupSetParam {

	return categoryGroupSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r categoryGroupQueryCreatedAtDateTime) SetIfPresent(value *DateTime) categoryGroupSetParam {
	if value == nil {
		return categoryGroupSetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupQueryCreatedAtDateTime) Equals(value DateTime) categoryGroupWithPrismaCreatedAtEqualsParam {

	return categoryGroupWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) categoryGroupWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return categoryGroupWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupQueryCreatedAtDateTime) Order(direction SortOrder) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) Cursor(cursor DateTime) categoryGroupCursorParam {
	return categoryGroupCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) In(value []DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) InIfPresent(value []DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupQueryCreatedAtDateTime) NotIn(value []DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupQueryCreatedAtDateTime) Lt(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) LtIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupQueryCreatedAtDateTime) Lte(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) LteIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupQueryCreatedAtDateTime) Gt(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) GtIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupQueryCreatedAtDateTime) Gte(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) GteIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupQueryCreatedAtDateTime) Not(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryCreatedAtDateTime) NotIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r categoryGroupQueryCreatedAtDateTime) Before(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r categoryGroupQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r categoryGroupQueryCreatedAtDateTime) After(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r categoryGroupQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r categoryGroupQueryCreatedAtDateTime) BeforeEquals(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r categoryGroupQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r categoryGroupQueryCreatedAtDateTime) AfterEquals(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r categoryGroupQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r categoryGroupQueryCreatedAtDateTime) Field() categoryGroupPrismaFields {
	return categoryGroupFieldCreatedAt
}

// base struct
type categoryGroupQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r categoryGroupQueryUpdatedAtDateTime) Set(value DateTime) categoryGroupSetParam {

	return categoryGroupSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r categoryGroupQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) categoryGroupSetParam {
	if value == nil {
		return categoryGroupSetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Equals(value DateTime) categoryGroupWithPrismaUpdatedAtEqualsParam {

	return categoryGroupWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) categoryGroupWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return categoryGroupWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Order(direction SortOrder) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) Cursor(cursor DateTime) categoryGroupCursorParam {
	return categoryGroupCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) In(value []DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) InIfPresent(value []DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupQueryUpdatedAtDateTime) NotIn(value []DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Lt(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Lte(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Gt(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Gte(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Not(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r categoryGroupQueryUpdatedAtDateTime) Before(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r categoryGroupQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r categoryGroupQueryUpdatedAtDateTime) After(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r categoryGroupQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r categoryGroupQueryUpdatedAtDateTime) BeforeEquals(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r categoryGroupQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r categoryGroupQueryUpdatedAtDateTime) AfterEquals(value DateTime) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r categoryGroupQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r categoryGroupQueryUpdatedAtDateTime) Field() categoryGroupPrismaFields {
	return categoryGroupFieldUpdatedAt
}

// base struct
type categoryGroupQueryCategoryGroupCategoriesCategoryGroupCategory struct{}

type categoryGroupQueryCategoryGroupCategoriesRelations struct{}

// CategoryGroup -> CategoryGroupCategories
//
// @relation
// @required
func (categoryGroupQueryCategoryGroupCategoriesRelations) Some(
	params ...CategoryGroupCategoryWhereParam,
) categoryGroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// CategoryGroup -> CategoryGroupCategories
//
// @relation
// @required
func (categoryGroupQueryCategoryGroupCategoriesRelations) Every(
	params ...CategoryGroupCategoryWhereParam,
) categoryGroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// CategoryGroup -> CategoryGroupCategories
//
// @relation
// @required
func (categoryGroupQueryCategoryGroupCategoriesRelations) None(
	params ...CategoryGroupCategoryWhereParam,
) categoryGroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (categoryGroupQueryCategoryGroupCategoriesRelations) Fetch(

	params ...CategoryGroupCategoryWhereParam,

) categoryGroupToCategoryGroupCategoriesFindMany {
	var v categoryGroupToCategoryGroupCategoriesFindMany

	v.query.Operation = "query"
	v.query.Method = "categoryGroupCategories"
	v.query.Outputs = categoryGroupCategoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryGroupQueryCategoryGroupCategoriesRelations) Link(
	params ...CategoryGroupCategoryWhereParam,
) categoryGroupSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupSetParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r categoryGroupQueryCategoryGroupCategoriesRelations) Unlink(
	params ...CategoryGroupCategoryWhereParam,
) categoryGroupSetParam {
	var v categoryGroupSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = categoryGroupSetParam{
		data: builder.Field{
			Name: "categoryGroupCategories",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r categoryGroupQueryCategoryGroupCategoriesCategoryGroupCategory) Field() categoryGroupPrismaFields {
	return categoryGroupFieldCategoryGroupCategories
}

// base struct
type categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput struct{}

func (r categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput) Fields(value []CategoryGroupOrderByRelevanceFieldEnum) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput) FieldsIfPresent(value []CategoryGroupOrderByRelevanceFieldEnum) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Fields(value)
}

func (r categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput) Sort(value SortOrder) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput) SortIfPresent(value *SortOrder) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Sort(*value)
}

func (r categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput) Search(value string) categoryGroupDefaultParam {
	return categoryGroupDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput) SearchIfPresent(value *string) categoryGroupDefaultParam {
	if value == nil {
		return categoryGroupDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupQueryRelevanceCategoryGroupOrderByRelevanceInput) Field() categoryGroupPrismaFields {
	return categoryGroupFieldRelevance
}

// CategoryGroupCategory acts as a namespaces to access query methods for the CategoryGroupCategory model
var CategoryGroupCategory = categoryGroupCategoryQuery{}

// categoryGroupCategoryQuery exposes query functions for the categoryGroupCategory model
type categoryGroupCategoryQuery struct {

	// CategoryID1
	//
	// @required
	CategoryID1 categoryGroupCategoryQueryCategoryID1String

	// CategoryID2
	//
	// @required
	CategoryID2 categoryGroupCategoryQueryCategoryID2String

	// CategoryID3
	//
	// @required
	CategoryID3 categoryGroupCategoryQueryCategoryID3String

	// CategoryID4
	//
	// @required
	CategoryID4 categoryGroupCategoryQueryCategoryID4String

	// CategoryID5
	//
	// @required
	CategoryID5 categoryGroupCategoryQueryCategoryID5String

	// CategoryGroupID
	//
	// @required
	CategoryGroupID categoryGroupCategoryQueryCategoryGroupIDString

	Category categoryGroupCategoryQueryCategoryRelations

	CategoryGroup categoryGroupCategoryQueryCategoryGroupRelations

	// Relevance_
	//
	// @optional
	Relevance_ categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput
}

func (categoryGroupCategoryQuery) Not(params ...CategoryGroupCategoryWhereParam) categoryGroupCategoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryGroupCategoryQuery) Or(params ...CategoryGroupCategoryWhereParam) categoryGroupCategoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryGroupCategoryQuery) And(params ...CategoryGroupCategoryWhereParam) categoryGroupCategoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (categoryGroupCategoryQuery) CategoryID1CategoryID2CategoryID3CategoryID4CategoryID5CategoryGroupID(
	_categoryID1 CategoryGroupCategoryWithPrismaCategoryID1WhereParam,

	_categoryID2 CategoryGroupCategoryWithPrismaCategoryID2WhereParam,

	_categoryID3 CategoryGroupCategoryWithPrismaCategoryID3WhereParam,

	_categoryID4 CategoryGroupCategoryWithPrismaCategoryID4WhereParam,

	_categoryID5 CategoryGroupCategoryWithPrismaCategoryID5WhereParam,

	_categoryGroupID CategoryGroupCategoryWithPrismaCategoryGroupIDWhereParam,
) CategoryGroupCategoryEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _categoryID1.field())
	fields = append(fields, _categoryID2.field())
	fields = append(fields, _categoryID3.field())
	fields = append(fields, _categoryID4.field())
	fields = append(fields, _categoryID5.field())
	fields = append(fields, _categoryGroupID.field())

	return categoryGroupCategoryEqualsUniqueParam{
		data: builder.Field{
			Name:   "categoryId1_categoryId2_categoryId3_categoryId4_categoryId5_categoryGroupId",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type categoryGroupCategoryQueryCategoryID1String struct{}

// Set the required value of CategoryID1
func (r categoryGroupCategoryQueryCategoryID1String) Set(value string) categoryGroupCategorySetParam {

	return categoryGroupCategorySetParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID1 dynamically
func (r categoryGroupCategoryQueryCategoryID1String) SetIfPresent(value *String) categoryGroupCategorySetParam {
	if value == nil {
		return categoryGroupCategorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Equals(value string) categoryGroupCategoryWithPrismaCategoryID1EqualsParam {

	return categoryGroupCategoryWithPrismaCategoryID1EqualsParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) EqualsIfPresent(value *string) categoryGroupCategoryWithPrismaCategoryID1EqualsParam {
	if value == nil {
		return categoryGroupCategoryWithPrismaCategoryID1EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Order(direction SortOrder) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: direction,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) Cursor(cursor string) categoryGroupCategoryCursorParam {
	return categoryGroupCategoryCursorParam{
		data: builder.Field{
			Name:  "categoryId1",
			Value: cursor,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) In(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) InIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupCategoryQueryCategoryID1String) NotIn(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) NotInIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Lt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) LtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Lte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) LteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Gt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) GtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Gte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) GteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Contains(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) ContainsIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) StartsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) StartsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) EndsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) EndsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Search(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) SearchIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Not(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID1String) NotIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupCategoryQueryCategoryID1String) HasPrefix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID1String) HasPrefixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupCategoryQueryCategoryID1String) HasSuffix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId1",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID1String) HasSuffixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupCategoryQueryCategoryID1String) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategoryID1
}

// base struct
type categoryGroupCategoryQueryCategoryID2String struct{}

// Set the required value of CategoryID2
func (r categoryGroupCategoryQueryCategoryID2String) Set(value string) categoryGroupCategorySetParam {

	return categoryGroupCategorySetParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID2 dynamically
func (r categoryGroupCategoryQueryCategoryID2String) SetIfPresent(value *String) categoryGroupCategorySetParam {
	if value == nil {
		return categoryGroupCategorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Equals(value string) categoryGroupCategoryWithPrismaCategoryID2EqualsParam {

	return categoryGroupCategoryWithPrismaCategoryID2EqualsParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) EqualsIfPresent(value *string) categoryGroupCategoryWithPrismaCategoryID2EqualsParam {
	if value == nil {
		return categoryGroupCategoryWithPrismaCategoryID2EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Order(direction SortOrder) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: direction,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) Cursor(cursor string) categoryGroupCategoryCursorParam {
	return categoryGroupCategoryCursorParam{
		data: builder.Field{
			Name:  "categoryId2",
			Value: cursor,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) In(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) InIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupCategoryQueryCategoryID2String) NotIn(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) NotInIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Lt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) LtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Lte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) LteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Gt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) GtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Gte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) GteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Contains(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) ContainsIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) StartsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) StartsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) EndsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) EndsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Search(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) SearchIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Not(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID2String) NotIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupCategoryQueryCategoryID2String) HasPrefix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID2String) HasPrefixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupCategoryQueryCategoryID2String) HasSuffix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId2",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID2String) HasSuffixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupCategoryQueryCategoryID2String) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategoryID2
}

// base struct
type categoryGroupCategoryQueryCategoryID3String struct{}

// Set the required value of CategoryID3
func (r categoryGroupCategoryQueryCategoryID3String) Set(value string) categoryGroupCategorySetParam {

	return categoryGroupCategorySetParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID3 dynamically
func (r categoryGroupCategoryQueryCategoryID3String) SetIfPresent(value *String) categoryGroupCategorySetParam {
	if value == nil {
		return categoryGroupCategorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Equals(value string) categoryGroupCategoryWithPrismaCategoryID3EqualsParam {

	return categoryGroupCategoryWithPrismaCategoryID3EqualsParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) EqualsIfPresent(value *string) categoryGroupCategoryWithPrismaCategoryID3EqualsParam {
	if value == nil {
		return categoryGroupCategoryWithPrismaCategoryID3EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Order(direction SortOrder) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: direction,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) Cursor(cursor string) categoryGroupCategoryCursorParam {
	return categoryGroupCategoryCursorParam{
		data: builder.Field{
			Name:  "categoryId3",
			Value: cursor,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) In(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) InIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupCategoryQueryCategoryID3String) NotIn(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) NotInIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Lt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) LtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Lte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) LteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Gt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) GtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Gte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) GteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Contains(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) ContainsIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) StartsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) StartsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) EndsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) EndsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Search(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) SearchIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Not(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID3String) NotIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupCategoryQueryCategoryID3String) HasPrefix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID3String) HasPrefixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupCategoryQueryCategoryID3String) HasSuffix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId3",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID3String) HasSuffixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupCategoryQueryCategoryID3String) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategoryID3
}

// base struct
type categoryGroupCategoryQueryCategoryID4String struct{}

// Set the required value of CategoryID4
func (r categoryGroupCategoryQueryCategoryID4String) Set(value string) categoryGroupCategorySetParam {

	return categoryGroupCategorySetParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID4 dynamically
func (r categoryGroupCategoryQueryCategoryID4String) SetIfPresent(value *String) categoryGroupCategorySetParam {
	if value == nil {
		return categoryGroupCategorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Equals(value string) categoryGroupCategoryWithPrismaCategoryID4EqualsParam {

	return categoryGroupCategoryWithPrismaCategoryID4EqualsParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) EqualsIfPresent(value *string) categoryGroupCategoryWithPrismaCategoryID4EqualsParam {
	if value == nil {
		return categoryGroupCategoryWithPrismaCategoryID4EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Order(direction SortOrder) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: direction,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) Cursor(cursor string) categoryGroupCategoryCursorParam {
	return categoryGroupCategoryCursorParam{
		data: builder.Field{
			Name:  "categoryId4",
			Value: cursor,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) In(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) InIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupCategoryQueryCategoryID4String) NotIn(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) NotInIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Lt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) LtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Lte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) LteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Gt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) GtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Gte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) GteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Contains(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) ContainsIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) StartsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) StartsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) EndsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) EndsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Search(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) SearchIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Not(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID4String) NotIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupCategoryQueryCategoryID4String) HasPrefix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID4String) HasPrefixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupCategoryQueryCategoryID4String) HasSuffix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId4",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID4String) HasSuffixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupCategoryQueryCategoryID4String) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategoryID4
}

// base struct
type categoryGroupCategoryQueryCategoryID5String struct{}

// Set the required value of CategoryID5
func (r categoryGroupCategoryQueryCategoryID5String) Set(value string) categoryGroupCategorySetParam {

	return categoryGroupCategorySetParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: value,
		},
	}

}

// Set the optional value of CategoryID5 dynamically
func (r categoryGroupCategoryQueryCategoryID5String) SetIfPresent(value *String) categoryGroupCategorySetParam {
	if value == nil {
		return categoryGroupCategorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Equals(value string) categoryGroupCategoryWithPrismaCategoryID5EqualsParam {

	return categoryGroupCategoryWithPrismaCategoryID5EqualsParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) EqualsIfPresent(value *string) categoryGroupCategoryWithPrismaCategoryID5EqualsParam {
	if value == nil {
		return categoryGroupCategoryWithPrismaCategoryID5EqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Order(direction SortOrder) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: direction,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) Cursor(cursor string) categoryGroupCategoryCursorParam {
	return categoryGroupCategoryCursorParam{
		data: builder.Field{
			Name:  "categoryId5",
			Value: cursor,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) In(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) InIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupCategoryQueryCategoryID5String) NotIn(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) NotInIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Lt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) LtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Lte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) LteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Gt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) GtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Gte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) GteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Contains(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) ContainsIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) StartsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) StartsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) EndsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) EndsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Search(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) SearchIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Not(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryID5String) NotIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupCategoryQueryCategoryID5String) HasPrefix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID5String) HasPrefixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupCategoryQueryCategoryID5String) HasSuffix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryId5",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryID5String) HasSuffixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupCategoryQueryCategoryID5String) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategoryID5
}

// base struct
type categoryGroupCategoryQueryCategoryGroupIDString struct{}

// Set the required value of CategoryGroupID
func (r categoryGroupCategoryQueryCategoryGroupIDString) Set(value string) categoryGroupCategorySetParam {

	return categoryGroupCategorySetParam{
		data: builder.Field{
			Name:  "categoryGroupId",
			Value: value,
		},
	}

}

// Set the optional value of CategoryGroupID dynamically
func (r categoryGroupCategoryQueryCategoryGroupIDString) SetIfPresent(value *String) categoryGroupCategorySetParam {
	if value == nil {
		return categoryGroupCategorySetParam{}
	}

	return r.Set(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Equals(value string) categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam {

	return categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) EqualsIfPresent(value *string) categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam {
	if value == nil {
		return categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Order(direction SortOrder) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name:  "categoryGroupId",
			Value: direction,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Cursor(cursor string) categoryGroupCategoryCursorParam {
	return categoryGroupCategoryCursorParam{
		data: builder.Field{
			Name:  "categoryGroupId",
			Value: cursor,
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) In(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) InIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.In(value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) NotIn(value []string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) NotInIfPresent(value []string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Lt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) LtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Lte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) LteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Gt(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) GtIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Gte(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) GteIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Contains(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) ContainsIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) StartsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) StartsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) EndsWith(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) EndsWithIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Search(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) SearchIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Not(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) NotIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r categoryGroupCategoryQueryCategoryGroupIDString) HasPrefix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryGroupIDString) HasPrefixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r categoryGroupCategoryQueryCategoryGroupIDString) HasSuffix(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroupId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r categoryGroupCategoryQueryCategoryGroupIDString) HasSuffixIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r categoryGroupCategoryQueryCategoryGroupIDString) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategoryGroupID
}

// base struct
type categoryGroupCategoryQueryCategoryCategory struct{}

type categoryGroupCategoryQueryCategoryRelations struct{}

// CategoryGroupCategory -> Category
//
// @relation
// @required
func (categoryGroupCategoryQueryCategoryRelations) Where(
	params ...CategoryWhereParam,
) categoryGroupCategoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (categoryGroupCategoryQueryCategoryRelations) Fetch() categoryGroupCategoryToCategoryFindUnique {
	var v categoryGroupCategoryToCategoryFindUnique

	v.query.Operation = "query"
	v.query.Method = "category"
	v.query.Outputs = categoryOutput

	return v
}

func (r categoryGroupCategoryQueryCategoryRelations) Link(
	params CategoryWhereParam,
) categoryGroupCategoryWithPrismaCategorySetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return categoryGroupCategoryWithPrismaCategorySetParam{}
	}

	fields = append(fields, f)

	return categoryGroupCategoryWithPrismaCategorySetParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryRelations) Unlink() categoryGroupCategoryWithPrismaCategorySetParam {
	var v categoryGroupCategoryWithPrismaCategorySetParam

	v = categoryGroupCategoryWithPrismaCategorySetParam{
		data: builder.Field{
			Name: "category",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r categoryGroupCategoryQueryCategoryCategory) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategory
}

// base struct
type categoryGroupCategoryQueryCategoryGroupCategoryGroup struct{}

type categoryGroupCategoryQueryCategoryGroupRelations struct{}

// CategoryGroupCategory -> CategoryGroup
//
// @relation
// @required
func (categoryGroupCategoryQueryCategoryGroupRelations) Where(
	params ...CategoryGroupWhereParam,
) categoryGroupCategoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "categoryGroup",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (categoryGroupCategoryQueryCategoryGroupRelations) Fetch() categoryGroupCategoryToCategoryGroupFindUnique {
	var v categoryGroupCategoryToCategoryGroupFindUnique

	v.query.Operation = "query"
	v.query.Method = "categoryGroup"
	v.query.Outputs = categoryGroupOutput

	return v
}

func (r categoryGroupCategoryQueryCategoryGroupRelations) Link(
	params CategoryGroupWhereParam,
) categoryGroupCategoryWithPrismaCategoryGroupSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return categoryGroupCategoryWithPrismaCategoryGroupSetParam{}
	}

	fields = append(fields, f)

	return categoryGroupCategoryWithPrismaCategoryGroupSetParam{
		data: builder.Field{
			Name: "categoryGroup",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryCategoryGroupRelations) Unlink() categoryGroupCategoryWithPrismaCategoryGroupSetParam {
	var v categoryGroupCategoryWithPrismaCategoryGroupSetParam

	v = categoryGroupCategoryWithPrismaCategoryGroupSetParam{
		data: builder.Field{
			Name: "categoryGroup",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r categoryGroupCategoryQueryCategoryGroupCategoryGroup) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldCategoryGroup
}

// base struct
type categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput struct{}

func (r categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput) Fields(value []CategoryGroupCategoryOrderByRelevanceFieldEnum) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput) FieldsIfPresent(value []CategoryGroupCategoryOrderByRelevanceFieldEnum) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Fields(value)
}

func (r categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput) Sort(value SortOrder) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput) SortIfPresent(value *SortOrder) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Sort(*value)
}

func (r categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput) Search(value string) categoryGroupCategoryDefaultParam {
	return categoryGroupCategoryDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput) SearchIfPresent(value *string) categoryGroupCategoryDefaultParam {
	if value == nil {
		return categoryGroupCategoryDefaultParam{}
	}
	return r.Search(*value)
}

func (r categoryGroupCategoryQueryRelevanceCategoryGroupCategoryOrderByRelevanceInput) Field() categoryGroupCategoryPrismaFields {
	return categoryGroupCategoryFieldRelevance
}

// Store acts as a namespaces to access query methods for the Store model
var Store = storeQuery{}

// storeQuery exposes query functions for the store model
type storeQuery struct {

	// ID
	//
	// @required
	ID storeQueryIDString

	// Name
	//
	// @required
	Name storeQueryNameString

	// SalesFloorArea
	//
	// @optional
	SalesFloorArea storeQuerySalesFloorAreaFloat

	// CreatedAt
	//
	// @required
	CreatedAt storeQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt storeQueryUpdatedAtDateTime

	UserStore storeQueryUserStoreRelations

	// Relevance_
	//
	// @optional
	Relevance_ storeQueryRelevanceStoreOrderByRelevanceInput
}

func (storeQuery) Not(params ...StoreWhereParam) storeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (storeQuery) Or(params ...StoreWhereParam) storeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (storeQuery) And(params ...StoreWhereParam) storeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type storeQueryIDString struct{}

// Set the required value of ID
func (r storeQueryIDString) Set(value string) storeWithPrismaIDSetParam {

	return storeWithPrismaIDSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r storeQueryIDString) SetIfPresent(value *String) storeWithPrismaIDSetParam {
	if value == nil {
		return storeWithPrismaIDSetParam{}
	}

	return r.Set(*value)
}

func (r storeQueryIDString) Equals(value string) storeWithPrismaIDEqualsUniqueParam {

	return storeWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) EqualsIfPresent(value *string) storeWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return storeWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r storeQueryIDString) Order(direction SortOrder) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r storeQueryIDString) Cursor(cursor string) storeCursorParam {
	return storeCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r storeQueryIDString) In(value []string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) InIfPresent(value []string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.In(value)
}

func (r storeQueryIDString) NotIn(value []string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) NotInIfPresent(value []string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.NotIn(value)
}

func (r storeQueryIDString) Lt(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) LtIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.Lt(*value)
}

func (r storeQueryIDString) Lte(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) LteIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.Lte(*value)
}

func (r storeQueryIDString) Gt(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) GtIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.Gt(*value)
}

func (r storeQueryIDString) Gte(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) GteIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.Gte(*value)
}

func (r storeQueryIDString) Contains(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) ContainsIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.Contains(*value)
}

func (r storeQueryIDString) StartsWith(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) StartsWithIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r storeQueryIDString) EndsWith(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) EndsWithIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r storeQueryIDString) Search(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) SearchIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.Search(*value)
}

func (r storeQueryIDString) Not(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryIDString) NotIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r storeQueryIDString) HasPrefix(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r storeQueryIDString) HasPrefixIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r storeQueryIDString) HasSuffix(value string) storeParamUnique {
	return storeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r storeQueryIDString) HasSuffixIfPresent(value *string) storeParamUnique {
	if value == nil {
		return storeParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r storeQueryIDString) Field() storePrismaFields {
	return storeFieldID
}

// base struct
type storeQueryNameString struct{}

// Set the required value of Name
func (r storeQueryNameString) Set(value string) storeWithPrismaNameSetParam {

	return storeWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r storeQueryNameString) SetIfPresent(value *String) storeWithPrismaNameSetParam {
	if value == nil {
		return storeWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r storeQueryNameString) Equals(value string) storeWithPrismaNameEqualsParam {

	return storeWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) EqualsIfPresent(value *string) storeWithPrismaNameEqualsParam {
	if value == nil {
		return storeWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeQueryNameString) Order(direction SortOrder) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r storeQueryNameString) Cursor(cursor string) storeCursorParam {
	return storeCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r storeQueryNameString) In(value []string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) InIfPresent(value []string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.In(value)
}

func (r storeQueryNameString) NotIn(value []string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) NotInIfPresent(value []string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeQueryNameString) Lt(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) LtIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeQueryNameString) Lte(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) LteIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeQueryNameString) Gt(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) GtIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeQueryNameString) Gte(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) GteIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeQueryNameString) Contains(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) ContainsIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r storeQueryNameString) StartsWith(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) StartsWithIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r storeQueryNameString) EndsWith(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) EndsWithIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r storeQueryNameString) Search(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) SearchIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Search(*value)
}

func (r storeQueryNameString) Not(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryNameString) NotIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r storeQueryNameString) HasPrefix(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r storeQueryNameString) HasPrefixIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r storeQueryNameString) HasSuffix(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r storeQueryNameString) HasSuffixIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r storeQueryNameString) Field() storePrismaFields {
	return storeFieldName
}

// base struct
type storeQuerySalesFloorAreaFloat struct{}

// Set the optional value of SalesFloorArea
func (r storeQuerySalesFloorAreaFloat) Set(value float64) storeSetParam {

	return storeSetParam{
		data: builder.Field{
			Name:  "salesFloorArea",
			Value: value,
		},
	}

}

// Set the optional value of SalesFloorArea dynamically
func (r storeQuerySalesFloorAreaFloat) SetIfPresent(value *Float) storeSetParam {
	if value == nil {
		return storeSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of SalesFloorArea dynamically
func (r storeQuerySalesFloorAreaFloat) SetOptional(value *Float) storeSetParam {
	if value == nil {

		var v *float64
		return storeSetParam{
			data: builder.Field{
				Name:  "salesFloorArea",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

// Increment the optional value of SalesFloorArea
func (r storeQuerySalesFloorAreaFloat) Increment(value float64) storeSetParam {
	return storeSetParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) IncrementIfPresent(value *float64) storeSetParam {
	if value == nil {
		return storeSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the optional value of SalesFloorArea
func (r storeQuerySalesFloorAreaFloat) Decrement(value float64) storeSetParam {
	return storeSetParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) DecrementIfPresent(value *float64) storeSetParam {
	if value == nil {
		return storeSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the optional value of SalesFloorArea
func (r storeQuerySalesFloorAreaFloat) Multiply(value float64) storeSetParam {
	return storeSetParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) MultiplyIfPresent(value *float64) storeSetParam {
	if value == nil {
		return storeSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the optional value of SalesFloorArea
func (r storeQuerySalesFloorAreaFloat) Divide(value float64) storeSetParam {
	return storeSetParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) DivideIfPresent(value *float64) storeSetParam {
	if value == nil {
		return storeSetParam{}
	}
	return r.Divide(*value)
}

func (r storeQuerySalesFloorAreaFloat) Equals(value float64) storeWithPrismaSalesFloorAreaEqualsParam {

	return storeWithPrismaSalesFloorAreaEqualsParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) EqualsIfPresent(value *float64) storeWithPrismaSalesFloorAreaEqualsParam {
	if value == nil {
		return storeWithPrismaSalesFloorAreaEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeQuerySalesFloorAreaFloat) EqualsOptional(value *Float) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) IsNull() storeDefaultParam {
	var str *string = nil
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) Order(direction SortOrder) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name:  "salesFloorArea",
			Value: direction,
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) Cursor(cursor float64) storeCursorParam {
	return storeCursorParam{
		data: builder.Field{
			Name:  "salesFloorArea",
			Value: cursor,
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) In(value []float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) InIfPresent(value []float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.In(value)
}

func (r storeQuerySalesFloorAreaFloat) NotIn(value []float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) NotInIfPresent(value []float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeQuerySalesFloorAreaFloat) Lt(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) LtIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeQuerySalesFloorAreaFloat) Lte(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) LteIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeQuerySalesFloorAreaFloat) Gt(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) GtIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeQuerySalesFloorAreaFloat) Gte(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) GteIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeQuerySalesFloorAreaFloat) Not(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeQuerySalesFloorAreaFloat) NotIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r storeQuerySalesFloorAreaFloat) LT(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r storeQuerySalesFloorAreaFloat) LTIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r storeQuerySalesFloorAreaFloat) LTE(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r storeQuerySalesFloorAreaFloat) LTEIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r storeQuerySalesFloorAreaFloat) GT(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r storeQuerySalesFloorAreaFloat) GTIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r storeQuerySalesFloorAreaFloat) GTE(value float64) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "salesFloorArea",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r storeQuerySalesFloorAreaFloat) GTEIfPresent(value *float64) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.GTE(*value)
}

func (r storeQuerySalesFloorAreaFloat) Field() storePrismaFields {
	return storeFieldSalesFloorArea
}

// base struct
type storeQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r storeQueryCreatedAtDateTime) Set(value DateTime) storeSetParam {

	return storeSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r storeQueryCreatedAtDateTime) SetIfPresent(value *DateTime) storeSetParam {
	if value == nil {
		return storeSetParam{}
	}

	return r.Set(*value)
}

func (r storeQueryCreatedAtDateTime) Equals(value DateTime) storeWithPrismaCreatedAtEqualsParam {

	return storeWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) storeWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return storeWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeQueryCreatedAtDateTime) Order(direction SortOrder) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r storeQueryCreatedAtDateTime) Cursor(cursor DateTime) storeCursorParam {
	return storeCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r storeQueryCreatedAtDateTime) In(value []DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) InIfPresent(value []DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.In(value)
}

func (r storeQueryCreatedAtDateTime) NotIn(value []DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeQueryCreatedAtDateTime) Lt(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) LtIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeQueryCreatedAtDateTime) Lte(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) LteIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeQueryCreatedAtDateTime) Gt(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) GtIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeQueryCreatedAtDateTime) Gte(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) GteIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeQueryCreatedAtDateTime) Not(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryCreatedAtDateTime) NotIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r storeQueryCreatedAtDateTime) Before(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r storeQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r storeQueryCreatedAtDateTime) After(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r storeQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r storeQueryCreatedAtDateTime) BeforeEquals(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r storeQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r storeQueryCreatedAtDateTime) AfterEquals(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r storeQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r storeQueryCreatedAtDateTime) Field() storePrismaFields {
	return storeFieldCreatedAt
}

// base struct
type storeQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r storeQueryUpdatedAtDateTime) Set(value DateTime) storeSetParam {

	return storeSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r storeQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) storeSetParam {
	if value == nil {
		return storeSetParam{}
	}

	return r.Set(*value)
}

func (r storeQueryUpdatedAtDateTime) Equals(value DateTime) storeWithPrismaUpdatedAtEqualsParam {

	return storeWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) storeWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return storeWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeQueryUpdatedAtDateTime) Order(direction SortOrder) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r storeQueryUpdatedAtDateTime) Cursor(cursor DateTime) storeCursorParam {
	return storeCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r storeQueryUpdatedAtDateTime) In(value []DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) InIfPresent(value []DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.In(value)
}

func (r storeQueryUpdatedAtDateTime) NotIn(value []DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeQueryUpdatedAtDateTime) Lt(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeQueryUpdatedAtDateTime) Lte(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeQueryUpdatedAtDateTime) Gt(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeQueryUpdatedAtDateTime) Gte(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeQueryUpdatedAtDateTime) Not(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r storeQueryUpdatedAtDateTime) Before(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r storeQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r storeQueryUpdatedAtDateTime) After(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r storeQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r storeQueryUpdatedAtDateTime) BeforeEquals(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r storeQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r storeQueryUpdatedAtDateTime) AfterEquals(value DateTime) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r storeQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r storeQueryUpdatedAtDateTime) Field() storePrismaFields {
	return storeFieldUpdatedAt
}

// base struct
type storeQueryUserStoreUserStore struct{}

type storeQueryUserStoreRelations struct{}

// Store -> UserStore
//
// @relation
// @required
func (storeQueryUserStoreRelations) Some(
	params ...UserStoreWhereParam,
) storeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeDefaultParam{
		data: builder.Field{
			Name: "userStore",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Store -> UserStore
//
// @relation
// @required
func (storeQueryUserStoreRelations) Every(
	params ...UserStoreWhereParam,
) storeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeDefaultParam{
		data: builder.Field{
			Name: "userStore",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Store -> UserStore
//
// @relation
// @required
func (storeQueryUserStoreRelations) None(
	params ...UserStoreWhereParam,
) storeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeDefaultParam{
		data: builder.Field{
			Name: "userStore",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (storeQueryUserStoreRelations) Fetch(

	params ...UserStoreWhereParam,

) storeToUserStoreFindMany {
	var v storeToUserStoreFindMany

	v.query.Operation = "query"
	v.query.Method = "userStore"
	v.query.Outputs = userStoreOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r storeQueryUserStoreRelations) Link(
	params ...UserStoreWhereParam,
) storeSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeSetParam{
		data: builder.Field{
			Name: "userStore",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r storeQueryUserStoreRelations) Unlink(
	params ...UserStoreWhereParam,
) storeSetParam {
	var v storeSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = storeSetParam{
		data: builder.Field{
			Name: "userStore",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r storeQueryUserStoreUserStore) Field() storePrismaFields {
	return storeFieldUserStore
}

// base struct
type storeQueryRelevanceStoreOrderByRelevanceInput struct{}

func (r storeQueryRelevanceStoreOrderByRelevanceInput) Fields(value []StoreOrderByRelevanceFieldEnum) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryRelevanceStoreOrderByRelevanceInput) FieldsIfPresent(value []StoreOrderByRelevanceFieldEnum) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Fields(value)
}

func (r storeQueryRelevanceStoreOrderByRelevanceInput) Sort(value SortOrder) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryRelevanceStoreOrderByRelevanceInput) SortIfPresent(value *SortOrder) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Sort(*value)
}

func (r storeQueryRelevanceStoreOrderByRelevanceInput) Search(value string) storeDefaultParam {
	return storeDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r storeQueryRelevanceStoreOrderByRelevanceInput) SearchIfPresent(value *string) storeDefaultParam {
	if value == nil {
		return storeDefaultParam{}
	}
	return r.Search(*value)
}

func (r storeQueryRelevanceStoreOrderByRelevanceInput) Field() storePrismaFields {
	return storeFieldRelevance
}

// UserStore acts as a namespaces to access query methods for the UserStore model
var UserStore = userStoreQuery{}

// userStoreQuery exposes query functions for the userStore model
type userStoreQuery struct {

	// Email
	//
	// @required
	Email userStoreQueryEmailString

	// Name
	//
	// @required
	Name userStoreQueryNameString

	// StoreID
	//
	// @required
	StoreID userStoreQueryStoreIDString

	// CreatedAt
	//
	// @required
	CreatedAt userStoreQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userStoreQueryUpdatedAtDateTime

	Store userStoreQueryStoreRelations

	// Relevance_
	//
	// @optional
	Relevance_ userStoreQueryRelevanceUserStoreOrderByRelevanceInput
}

func (userStoreQuery) Not(params ...UserStoreWhereParam) userStoreDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userStoreDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userStoreQuery) Or(params ...UserStoreWhereParam) userStoreDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userStoreDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userStoreQuery) And(params ...UserStoreWhereParam) userStoreDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userStoreDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userStoreQuery) EmailStoreID(
	_email UserStoreWithPrismaEmailWhereParam,

	_storeID UserStoreWithPrismaStoreIDWhereParam,
) UserStoreEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _email.field())
	fields = append(fields, _storeID.field())

	return userStoreEqualsUniqueParam{
		data: builder.Field{
			Name:   "email_storeId",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type userStoreQueryEmailString struct{}

// Set the required value of Email
func (r userStoreQueryEmailString) Set(value string) userStoreWithPrismaEmailSetParam {

	return userStoreWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r userStoreQueryEmailString) SetIfPresent(value *String) userStoreWithPrismaEmailSetParam {
	if value == nil {
		return userStoreWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r userStoreQueryEmailString) Equals(value string) userStoreWithPrismaEmailEqualsParam {

	return userStoreWithPrismaEmailEqualsParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) EqualsIfPresent(value *string) userStoreWithPrismaEmailEqualsParam {
	if value == nil {
		return userStoreWithPrismaEmailEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userStoreQueryEmailString) Order(direction SortOrder) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userStoreQueryEmailString) Cursor(cursor string) userStoreCursorParam {
	return userStoreCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userStoreQueryEmailString) In(value []string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) InIfPresent(value []string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.In(value)
}

func (r userStoreQueryEmailString) NotIn(value []string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) NotInIfPresent(value []string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userStoreQueryEmailString) Lt(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) LtIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userStoreQueryEmailString) Lte(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) LteIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userStoreQueryEmailString) Gt(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) GtIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userStoreQueryEmailString) Gte(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) GteIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userStoreQueryEmailString) Contains(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) ContainsIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userStoreQueryEmailString) StartsWith(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) StartsWithIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userStoreQueryEmailString) EndsWith(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) EndsWithIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userStoreQueryEmailString) Search(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) SearchIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Search(*value)
}

func (r userStoreQueryEmailString) Not(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryEmailString) NotIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userStoreQueryEmailString) HasPrefix(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userStoreQueryEmailString) HasPrefixIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userStoreQueryEmailString) HasSuffix(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userStoreQueryEmailString) HasSuffixIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userStoreQueryEmailString) Field() userStorePrismaFields {
	return userStoreFieldEmail
}

// base struct
type userStoreQueryNameString struct{}

// Set the required value of Name
func (r userStoreQueryNameString) Set(value string) userStoreWithPrismaNameSetParam {

	return userStoreWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r userStoreQueryNameString) SetIfPresent(value *String) userStoreWithPrismaNameSetParam {
	if value == nil {
		return userStoreWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r userStoreQueryNameString) Equals(value string) userStoreWithPrismaNameEqualsParam {

	return userStoreWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) EqualsIfPresent(value *string) userStoreWithPrismaNameEqualsParam {
	if value == nil {
		return userStoreWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userStoreQueryNameString) Order(direction SortOrder) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r userStoreQueryNameString) Cursor(cursor string) userStoreCursorParam {
	return userStoreCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r userStoreQueryNameString) In(value []string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) InIfPresent(value []string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.In(value)
}

func (r userStoreQueryNameString) NotIn(value []string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) NotInIfPresent(value []string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userStoreQueryNameString) Lt(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) LtIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userStoreQueryNameString) Lte(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) LteIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userStoreQueryNameString) Gt(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) GtIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userStoreQueryNameString) Gte(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) GteIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userStoreQueryNameString) Contains(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) ContainsIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userStoreQueryNameString) StartsWith(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) StartsWithIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userStoreQueryNameString) EndsWith(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) EndsWithIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userStoreQueryNameString) Search(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) SearchIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Search(*value)
}

func (r userStoreQueryNameString) Not(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryNameString) NotIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userStoreQueryNameString) HasPrefix(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userStoreQueryNameString) HasPrefixIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userStoreQueryNameString) HasSuffix(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userStoreQueryNameString) HasSuffixIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userStoreQueryNameString) Field() userStorePrismaFields {
	return userStoreFieldName
}

// base struct
type userStoreQueryStoreIDString struct{}

// Set the required value of StoreID
func (r userStoreQueryStoreIDString) Set(value string) userStoreSetParam {

	return userStoreSetParam{
		data: builder.Field{
			Name:  "storeId",
			Value: value,
		},
	}

}

// Set the optional value of StoreID dynamically
func (r userStoreQueryStoreIDString) SetIfPresent(value *String) userStoreSetParam {
	if value == nil {
		return userStoreSetParam{}
	}

	return r.Set(*value)
}

func (r userStoreQueryStoreIDString) Equals(value string) userStoreWithPrismaStoreIDEqualsParam {

	return userStoreWithPrismaStoreIDEqualsParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) EqualsIfPresent(value *string) userStoreWithPrismaStoreIDEqualsParam {
	if value == nil {
		return userStoreWithPrismaStoreIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userStoreQueryStoreIDString) Order(direction SortOrder) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name:  "storeId",
			Value: direction,
		},
	}
}

func (r userStoreQueryStoreIDString) Cursor(cursor string) userStoreCursorParam {
	return userStoreCursorParam{
		data: builder.Field{
			Name:  "storeId",
			Value: cursor,
		},
	}
}

func (r userStoreQueryStoreIDString) In(value []string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) InIfPresent(value []string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.In(value)
}

func (r userStoreQueryStoreIDString) NotIn(value []string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) NotInIfPresent(value []string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userStoreQueryStoreIDString) Lt(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) LtIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userStoreQueryStoreIDString) Lte(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) LteIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userStoreQueryStoreIDString) Gt(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) GtIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userStoreQueryStoreIDString) Gte(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) GteIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userStoreQueryStoreIDString) Contains(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) ContainsIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userStoreQueryStoreIDString) StartsWith(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) StartsWithIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userStoreQueryStoreIDString) EndsWith(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) EndsWithIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userStoreQueryStoreIDString) Search(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) SearchIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Search(*value)
}

func (r userStoreQueryStoreIDString) Not(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryStoreIDString) NotIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userStoreQueryStoreIDString) HasPrefix(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userStoreQueryStoreIDString) HasPrefixIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userStoreQueryStoreIDString) HasSuffix(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userStoreQueryStoreIDString) HasSuffixIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userStoreQueryStoreIDString) Field() userStorePrismaFields {
	return userStoreFieldStoreID
}

// base struct
type userStoreQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userStoreQueryCreatedAtDateTime) Set(value DateTime) userStoreSetParam {

	return userStoreSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userStoreQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userStoreSetParam {
	if value == nil {
		return userStoreSetParam{}
	}

	return r.Set(*value)
}

func (r userStoreQueryCreatedAtDateTime) Equals(value DateTime) userStoreWithPrismaCreatedAtEqualsParam {

	return userStoreWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userStoreWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userStoreWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userStoreQueryCreatedAtDateTime) Order(direction SortOrder) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) Cursor(cursor DateTime) userStoreCursorParam {
	return userStoreCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) In(value []DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) InIfPresent(value []DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.In(value)
}

func (r userStoreQueryCreatedAtDateTime) NotIn(value []DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userStoreQueryCreatedAtDateTime) Lt(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userStoreQueryCreatedAtDateTime) Lte(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userStoreQueryCreatedAtDateTime) Gt(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userStoreQueryCreatedAtDateTime) Gte(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userStoreQueryCreatedAtDateTime) Not(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userStoreQueryCreatedAtDateTime) Before(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userStoreQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userStoreQueryCreatedAtDateTime) After(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userStoreQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userStoreQueryCreatedAtDateTime) BeforeEquals(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userStoreQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userStoreQueryCreatedAtDateTime) AfterEquals(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userStoreQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userStoreQueryCreatedAtDateTime) Field() userStorePrismaFields {
	return userStoreFieldCreatedAt
}

// base struct
type userStoreQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userStoreQueryUpdatedAtDateTime) Set(value DateTime) userStoreSetParam {

	return userStoreSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userStoreQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userStoreSetParam {
	if value == nil {
		return userStoreSetParam{}
	}

	return r.Set(*value)
}

func (r userStoreQueryUpdatedAtDateTime) Equals(value DateTime) userStoreWithPrismaUpdatedAtEqualsParam {

	return userStoreWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userStoreWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userStoreWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userStoreQueryUpdatedAtDateTime) Order(direction SortOrder) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) Cursor(cursor DateTime) userStoreCursorParam {
	return userStoreCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) In(value []DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.In(value)
}

func (r userStoreQueryUpdatedAtDateTime) NotIn(value []DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userStoreQueryUpdatedAtDateTime) Lt(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userStoreQueryUpdatedAtDateTime) Lte(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userStoreQueryUpdatedAtDateTime) Gt(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userStoreQueryUpdatedAtDateTime) Gte(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userStoreQueryUpdatedAtDateTime) Not(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userStoreQueryUpdatedAtDateTime) Before(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userStoreQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userStoreQueryUpdatedAtDateTime) After(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userStoreQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userStoreQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userStoreQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userStoreQueryUpdatedAtDateTime) AfterEquals(value DateTime) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userStoreQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userStoreQueryUpdatedAtDateTime) Field() userStorePrismaFields {
	return userStoreFieldUpdatedAt
}

// base struct
type userStoreQueryStoreStore struct{}

type userStoreQueryStoreRelations struct{}

// UserStore -> Store
//
// @relation
// @required
func (userStoreQueryStoreRelations) Where(
	params ...StoreWhereParam,
) userStoreDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userStoreDefaultParam{
		data: builder.Field{
			Name: "store",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (userStoreQueryStoreRelations) Fetch() userStoreToStoreFindUnique {
	var v userStoreToStoreFindUnique

	v.query.Operation = "query"
	v.query.Method = "store"
	v.query.Outputs = storeOutput

	return v
}

func (r userStoreQueryStoreRelations) Link(
	params StoreWhereParam,
) userStoreWithPrismaStoreSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return userStoreWithPrismaStoreSetParam{}
	}

	fields = append(fields, f)

	return userStoreWithPrismaStoreSetParam{
		data: builder.Field{
			Name: "store",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r userStoreQueryStoreRelations) Unlink() userStoreWithPrismaStoreSetParam {
	var v userStoreWithPrismaStoreSetParam

	v = userStoreWithPrismaStoreSetParam{
		data: builder.Field{
			Name: "store",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r userStoreQueryStoreStore) Field() userStorePrismaFields {
	return userStoreFieldStore
}

// base struct
type userStoreQueryRelevanceUserStoreOrderByRelevanceInput struct{}

func (r userStoreQueryRelevanceUserStoreOrderByRelevanceInput) Fields(value []UserStoreOrderByRelevanceFieldEnum) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryRelevanceUserStoreOrderByRelevanceInput) FieldsIfPresent(value []UserStoreOrderByRelevanceFieldEnum) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Fields(value)
}

func (r userStoreQueryRelevanceUserStoreOrderByRelevanceInput) Sort(value SortOrder) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryRelevanceUserStoreOrderByRelevanceInput) SortIfPresent(value *SortOrder) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Sort(*value)
}

func (r userStoreQueryRelevanceUserStoreOrderByRelevanceInput) Search(value string) userStoreDefaultParam {
	return userStoreDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r userStoreQueryRelevanceUserStoreOrderByRelevanceInput) SearchIfPresent(value *string) userStoreDefaultParam {
	if value == nil {
		return userStoreDefaultParam{}
	}
	return r.Search(*value)
}

func (r userStoreQueryRelevanceUserStoreOrderByRelevanceInput) Field() userStorePrismaFields {
	return userStoreFieldRelevance
}

// Holiday acts as a namespaces to access query methods for the Holiday model
var Holiday = holidayQuery{}

// holidayQuery exposes query functions for the holiday model
type holidayQuery struct {

	// Date
	//
	// @required
	Date holidayQueryDateDateTime

	// Name
	//
	// @required
	Name holidayQueryNameString

	// Relevance_
	//
	// @optional
	Relevance_ holidayQueryRelevanceHolidayOrderByRelevanceInput
}

func (holidayQuery) Not(params ...HolidayWhereParam) holidayDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return holidayDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (holidayQuery) Or(params ...HolidayWhereParam) holidayDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return holidayDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (holidayQuery) And(params ...HolidayWhereParam) holidayDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return holidayDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type holidayQueryDateDateTime struct{}

// Set the required value of Date
func (r holidayQueryDateDateTime) Set(value DateTime) holidayWithPrismaDateSetParam {

	return holidayWithPrismaDateSetParam{
		data: builder.Field{
			Name:  "date",
			Value: value,
		},
	}

}

// Set the optional value of Date dynamically
func (r holidayQueryDateDateTime) SetIfPresent(value *DateTime) holidayWithPrismaDateSetParam {
	if value == nil {
		return holidayWithPrismaDateSetParam{}
	}

	return r.Set(*value)
}

func (r holidayQueryDateDateTime) Equals(value DateTime) holidayWithPrismaDateEqualsUniqueParam {

	return holidayWithPrismaDateEqualsUniqueParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) EqualsIfPresent(value *DateTime) holidayWithPrismaDateEqualsUniqueParam {
	if value == nil {
		return holidayWithPrismaDateEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r holidayQueryDateDateTime) Order(direction SortOrder) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name:  "date",
			Value: direction,
		},
	}
}

func (r holidayQueryDateDateTime) Cursor(cursor DateTime) holidayCursorParam {
	return holidayCursorParam{
		data: builder.Field{
			Name:  "date",
			Value: cursor,
		},
	}
}

func (r holidayQueryDateDateTime) In(value []DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) InIfPresent(value []DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.In(value)
}

func (r holidayQueryDateDateTime) NotIn(value []DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) NotInIfPresent(value []DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.NotIn(value)
}

func (r holidayQueryDateDateTime) Lt(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) LtIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.Lt(*value)
}

func (r holidayQueryDateDateTime) Lte(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) LteIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.Lte(*value)
}

func (r holidayQueryDateDateTime) Gt(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) GtIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.Gt(*value)
}

func (r holidayQueryDateDateTime) Gte(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) GteIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.Gte(*value)
}

func (r holidayQueryDateDateTime) Not(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryDateDateTime) NotIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r holidayQueryDateDateTime) Before(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r holidayQueryDateDateTime) BeforeIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r holidayQueryDateDateTime) After(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r holidayQueryDateDateTime) AfterIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r holidayQueryDateDateTime) BeforeEquals(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r holidayQueryDateDateTime) BeforeEqualsIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r holidayQueryDateDateTime) AfterEquals(value DateTime) holidayParamUnique {
	return holidayParamUnique{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r holidayQueryDateDateTime) AfterEqualsIfPresent(value *DateTime) holidayParamUnique {
	if value == nil {
		return holidayParamUnique{}
	}
	return r.AfterEquals(*value)
}

func (r holidayQueryDateDateTime) Field() holidayPrismaFields {
	return holidayFieldDate
}

// base struct
type holidayQueryNameString struct{}

// Set the required value of Name
func (r holidayQueryNameString) Set(value string) holidayWithPrismaNameSetParam {

	return holidayWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r holidayQueryNameString) SetIfPresent(value *String) holidayWithPrismaNameSetParam {
	if value == nil {
		return holidayWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r holidayQueryNameString) Equals(value string) holidayWithPrismaNameEqualsParam {

	return holidayWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) EqualsIfPresent(value *string) holidayWithPrismaNameEqualsParam {
	if value == nil {
		return holidayWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r holidayQueryNameString) Order(direction SortOrder) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r holidayQueryNameString) Cursor(cursor string) holidayCursorParam {
	return holidayCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r holidayQueryNameString) In(value []string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) InIfPresent(value []string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.In(value)
}

func (r holidayQueryNameString) NotIn(value []string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) NotInIfPresent(value []string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.NotIn(value)
}

func (r holidayQueryNameString) Lt(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) LtIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Lt(*value)
}

func (r holidayQueryNameString) Lte(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) LteIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Lte(*value)
}

func (r holidayQueryNameString) Gt(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) GtIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Gt(*value)
}

func (r holidayQueryNameString) Gte(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) GteIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Gte(*value)
}

func (r holidayQueryNameString) Contains(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) ContainsIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Contains(*value)
}

func (r holidayQueryNameString) StartsWith(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) StartsWithIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r holidayQueryNameString) EndsWith(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) EndsWithIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r holidayQueryNameString) Search(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) SearchIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Search(*value)
}

func (r holidayQueryNameString) Not(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryNameString) NotIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r holidayQueryNameString) HasPrefix(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r holidayQueryNameString) HasPrefixIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r holidayQueryNameString) HasSuffix(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r holidayQueryNameString) HasSuffixIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r holidayQueryNameString) Field() holidayPrismaFields {
	return holidayFieldName
}

// base struct
type holidayQueryRelevanceHolidayOrderByRelevanceInput struct{}

func (r holidayQueryRelevanceHolidayOrderByRelevanceInput) Fields(value []HolidayOrderByRelevanceFieldEnum) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryRelevanceHolidayOrderByRelevanceInput) FieldsIfPresent(value []HolidayOrderByRelevanceFieldEnum) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Fields(value)
}

func (r holidayQueryRelevanceHolidayOrderByRelevanceInput) Sort(value SortOrder) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryRelevanceHolidayOrderByRelevanceInput) SortIfPresent(value *SortOrder) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Sort(*value)
}

func (r holidayQueryRelevanceHolidayOrderByRelevanceInput) Search(value string) holidayDefaultParam {
	return holidayDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r holidayQueryRelevanceHolidayOrderByRelevanceInput) SearchIfPresent(value *string) holidayDefaultParam {
	if value == nil {
		return holidayDefaultParam{}
	}
	return r.Search(*value)
}

func (r holidayQueryRelevanceHolidayOrderByRelevanceInput) Field() holidayPrismaFields {
	return holidayFieldRelevance
}

// StoreStatus acts as a namespaces to access query methods for the StoreStatus model
var StoreStatus = storeStatusQuery{}

// storeStatusQuery exposes query functions for the storeStatus model
type storeStatusQuery struct {

	// StoreID
	//
	// @required
	StoreID storeStatusQueryStoreIDString

	// Date
	//
	// @required
	Date storeStatusQueryDateDateTime

	// IsOpen
	//
	// @required
	IsOpen storeStatusQueryIsOpenBoolean

	// IsExisting
	//
	// @required
	IsExisting storeStatusQueryIsExistingBoolean

	// CreatedAt
	//
	// @required
	CreatedAt storeStatusQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt storeStatusQueryUpdatedAtDateTime

	// Relevance_
	//
	// @optional
	Relevance_ storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput
}

func (storeStatusQuery) Not(params ...StoreStatusWhereParam) storeStatusDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeStatusDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (storeStatusQuery) Or(params ...StoreStatusWhereParam) storeStatusDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeStatusDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (storeStatusQuery) And(params ...StoreStatusWhereParam) storeStatusDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return storeStatusDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (storeStatusQuery) StoreIDDate(
	_storeID StoreStatusWithPrismaStoreIDWhereParam,

	_date StoreStatusWithPrismaDateWhereParam,
) StoreStatusEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _storeID.field())
	fields = append(fields, _date.field())

	return storeStatusEqualsUniqueParam{
		data: builder.Field{
			Name:   "storeId_date",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type storeStatusQueryStoreIDString struct{}

// Set the required value of StoreID
func (r storeStatusQueryStoreIDString) Set(value string) storeStatusWithPrismaStoreIDSetParam {

	return storeStatusWithPrismaStoreIDSetParam{
		data: builder.Field{
			Name:  "storeId",
			Value: value,
		},
	}

}

// Set the optional value of StoreID dynamically
func (r storeStatusQueryStoreIDString) SetIfPresent(value *String) storeStatusWithPrismaStoreIDSetParam {
	if value == nil {
		return storeStatusWithPrismaStoreIDSetParam{}
	}

	return r.Set(*value)
}

func (r storeStatusQueryStoreIDString) Equals(value string) storeStatusWithPrismaStoreIDEqualsParam {

	return storeStatusWithPrismaStoreIDEqualsParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) EqualsIfPresent(value *string) storeStatusWithPrismaStoreIDEqualsParam {
	if value == nil {
		return storeStatusWithPrismaStoreIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeStatusQueryStoreIDString) Order(direction SortOrder) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name:  "storeId",
			Value: direction,
		},
	}
}

func (r storeStatusQueryStoreIDString) Cursor(cursor string) storeStatusCursorParam {
	return storeStatusCursorParam{
		data: builder.Field{
			Name:  "storeId",
			Value: cursor,
		},
	}
}

func (r storeStatusQueryStoreIDString) In(value []string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) InIfPresent(value []string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.In(value)
}

func (r storeStatusQueryStoreIDString) NotIn(value []string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) NotInIfPresent(value []string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeStatusQueryStoreIDString) Lt(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) LtIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeStatusQueryStoreIDString) Lte(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) LteIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeStatusQueryStoreIDString) Gt(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) GtIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeStatusQueryStoreIDString) Gte(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) GteIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeStatusQueryStoreIDString) Contains(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) ContainsIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Contains(*value)
}

func (r storeStatusQueryStoreIDString) StartsWith(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) StartsWithIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r storeStatusQueryStoreIDString) EndsWith(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) EndsWithIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r storeStatusQueryStoreIDString) Search(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) SearchIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Search(*value)
}

func (r storeStatusQueryStoreIDString) Not(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryStoreIDString) NotIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r storeStatusQueryStoreIDString) HasPrefix(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r storeStatusQueryStoreIDString) HasPrefixIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r storeStatusQueryStoreIDString) HasSuffix(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "storeId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r storeStatusQueryStoreIDString) HasSuffixIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r storeStatusQueryStoreIDString) Field() storeStatusPrismaFields {
	return storeStatusFieldStoreID
}

// base struct
type storeStatusQueryDateDateTime struct{}

// Set the required value of Date
func (r storeStatusQueryDateDateTime) Set(value DateTime) storeStatusWithPrismaDateSetParam {

	return storeStatusWithPrismaDateSetParam{
		data: builder.Field{
			Name:  "date",
			Value: value,
		},
	}

}

// Set the optional value of Date dynamically
func (r storeStatusQueryDateDateTime) SetIfPresent(value *DateTime) storeStatusWithPrismaDateSetParam {
	if value == nil {
		return storeStatusWithPrismaDateSetParam{}
	}

	return r.Set(*value)
}

func (r storeStatusQueryDateDateTime) Equals(value DateTime) storeStatusWithPrismaDateEqualsParam {

	return storeStatusWithPrismaDateEqualsParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) EqualsIfPresent(value *DateTime) storeStatusWithPrismaDateEqualsParam {
	if value == nil {
		return storeStatusWithPrismaDateEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeStatusQueryDateDateTime) Order(direction SortOrder) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name:  "date",
			Value: direction,
		},
	}
}

func (r storeStatusQueryDateDateTime) Cursor(cursor DateTime) storeStatusCursorParam {
	return storeStatusCursorParam{
		data: builder.Field{
			Name:  "date",
			Value: cursor,
		},
	}
}

func (r storeStatusQueryDateDateTime) In(value []DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) InIfPresent(value []DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.In(value)
}

func (r storeStatusQueryDateDateTime) NotIn(value []DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) NotInIfPresent(value []DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeStatusQueryDateDateTime) Lt(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) LtIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeStatusQueryDateDateTime) Lte(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) LteIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeStatusQueryDateDateTime) Gt(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) GtIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeStatusQueryDateDateTime) Gte(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) GteIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeStatusQueryDateDateTime) Not(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryDateDateTime) NotIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r storeStatusQueryDateDateTime) Before(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r storeStatusQueryDateDateTime) BeforeIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r storeStatusQueryDateDateTime) After(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r storeStatusQueryDateDateTime) AfterIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r storeStatusQueryDateDateTime) BeforeEquals(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r storeStatusQueryDateDateTime) BeforeEqualsIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r storeStatusQueryDateDateTime) AfterEquals(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "date",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r storeStatusQueryDateDateTime) AfterEqualsIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r storeStatusQueryDateDateTime) Field() storeStatusPrismaFields {
	return storeStatusFieldDate
}

// base struct
type storeStatusQueryIsOpenBoolean struct{}

// Set the required value of IsOpen
func (r storeStatusQueryIsOpenBoolean) Set(value bool) storeStatusSetParam {

	return storeStatusSetParam{
		data: builder.Field{
			Name:  "isOpen",
			Value: value,
		},
	}

}

// Set the optional value of IsOpen dynamically
func (r storeStatusQueryIsOpenBoolean) SetIfPresent(value *Boolean) storeStatusSetParam {
	if value == nil {
		return storeStatusSetParam{}
	}

	return r.Set(*value)
}

func (r storeStatusQueryIsOpenBoolean) Equals(value bool) storeStatusWithPrismaIsOpenEqualsParam {

	return storeStatusWithPrismaIsOpenEqualsParam{
		data: builder.Field{
			Name: "isOpen",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryIsOpenBoolean) EqualsIfPresent(value *bool) storeStatusWithPrismaIsOpenEqualsParam {
	if value == nil {
		return storeStatusWithPrismaIsOpenEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeStatusQueryIsOpenBoolean) Order(direction SortOrder) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name:  "isOpen",
			Value: direction,
		},
	}
}

func (r storeStatusQueryIsOpenBoolean) Cursor(cursor bool) storeStatusCursorParam {
	return storeStatusCursorParam{
		data: builder.Field{
			Name:  "isOpen",
			Value: cursor,
		},
	}
}

func (r storeStatusQueryIsOpenBoolean) Field() storeStatusPrismaFields {
	return storeStatusFieldIsOpen
}

// base struct
type storeStatusQueryIsExistingBoolean struct{}

// Set the required value of IsExisting
func (r storeStatusQueryIsExistingBoolean) Set(value bool) storeStatusSetParam {

	return storeStatusSetParam{
		data: builder.Field{
			Name:  "isExisting",
			Value: value,
		},
	}

}

// Set the optional value of IsExisting dynamically
func (r storeStatusQueryIsExistingBoolean) SetIfPresent(value *Boolean) storeStatusSetParam {
	if value == nil {
		return storeStatusSetParam{}
	}

	return r.Set(*value)
}

func (r storeStatusQueryIsExistingBoolean) Equals(value bool) storeStatusWithPrismaIsExistingEqualsParam {

	return storeStatusWithPrismaIsExistingEqualsParam{
		data: builder.Field{
			Name: "isExisting",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryIsExistingBoolean) EqualsIfPresent(value *bool) storeStatusWithPrismaIsExistingEqualsParam {
	if value == nil {
		return storeStatusWithPrismaIsExistingEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeStatusQueryIsExistingBoolean) Order(direction SortOrder) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name:  "isExisting",
			Value: direction,
		},
	}
}

func (r storeStatusQueryIsExistingBoolean) Cursor(cursor bool) storeStatusCursorParam {
	return storeStatusCursorParam{
		data: builder.Field{
			Name:  "isExisting",
			Value: cursor,
		},
	}
}

func (r storeStatusQueryIsExistingBoolean) Field() storeStatusPrismaFields {
	return storeStatusFieldIsExisting
}

// base struct
type storeStatusQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r storeStatusQueryCreatedAtDateTime) Set(value DateTime) storeStatusSetParam {

	return storeStatusSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r storeStatusQueryCreatedAtDateTime) SetIfPresent(value *DateTime) storeStatusSetParam {
	if value == nil {
		return storeStatusSetParam{}
	}

	return r.Set(*value)
}

func (r storeStatusQueryCreatedAtDateTime) Equals(value DateTime) storeStatusWithPrismaCreatedAtEqualsParam {

	return storeStatusWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) storeStatusWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return storeStatusWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeStatusQueryCreatedAtDateTime) Order(direction SortOrder) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) Cursor(cursor DateTime) storeStatusCursorParam {
	return storeStatusCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) In(value []DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) InIfPresent(value []DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.In(value)
}

func (r storeStatusQueryCreatedAtDateTime) NotIn(value []DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeStatusQueryCreatedAtDateTime) Lt(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) LtIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeStatusQueryCreatedAtDateTime) Lte(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) LteIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeStatusQueryCreatedAtDateTime) Gt(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) GtIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeStatusQueryCreatedAtDateTime) Gte(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) GteIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeStatusQueryCreatedAtDateTime) Not(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryCreatedAtDateTime) NotIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r storeStatusQueryCreatedAtDateTime) Before(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r storeStatusQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r storeStatusQueryCreatedAtDateTime) After(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r storeStatusQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r storeStatusQueryCreatedAtDateTime) BeforeEquals(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r storeStatusQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r storeStatusQueryCreatedAtDateTime) AfterEquals(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r storeStatusQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r storeStatusQueryCreatedAtDateTime) Field() storeStatusPrismaFields {
	return storeStatusFieldCreatedAt
}

// base struct
type storeStatusQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r storeStatusQueryUpdatedAtDateTime) Set(value DateTime) storeStatusSetParam {

	return storeStatusSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r storeStatusQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) storeStatusSetParam {
	if value == nil {
		return storeStatusSetParam{}
	}

	return r.Set(*value)
}

func (r storeStatusQueryUpdatedAtDateTime) Equals(value DateTime) storeStatusWithPrismaUpdatedAtEqualsParam {

	return storeStatusWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) storeStatusWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return storeStatusWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r storeStatusQueryUpdatedAtDateTime) Order(direction SortOrder) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) Cursor(cursor DateTime) storeStatusCursorParam {
	return storeStatusCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) In(value []DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) InIfPresent(value []DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.In(value)
}

func (r storeStatusQueryUpdatedAtDateTime) NotIn(value []DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.NotIn(value)
}

func (r storeStatusQueryUpdatedAtDateTime) Lt(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lt(*value)
}

func (r storeStatusQueryUpdatedAtDateTime) Lte(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Lte(*value)
}

func (r storeStatusQueryUpdatedAtDateTime) Gt(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gt(*value)
}

func (r storeStatusQueryUpdatedAtDateTime) Gte(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Gte(*value)
}

func (r storeStatusQueryUpdatedAtDateTime) Not(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r storeStatusQueryUpdatedAtDateTime) Before(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r storeStatusQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r storeStatusQueryUpdatedAtDateTime) After(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r storeStatusQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r storeStatusQueryUpdatedAtDateTime) BeforeEquals(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r storeStatusQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r storeStatusQueryUpdatedAtDateTime) AfterEquals(value DateTime) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r storeStatusQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r storeStatusQueryUpdatedAtDateTime) Field() storeStatusPrismaFields {
	return storeStatusFieldUpdatedAt
}

// base struct
type storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput struct{}

func (r storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput) Fields(value []StoreStatusOrderByRelevanceFieldEnum) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "fields",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput) FieldsIfPresent(value []StoreStatusOrderByRelevanceFieldEnum) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Fields(value)
}

func (r storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput) Sort(value SortOrder) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "sort",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput) SortIfPresent(value *SortOrder) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Sort(*value)
}

func (r storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput) Search(value string) storeStatusDefaultParam {
	return storeStatusDefaultParam{
		data: builder.Field{
			Name: "_relevance",
			Fields: []builder.Field{
				{
					Name:  "search",
					Value: value,
				},
			},
		},
	}
}

func (r storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput) SearchIfPresent(value *string) storeStatusDefaultParam {
	if value == nil {
		return storeStatusDefaultParam{}
	}
	return r.Search(*value)
}

func (r storeStatusQueryRelevanceStoreStatusOrderByRelevanceInput) Field() storeStatusPrismaFields {
	return storeStatusFieldRelevance
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "uid"},
	{Name: "role"},
	{Name: "name"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "synchedAt"},
	{Name: "deletedAt"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaUIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	uidField()
}

type UserWithPrismaUIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	uidField()
}

type userWithPrismaUIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUIDSetParam) userModel() {}

func (p userWithPrismaUIDSetParam) uidField() {}

type UserWithPrismaUIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	uidField()
}

type userWithPrismaUIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUIDEqualsParam) userModel() {}

func (p userWithPrismaUIDEqualsParam) uidField() {}

func (userWithPrismaUIDSetParam) settable()  {}
func (userWithPrismaUIDEqualsParam) equals() {}

type userWithPrismaUIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaUIDEqualsUniqueParam) uidField()  {}

func (userWithPrismaUIDEqualsUniqueParam) unique() {}
func (userWithPrismaUIDEqualsUniqueParam) equals() {}

type UserWithPrismaRoleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	roleField()
}

type UserWithPrismaRoleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	roleField()
}

type userWithPrismaRoleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleSetParam) userModel() {}

func (p userWithPrismaRoleSetParam) roleField() {}

type UserWithPrismaRoleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	roleField()
}

type userWithPrismaRoleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleEqualsParam) userModel() {}

func (p userWithPrismaRoleEqualsParam) roleField() {}

func (userWithPrismaRoleSetParam) settable()  {}
func (userWithPrismaRoleEqualsParam) equals() {}

type userWithPrismaRoleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRoleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRoleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRoleEqualsUniqueParam) userModel() {}
func (p userWithPrismaRoleEqualsUniqueParam) roleField() {}

func (userWithPrismaRoleEqualsUniqueParam) unique() {}
func (userWithPrismaRoleEqualsUniqueParam) equals() {}

type UserWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	nameField()
}

type UserWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	nameField()
}

type userWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNameSetParam) userModel() {}

func (p userWithPrismaNameSetParam) nameField() {}

type UserWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	nameField()
}

type userWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNameEqualsParam) userModel() {}

func (p userWithPrismaNameEqualsParam) nameField() {}

func (userWithPrismaNameSetParam) settable()  {}
func (userWithPrismaNameEqualsParam) equals() {}

type userWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaNameEqualsUniqueParam) userModel() {}
func (p userWithPrismaNameEqualsUniqueParam) nameField() {}

func (userWithPrismaNameEqualsUniqueParam) unique() {}
func (userWithPrismaNameEqualsUniqueParam) equals() {}

type UserWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	createdAtField()
}

type UserWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtSetParam) userModel() {}

func (p userWithPrismaCreatedAtSetParam) createdAtField() {}

type UserWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsParam) userModel() {}

func (p userWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userWithPrismaCreatedAtSetParam) settable()  {}
func (userWithPrismaCreatedAtEqualsParam) equals() {}

type userWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	updatedAtField()
}

type UserWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtSetParam) userModel() {}

func (p userWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsParam) userModel() {}

func (p userWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userWithPrismaUpdatedAtSetParam) settable()  {}
func (userWithPrismaUpdatedAtEqualsParam) equals() {}

type userWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaSynchedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	synchedAtField()
}

type UserWithPrismaSynchedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	synchedAtField()
}

type userWithPrismaSynchedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSynchedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSynchedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSynchedAtSetParam) userModel() {}

func (p userWithPrismaSynchedAtSetParam) synchedAtField() {}

type UserWithPrismaSynchedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	synchedAtField()
}

type userWithPrismaSynchedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSynchedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSynchedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSynchedAtEqualsParam) userModel() {}

func (p userWithPrismaSynchedAtEqualsParam) synchedAtField() {}

func (userWithPrismaSynchedAtSetParam) settable()  {}
func (userWithPrismaSynchedAtEqualsParam) equals() {}

type userWithPrismaSynchedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSynchedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSynchedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSynchedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaSynchedAtEqualsUniqueParam) synchedAtField() {}

func (userWithPrismaSynchedAtEqualsUniqueParam) unique() {}
func (userWithPrismaSynchedAtEqualsUniqueParam) equals() {}

type UserWithPrismaDeletedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	deletedAtField()
}

type UserWithPrismaDeletedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	deletedAtField()
}

type userWithPrismaDeletedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDeletedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDeletedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDeletedAtSetParam) userModel() {}

func (p userWithPrismaDeletedAtSetParam) deletedAtField() {}

type UserWithPrismaDeletedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	deletedAtField()
}

type userWithPrismaDeletedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDeletedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDeletedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDeletedAtEqualsParam) userModel() {}

func (p userWithPrismaDeletedAtEqualsParam) deletedAtField() {}

func (userWithPrismaDeletedAtSetParam) settable()  {}
func (userWithPrismaDeletedAtEqualsParam) equals() {}

type userWithPrismaDeletedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDeletedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDeletedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDeletedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaDeletedAtEqualsUniqueParam) deletedAtField() {}

func (userWithPrismaDeletedAtEqualsUniqueParam) unique() {}
func (userWithPrismaDeletedAtEqualsUniqueParam) equals() {}

type accessKeyActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var accessKeyOutput = []builder.Output{
	{Name: "name"},
	{Name: "value"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type AccessKeyRelationWith interface {
	getQuery() builder.Query
	with()
	accessKeyRelation()
}

type AccessKeyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
}

type accessKeyDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyDefaultParam) field() builder.Field {
	return p.data
}

func (p accessKeyDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyDefaultParam) accessKeyModel() {}

type AccessKeyOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
}

type accessKeyOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyOrderByParam) field() builder.Field {
	return p.data
}

func (p accessKeyOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyOrderByParam) accessKeyModel() {}

type AccessKeyCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	isCursor()
}

type accessKeyCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyCursorParam) field() builder.Field {
	return p.data
}

func (p accessKeyCursorParam) isCursor() {}

func (p accessKeyCursorParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyCursorParam) accessKeyModel() {}

type AccessKeyParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	accessKeyModel()
}

type accessKeyParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyParamUnique) accessKeyModel() {}

func (accessKeyParamUnique) unique() {}

func (p accessKeyParamUnique) field() builder.Field {
	return p.data
}

func (p accessKeyParamUnique) getQuery() builder.Query {
	return p.query
}

type AccessKeyEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	accessKeyModel()
}

type accessKeyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyEqualsParam) accessKeyModel() {}

func (accessKeyEqualsParam) equals() {}

func (p accessKeyEqualsParam) field() builder.Field {
	return p.data
}

func (p accessKeyEqualsParam) getQuery() builder.Query {
	return p.query
}

type AccessKeyEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	accessKeyModel()
}

type accessKeyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyEqualsUniqueParam) accessKeyModel() {}

func (accessKeyEqualsUniqueParam) unique() {}
func (accessKeyEqualsUniqueParam) equals() {}

func (p accessKeyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p accessKeyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type AccessKeySetParam interface {
	field() builder.Field
	settable()
	accessKeyModel()
}

type accessKeySetParam struct {
	data builder.Field
}

func (accessKeySetParam) settable() {}

func (p accessKeySetParam) field() builder.Field {
	return p.data
}

func (p accessKeySetParam) accessKeyModel() {}

type AccessKeyWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	accessKeyModel()
	nameField()
}

type AccessKeyWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	nameField()
}

type accessKeyWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaNameSetParam) accessKeyModel() {}

func (p accessKeyWithPrismaNameSetParam) nameField() {}

type AccessKeyWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	nameField()
}

type accessKeyWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaNameEqualsParam) accessKeyModel() {}

func (p accessKeyWithPrismaNameEqualsParam) nameField() {}

func (accessKeyWithPrismaNameSetParam) settable()  {}
func (accessKeyWithPrismaNameEqualsParam) equals() {}

type accessKeyWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaNameEqualsUniqueParam) accessKeyModel() {}
func (p accessKeyWithPrismaNameEqualsUniqueParam) nameField()      {}

func (accessKeyWithPrismaNameEqualsUniqueParam) unique() {}
func (accessKeyWithPrismaNameEqualsUniqueParam) equals() {}

type AccessKeyWithPrismaValueEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	accessKeyModel()
	valueField()
}

type AccessKeyWithPrismaValueSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	valueField()
}

type accessKeyWithPrismaValueSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaValueSetParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaValueSetParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaValueSetParam) accessKeyModel() {}

func (p accessKeyWithPrismaValueSetParam) valueField() {}

type AccessKeyWithPrismaValueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	valueField()
}

type accessKeyWithPrismaValueEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaValueEqualsParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaValueEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaValueEqualsParam) accessKeyModel() {}

func (p accessKeyWithPrismaValueEqualsParam) valueField() {}

func (accessKeyWithPrismaValueSetParam) settable()  {}
func (accessKeyWithPrismaValueEqualsParam) equals() {}

type accessKeyWithPrismaValueEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaValueEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaValueEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaValueEqualsUniqueParam) accessKeyModel() {}
func (p accessKeyWithPrismaValueEqualsUniqueParam) valueField()     {}

func (accessKeyWithPrismaValueEqualsUniqueParam) unique() {}
func (accessKeyWithPrismaValueEqualsUniqueParam) equals() {}

type AccessKeyWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	accessKeyModel()
	createdAtField()
}

type AccessKeyWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	createdAtField()
}

type accessKeyWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaCreatedAtSetParam) accessKeyModel() {}

func (p accessKeyWithPrismaCreatedAtSetParam) createdAtField() {}

type AccessKeyWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	createdAtField()
}

type accessKeyWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaCreatedAtEqualsParam) accessKeyModel() {}

func (p accessKeyWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (accessKeyWithPrismaCreatedAtSetParam) settable()  {}
func (accessKeyWithPrismaCreatedAtEqualsParam) equals() {}

type accessKeyWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaCreatedAtEqualsUniqueParam) accessKeyModel() {}
func (p accessKeyWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (accessKeyWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (accessKeyWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type AccessKeyWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	accessKeyModel()
	updatedAtField()
}

type AccessKeyWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	updatedAtField()
}

type accessKeyWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaUpdatedAtSetParam) accessKeyModel() {}

func (p accessKeyWithPrismaUpdatedAtSetParam) updatedAtField() {}

type AccessKeyWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	accessKeyModel()
	updatedAtField()
}

type accessKeyWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaUpdatedAtEqualsParam) accessKeyModel() {}

func (p accessKeyWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (accessKeyWithPrismaUpdatedAtSetParam) settable()  {}
func (accessKeyWithPrismaUpdatedAtEqualsParam) equals() {}

type accessKeyWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p accessKeyWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p accessKeyWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p accessKeyWithPrismaUpdatedAtEqualsUniqueParam) accessKeyModel() {}
func (p accessKeyWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (accessKeyWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (accessKeyWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type importActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var importOutput = []builder.Output{
	{Name: "id"},
	{Name: "resourceType"},
	{Name: "status"},
	{Name: "output"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "objectKey"},
}

type ImportRelationWith interface {
	getQuery() builder.Query
	with()
	importRelation()
}

type ImportWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
}

type importDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p importDefaultParam) field() builder.Field {
	return p.data
}

func (p importDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p importDefaultParam) importModel() {}

type ImportOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
}

type importOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p importOrderByParam) field() builder.Field {
	return p.data
}

func (p importOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p importOrderByParam) importModel() {}

type ImportCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	isCursor()
}

type importCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p importCursorParam) field() builder.Field {
	return p.data
}

func (p importCursorParam) isCursor() {}

func (p importCursorParam) getQuery() builder.Query {
	return p.query
}

func (p importCursorParam) importModel() {}

type ImportParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	importModel()
}

type importParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p importParamUnique) importModel() {}

func (importParamUnique) unique() {}

func (p importParamUnique) field() builder.Field {
	return p.data
}

func (p importParamUnique) getQuery() builder.Query {
	return p.query
}

type ImportEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
}

type importEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importEqualsParam) importModel() {}

func (importEqualsParam) equals() {}

func (p importEqualsParam) field() builder.Field {
	return p.data
}

func (p importEqualsParam) getQuery() builder.Query {
	return p.query
}

type ImportEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	importModel()
}

type importEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importEqualsUniqueParam) importModel() {}

func (importEqualsUniqueParam) unique() {}
func (importEqualsUniqueParam) equals() {}

func (p importEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ImportSetParam interface {
	field() builder.Field
	settable()
	importModel()
}

type importSetParam struct {
	data builder.Field
}

func (importSetParam) settable() {}

func (p importSetParam) field() builder.Field {
	return p.data
}

func (p importSetParam) importModel() {}

type ImportWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
	idField()
}

type ImportWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	idField()
}

type importWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaIDSetParam) importModel() {}

func (p importWithPrismaIDSetParam) idField() {}

type ImportWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	idField()
}

type importWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaIDEqualsParam) importModel() {}

func (p importWithPrismaIDEqualsParam) idField() {}

func (importWithPrismaIDSetParam) settable()  {}
func (importWithPrismaIDEqualsParam) equals() {}

type importWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaIDEqualsUniqueParam) importModel() {}
func (p importWithPrismaIDEqualsUniqueParam) idField()     {}

func (importWithPrismaIDEqualsUniqueParam) unique() {}
func (importWithPrismaIDEqualsUniqueParam) equals() {}

type ImportWithPrismaResourceTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
	resourceTypeField()
}

type ImportWithPrismaResourceTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	resourceTypeField()
}

type importWithPrismaResourceTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaResourceTypeSetParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaResourceTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaResourceTypeSetParam) importModel() {}

func (p importWithPrismaResourceTypeSetParam) resourceTypeField() {}

type ImportWithPrismaResourceTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	resourceTypeField()
}

type importWithPrismaResourceTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaResourceTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaResourceTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaResourceTypeEqualsParam) importModel() {}

func (p importWithPrismaResourceTypeEqualsParam) resourceTypeField() {}

func (importWithPrismaResourceTypeSetParam) settable()  {}
func (importWithPrismaResourceTypeEqualsParam) equals() {}

type importWithPrismaResourceTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaResourceTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaResourceTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaResourceTypeEqualsUniqueParam) importModel()       {}
func (p importWithPrismaResourceTypeEqualsUniqueParam) resourceTypeField() {}

func (importWithPrismaResourceTypeEqualsUniqueParam) unique() {}
func (importWithPrismaResourceTypeEqualsUniqueParam) equals() {}

type ImportWithPrismaStatusEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
	statusField()
}

type ImportWithPrismaStatusSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	statusField()
}

type importWithPrismaStatusSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaStatusSetParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaStatusSetParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaStatusSetParam) importModel() {}

func (p importWithPrismaStatusSetParam) statusField() {}

type ImportWithPrismaStatusWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	statusField()
}

type importWithPrismaStatusEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaStatusEqualsParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaStatusEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaStatusEqualsParam) importModel() {}

func (p importWithPrismaStatusEqualsParam) statusField() {}

func (importWithPrismaStatusSetParam) settable()  {}
func (importWithPrismaStatusEqualsParam) equals() {}

type importWithPrismaStatusEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaStatusEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaStatusEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaStatusEqualsUniqueParam) importModel() {}
func (p importWithPrismaStatusEqualsUniqueParam) statusField() {}

func (importWithPrismaStatusEqualsUniqueParam) unique() {}
func (importWithPrismaStatusEqualsUniqueParam) equals() {}

type ImportWithPrismaOutputEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
	outputField()
}

type ImportWithPrismaOutputSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	outputField()
}

type importWithPrismaOutputSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaOutputSetParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaOutputSetParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaOutputSetParam) importModel() {}

func (p importWithPrismaOutputSetParam) outputField() {}

type ImportWithPrismaOutputWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	outputField()
}

type importWithPrismaOutputEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaOutputEqualsParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaOutputEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaOutputEqualsParam) importModel() {}

func (p importWithPrismaOutputEqualsParam) outputField() {}

func (importWithPrismaOutputSetParam) settable()  {}
func (importWithPrismaOutputEqualsParam) equals() {}

type importWithPrismaOutputEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaOutputEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaOutputEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaOutputEqualsUniqueParam) importModel() {}
func (p importWithPrismaOutputEqualsUniqueParam) outputField() {}

func (importWithPrismaOutputEqualsUniqueParam) unique() {}
func (importWithPrismaOutputEqualsUniqueParam) equals() {}

type ImportWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
	createdAtField()
}

type ImportWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	createdAtField()
}

type importWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaCreatedAtSetParam) importModel() {}

func (p importWithPrismaCreatedAtSetParam) createdAtField() {}

type ImportWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	createdAtField()
}

type importWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaCreatedAtEqualsParam) importModel() {}

func (p importWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (importWithPrismaCreatedAtSetParam) settable()  {}
func (importWithPrismaCreatedAtEqualsParam) equals() {}

type importWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaCreatedAtEqualsUniqueParam) importModel()    {}
func (p importWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (importWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (importWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type ImportWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
	updatedAtField()
}

type ImportWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	updatedAtField()
}

type importWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaUpdatedAtSetParam) importModel() {}

func (p importWithPrismaUpdatedAtSetParam) updatedAtField() {}

type ImportWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	updatedAtField()
}

type importWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaUpdatedAtEqualsParam) importModel() {}

func (p importWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (importWithPrismaUpdatedAtSetParam) settable()  {}
func (importWithPrismaUpdatedAtEqualsParam) equals() {}

type importWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaUpdatedAtEqualsUniqueParam) importModel()    {}
func (p importWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (importWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (importWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type ImportWithPrismaObjectKeyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	importModel()
	objectKeyField()
}

type ImportWithPrismaObjectKeySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	objectKeyField()
}

type importWithPrismaObjectKeySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaObjectKeySetParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaObjectKeySetParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaObjectKeySetParam) importModel() {}

func (p importWithPrismaObjectKeySetParam) objectKeyField() {}

type ImportWithPrismaObjectKeyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	importModel()
	objectKeyField()
}

type importWithPrismaObjectKeyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaObjectKeyEqualsParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaObjectKeyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaObjectKeyEqualsParam) importModel() {}

func (p importWithPrismaObjectKeyEqualsParam) objectKeyField() {}

func (importWithPrismaObjectKeySetParam) settable()  {}
func (importWithPrismaObjectKeyEqualsParam) equals() {}

type importWithPrismaObjectKeyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p importWithPrismaObjectKeyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p importWithPrismaObjectKeyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p importWithPrismaObjectKeyEqualsUniqueParam) importModel()    {}
func (p importWithPrismaObjectKeyEqualsUniqueParam) objectKeyField() {}

func (importWithPrismaObjectKeyEqualsUniqueParam) unique() {}
func (importWithPrismaObjectKeyEqualsUniqueParam) equals() {}

type productActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var productOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "categoryId1"},
	{Name: "categoryId2"},
	{Name: "categoryId3"},
	{Name: "categoryId4"},
	{Name: "categoryId5"},
	{Name: "note"},
	{Name: "price"},
	{Name: "custom1"},
	{Name: "custom2"},
	{Name: "description"},
	{Name: "details"},
	{Name: "imageUrl1"},
	{Name: "imageUrl2"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type ProductRelationWith interface {
	getQuery() builder.Query
	with()
	productRelation()
}

type ProductWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
}

type productDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p productDefaultParam) field() builder.Field {
	return p.data
}

func (p productDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p productDefaultParam) productModel() {}

type ProductOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
}

type productOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p productOrderByParam) field() builder.Field {
	return p.data
}

func (p productOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p productOrderByParam) productModel() {}

type ProductCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	isCursor()
}

type productCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p productCursorParam) field() builder.Field {
	return p.data
}

func (p productCursorParam) isCursor() {}

func (p productCursorParam) getQuery() builder.Query {
	return p.query
}

func (p productCursorParam) productModel() {}

type ProductParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	productModel()
}

type productParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p productParamUnique) productModel() {}

func (productParamUnique) unique() {}

func (p productParamUnique) field() builder.Field {
	return p.data
}

func (p productParamUnique) getQuery() builder.Query {
	return p.query
}

type ProductEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
}

type productEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productEqualsParam) productModel() {}

func (productEqualsParam) equals() {}

func (p productEqualsParam) field() builder.Field {
	return p.data
}

func (p productEqualsParam) getQuery() builder.Query {
	return p.query
}

type ProductEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	productModel()
}

type productEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productEqualsUniqueParam) productModel() {}

func (productEqualsUniqueParam) unique() {}
func (productEqualsUniqueParam) equals() {}

func (p productEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ProductSetParam interface {
	field() builder.Field
	settable()
	productModel()
}

type productSetParam struct {
	data builder.Field
}

func (productSetParam) settable() {}

func (p productSetParam) field() builder.Field {
	return p.data
}

func (p productSetParam) productModel() {}

type ProductWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	idField()
}

type ProductWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	idField()
}

type productWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaIDSetParam) productModel() {}

func (p productWithPrismaIDSetParam) idField() {}

type ProductWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	idField()
}

type productWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaIDEqualsParam) productModel() {}

func (p productWithPrismaIDEqualsParam) idField() {}

func (productWithPrismaIDSetParam) settable()  {}
func (productWithPrismaIDEqualsParam) equals() {}

type productWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaIDEqualsUniqueParam) productModel() {}
func (p productWithPrismaIDEqualsUniqueParam) idField()      {}

func (productWithPrismaIDEqualsUniqueParam) unique() {}
func (productWithPrismaIDEqualsUniqueParam) equals() {}

type ProductWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	nameField()
}

type ProductWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	nameField()
}

type productWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNameSetParam) productModel() {}

func (p productWithPrismaNameSetParam) nameField() {}

type ProductWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	nameField()
}

type productWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNameEqualsParam) productModel() {}

func (p productWithPrismaNameEqualsParam) nameField() {}

func (productWithPrismaNameSetParam) settable()  {}
func (productWithPrismaNameEqualsParam) equals() {}

type productWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNameEqualsUniqueParam) productModel() {}
func (p productWithPrismaNameEqualsUniqueParam) nameField()    {}

func (productWithPrismaNameEqualsUniqueParam) unique() {}
func (productWithPrismaNameEqualsUniqueParam) equals() {}

type ProductWithPrismaCategoryID1EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	categoryID1Field()
}

type ProductWithPrismaCategoryID1SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID1Field()
}

type productWithPrismaCategoryID1SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID1SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID1SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID1SetParam) productModel() {}

func (p productWithPrismaCategoryID1SetParam) categoryID1Field() {}

type ProductWithPrismaCategoryID1WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID1Field()
}

type productWithPrismaCategoryID1EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID1EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID1EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID1EqualsParam) productModel() {}

func (p productWithPrismaCategoryID1EqualsParam) categoryID1Field() {}

func (productWithPrismaCategoryID1SetParam) settable()  {}
func (productWithPrismaCategoryID1EqualsParam) equals() {}

type productWithPrismaCategoryID1EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID1EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID1EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID1EqualsUniqueParam) productModel()     {}
func (p productWithPrismaCategoryID1EqualsUniqueParam) categoryID1Field() {}

func (productWithPrismaCategoryID1EqualsUniqueParam) unique() {}
func (productWithPrismaCategoryID1EqualsUniqueParam) equals() {}

type ProductWithPrismaCategoryID2EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	categoryID2Field()
}

type ProductWithPrismaCategoryID2SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID2Field()
}

type productWithPrismaCategoryID2SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID2SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID2SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID2SetParam) productModel() {}

func (p productWithPrismaCategoryID2SetParam) categoryID2Field() {}

type ProductWithPrismaCategoryID2WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID2Field()
}

type productWithPrismaCategoryID2EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID2EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID2EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID2EqualsParam) productModel() {}

func (p productWithPrismaCategoryID2EqualsParam) categoryID2Field() {}

func (productWithPrismaCategoryID2SetParam) settable()  {}
func (productWithPrismaCategoryID2EqualsParam) equals() {}

type productWithPrismaCategoryID2EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID2EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID2EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID2EqualsUniqueParam) productModel()     {}
func (p productWithPrismaCategoryID2EqualsUniqueParam) categoryID2Field() {}

func (productWithPrismaCategoryID2EqualsUniqueParam) unique() {}
func (productWithPrismaCategoryID2EqualsUniqueParam) equals() {}

type ProductWithPrismaCategoryID3EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	categoryID3Field()
}

type ProductWithPrismaCategoryID3SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID3Field()
}

type productWithPrismaCategoryID3SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID3SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID3SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID3SetParam) productModel() {}

func (p productWithPrismaCategoryID3SetParam) categoryID3Field() {}

type ProductWithPrismaCategoryID3WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID3Field()
}

type productWithPrismaCategoryID3EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID3EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID3EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID3EqualsParam) productModel() {}

func (p productWithPrismaCategoryID3EqualsParam) categoryID3Field() {}

func (productWithPrismaCategoryID3SetParam) settable()  {}
func (productWithPrismaCategoryID3EqualsParam) equals() {}

type productWithPrismaCategoryID3EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID3EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID3EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID3EqualsUniqueParam) productModel()     {}
func (p productWithPrismaCategoryID3EqualsUniqueParam) categoryID3Field() {}

func (productWithPrismaCategoryID3EqualsUniqueParam) unique() {}
func (productWithPrismaCategoryID3EqualsUniqueParam) equals() {}

type ProductWithPrismaCategoryID4EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	categoryID4Field()
}

type ProductWithPrismaCategoryID4SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID4Field()
}

type productWithPrismaCategoryID4SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID4SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID4SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID4SetParam) productModel() {}

func (p productWithPrismaCategoryID4SetParam) categoryID4Field() {}

type ProductWithPrismaCategoryID4WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID4Field()
}

type productWithPrismaCategoryID4EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID4EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID4EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID4EqualsParam) productModel() {}

func (p productWithPrismaCategoryID4EqualsParam) categoryID4Field() {}

func (productWithPrismaCategoryID4SetParam) settable()  {}
func (productWithPrismaCategoryID4EqualsParam) equals() {}

type productWithPrismaCategoryID4EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID4EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID4EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID4EqualsUniqueParam) productModel()     {}
func (p productWithPrismaCategoryID4EqualsUniqueParam) categoryID4Field() {}

func (productWithPrismaCategoryID4EqualsUniqueParam) unique() {}
func (productWithPrismaCategoryID4EqualsUniqueParam) equals() {}

type ProductWithPrismaCategoryID5EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	categoryID5Field()
}

type ProductWithPrismaCategoryID5SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID5Field()
}

type productWithPrismaCategoryID5SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID5SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID5SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID5SetParam) productModel() {}

func (p productWithPrismaCategoryID5SetParam) categoryID5Field() {}

type ProductWithPrismaCategoryID5WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	categoryID5Field()
}

type productWithPrismaCategoryID5EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID5EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID5EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID5EqualsParam) productModel() {}

func (p productWithPrismaCategoryID5EqualsParam) categoryID5Field() {}

func (productWithPrismaCategoryID5SetParam) settable()  {}
func (productWithPrismaCategoryID5EqualsParam) equals() {}

type productWithPrismaCategoryID5EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCategoryID5EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCategoryID5EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCategoryID5EqualsUniqueParam) productModel()     {}
func (p productWithPrismaCategoryID5EqualsUniqueParam) categoryID5Field() {}

func (productWithPrismaCategoryID5EqualsUniqueParam) unique() {}
func (productWithPrismaCategoryID5EqualsUniqueParam) equals() {}

type ProductWithPrismaNoteEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	noteField()
}

type ProductWithPrismaNoteSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	noteField()
}

type productWithPrismaNoteSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNoteSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNoteSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNoteSetParam) productModel() {}

func (p productWithPrismaNoteSetParam) noteField() {}

type ProductWithPrismaNoteWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	noteField()
}

type productWithPrismaNoteEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNoteEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNoteEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNoteEqualsParam) productModel() {}

func (p productWithPrismaNoteEqualsParam) noteField() {}

func (productWithPrismaNoteSetParam) settable()  {}
func (productWithPrismaNoteEqualsParam) equals() {}

type productWithPrismaNoteEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaNoteEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaNoteEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaNoteEqualsUniqueParam) productModel() {}
func (p productWithPrismaNoteEqualsUniqueParam) noteField()    {}

func (productWithPrismaNoteEqualsUniqueParam) unique() {}
func (productWithPrismaNoteEqualsUniqueParam) equals() {}

type ProductWithPrismaPriceEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	priceField()
}

type ProductWithPrismaPriceSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	priceField()
}

type productWithPrismaPriceSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaPriceSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaPriceSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaPriceSetParam) productModel() {}

func (p productWithPrismaPriceSetParam) priceField() {}

type ProductWithPrismaPriceWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	priceField()
}

type productWithPrismaPriceEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaPriceEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaPriceEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaPriceEqualsParam) productModel() {}

func (p productWithPrismaPriceEqualsParam) priceField() {}

func (productWithPrismaPriceSetParam) settable()  {}
func (productWithPrismaPriceEqualsParam) equals() {}

type productWithPrismaPriceEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaPriceEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaPriceEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaPriceEqualsUniqueParam) productModel() {}
func (p productWithPrismaPriceEqualsUniqueParam) priceField()   {}

func (productWithPrismaPriceEqualsUniqueParam) unique() {}
func (productWithPrismaPriceEqualsUniqueParam) equals() {}

type ProductWithPrismaCustom1EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	custom1Field()
}

type ProductWithPrismaCustom1SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	custom1Field()
}

type productWithPrismaCustom1SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCustom1SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCustom1SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCustom1SetParam) productModel() {}

func (p productWithPrismaCustom1SetParam) custom1Field() {}

type ProductWithPrismaCustom1WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	custom1Field()
}

type productWithPrismaCustom1EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCustom1EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCustom1EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCustom1EqualsParam) productModel() {}

func (p productWithPrismaCustom1EqualsParam) custom1Field() {}

func (productWithPrismaCustom1SetParam) settable()  {}
func (productWithPrismaCustom1EqualsParam) equals() {}

type productWithPrismaCustom1EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCustom1EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCustom1EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCustom1EqualsUniqueParam) productModel() {}
func (p productWithPrismaCustom1EqualsUniqueParam) custom1Field() {}

func (productWithPrismaCustom1EqualsUniqueParam) unique() {}
func (productWithPrismaCustom1EqualsUniqueParam) equals() {}

type ProductWithPrismaCustom2EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	custom2Field()
}

type ProductWithPrismaCustom2SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	custom2Field()
}

type productWithPrismaCustom2SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCustom2SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCustom2SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCustom2SetParam) productModel() {}

func (p productWithPrismaCustom2SetParam) custom2Field() {}

type ProductWithPrismaCustom2WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	custom2Field()
}

type productWithPrismaCustom2EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCustom2EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCustom2EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCustom2EqualsParam) productModel() {}

func (p productWithPrismaCustom2EqualsParam) custom2Field() {}

func (productWithPrismaCustom2SetParam) settable()  {}
func (productWithPrismaCustom2EqualsParam) equals() {}

type productWithPrismaCustom2EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCustom2EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCustom2EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCustom2EqualsUniqueParam) productModel() {}
func (p productWithPrismaCustom2EqualsUniqueParam) custom2Field() {}

func (productWithPrismaCustom2EqualsUniqueParam) unique() {}
func (productWithPrismaCustom2EqualsUniqueParam) equals() {}

type ProductWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	descriptionField()
}

type ProductWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	descriptionField()
}

type productWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaDescriptionSetParam) productModel() {}

func (p productWithPrismaDescriptionSetParam) descriptionField() {}

type ProductWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	descriptionField()
}

type productWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaDescriptionEqualsParam) productModel() {}

func (p productWithPrismaDescriptionEqualsParam) descriptionField() {}

func (productWithPrismaDescriptionSetParam) settable()  {}
func (productWithPrismaDescriptionEqualsParam) equals() {}

type productWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaDescriptionEqualsUniqueParam) productModel()     {}
func (p productWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (productWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (productWithPrismaDescriptionEqualsUniqueParam) equals() {}

type ProductWithPrismaDetailsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	detailsField()
}

type ProductWithPrismaDetailsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	detailsField()
}

type productWithPrismaDetailsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaDetailsSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaDetailsSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaDetailsSetParam) productModel() {}

func (p productWithPrismaDetailsSetParam) detailsField() {}

type ProductWithPrismaDetailsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	detailsField()
}

type productWithPrismaDetailsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaDetailsEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaDetailsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaDetailsEqualsParam) productModel() {}

func (p productWithPrismaDetailsEqualsParam) detailsField() {}

func (productWithPrismaDetailsSetParam) settable()  {}
func (productWithPrismaDetailsEqualsParam) equals() {}

type productWithPrismaDetailsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaDetailsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaDetailsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaDetailsEqualsUniqueParam) productModel() {}
func (p productWithPrismaDetailsEqualsUniqueParam) detailsField() {}

func (productWithPrismaDetailsEqualsUniqueParam) unique() {}
func (productWithPrismaDetailsEqualsUniqueParam) equals() {}

type ProductWithPrismaImageURL1EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	imageURL1Field()
}

type ProductWithPrismaImageURL1SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	imageURL1Field()
}

type productWithPrismaImageURL1SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURL1SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURL1SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURL1SetParam) productModel() {}

func (p productWithPrismaImageURL1SetParam) imageURL1Field() {}

type ProductWithPrismaImageURL1WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	imageURL1Field()
}

type productWithPrismaImageURL1EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURL1EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURL1EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURL1EqualsParam) productModel() {}

func (p productWithPrismaImageURL1EqualsParam) imageURL1Field() {}

func (productWithPrismaImageURL1SetParam) settable()  {}
func (productWithPrismaImageURL1EqualsParam) equals() {}

type productWithPrismaImageURL1EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURL1EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURL1EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURL1EqualsUniqueParam) productModel()   {}
func (p productWithPrismaImageURL1EqualsUniqueParam) imageURL1Field() {}

func (productWithPrismaImageURL1EqualsUniqueParam) unique() {}
func (productWithPrismaImageURL1EqualsUniqueParam) equals() {}

type ProductWithPrismaImageURL2EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	imageURL2Field()
}

type ProductWithPrismaImageURL2SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	imageURL2Field()
}

type productWithPrismaImageURL2SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURL2SetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURL2SetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURL2SetParam) productModel() {}

func (p productWithPrismaImageURL2SetParam) imageURL2Field() {}

type ProductWithPrismaImageURL2WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	imageURL2Field()
}

type productWithPrismaImageURL2EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURL2EqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURL2EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURL2EqualsParam) productModel() {}

func (p productWithPrismaImageURL2EqualsParam) imageURL2Field() {}

func (productWithPrismaImageURL2SetParam) settable()  {}
func (productWithPrismaImageURL2EqualsParam) equals() {}

type productWithPrismaImageURL2EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaImageURL2EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaImageURL2EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaImageURL2EqualsUniqueParam) productModel()   {}
func (p productWithPrismaImageURL2EqualsUniqueParam) imageURL2Field() {}

func (productWithPrismaImageURL2EqualsUniqueParam) unique() {}
func (productWithPrismaImageURL2EqualsUniqueParam) equals() {}

type ProductWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	createdAtField()
}

type ProductWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	createdAtField()
}

type productWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCreatedAtSetParam) productModel() {}

func (p productWithPrismaCreatedAtSetParam) createdAtField() {}

type ProductWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	createdAtField()
}

type productWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCreatedAtEqualsParam) productModel() {}

func (p productWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (productWithPrismaCreatedAtSetParam) settable()  {}
func (productWithPrismaCreatedAtEqualsParam) equals() {}

type productWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaCreatedAtEqualsUniqueParam) productModel()   {}
func (p productWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (productWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (productWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type ProductWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	productModel()
	updatedAtField()
}

type ProductWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	updatedAtField()
}

type productWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaUpdatedAtSetParam) productModel() {}

func (p productWithPrismaUpdatedAtSetParam) updatedAtField() {}

type ProductWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	productModel()
	updatedAtField()
}

type productWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaUpdatedAtEqualsParam) productModel() {}

func (p productWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (productWithPrismaUpdatedAtSetParam) settable()  {}
func (productWithPrismaUpdatedAtEqualsParam) equals() {}

type productWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p productWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p productWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p productWithPrismaUpdatedAtEqualsUniqueParam) productModel()   {}
func (p productWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (productWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (productWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type categoryActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var categoryOutput = []builder.Output{
	{Name: "categoryId1"},
	{Name: "categoryName1"},
	{Name: "categoryId2"},
	{Name: "categoryName2"},
	{Name: "categoryId3"},
	{Name: "categoryName3"},
	{Name: "categoryId4"},
	{Name: "categoryName4"},
	{Name: "categoryId5"},
	{Name: "categoryName5"},
}

type CategoryRelationWith interface {
	getQuery() builder.Query
	with()
	categoryRelation()
}

type CategoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
}

type categoryDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryDefaultParam) field() builder.Field {
	return p.data
}

func (p categoryDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p categoryDefaultParam) categoryModel() {}

type CategoryOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
}

type categoryOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryOrderByParam) field() builder.Field {
	return p.data
}

func (p categoryOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p categoryOrderByParam) categoryModel() {}

type CategoryCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	isCursor()
}

type categoryCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryCursorParam) field() builder.Field {
	return p.data
}

func (p categoryCursorParam) isCursor() {}

func (p categoryCursorParam) getQuery() builder.Query {
	return p.query
}

func (p categoryCursorParam) categoryModel() {}

type CategoryParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	categoryModel()
}

type categoryParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p categoryParamUnique) categoryModel() {}

func (categoryParamUnique) unique() {}

func (p categoryParamUnique) field() builder.Field {
	return p.data
}

func (p categoryParamUnique) getQuery() builder.Query {
	return p.query
}

type CategoryEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
}

type categoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryEqualsParam) categoryModel() {}

func (categoryEqualsParam) equals() {}

func (p categoryEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryEqualsParam) getQuery() builder.Query {
	return p.query
}

type CategoryEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	categoryModel()
}

type categoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryEqualsUniqueParam) categoryModel() {}

func (categoryEqualsUniqueParam) unique() {}
func (categoryEqualsUniqueParam) equals() {}

func (p categoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type CategorySetParam interface {
	field() builder.Field
	settable()
	categoryModel()
}

type categorySetParam struct {
	data builder.Field
}

func (categorySetParam) settable() {}

func (p categorySetParam) field() builder.Field {
	return p.data
}

func (p categorySetParam) categoryModel() {}

type CategoryWithPrismaCategoryID1EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryID1Field()
}

type CategoryWithPrismaCategoryID1SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID1Field()
}

type categoryWithPrismaCategoryID1SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID1SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID1SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID1SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryID1SetParam) categoryID1Field() {}

type CategoryWithPrismaCategoryID1WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID1Field()
}

type categoryWithPrismaCategoryID1EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID1EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID1EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID1EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryID1EqualsParam) categoryID1Field() {}

func (categoryWithPrismaCategoryID1SetParam) settable()  {}
func (categoryWithPrismaCategoryID1EqualsParam) equals() {}

type categoryWithPrismaCategoryID1EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID1EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID1EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID1EqualsUniqueParam) categoryModel()    {}
func (p categoryWithPrismaCategoryID1EqualsUniqueParam) categoryID1Field() {}

func (categoryWithPrismaCategoryID1EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryID1EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryName1EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryName1Field()
}

type CategoryWithPrismaCategoryName1SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName1Field()
}

type categoryWithPrismaCategoryName1SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName1SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName1SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName1SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryName1SetParam) categoryName1Field() {}

type CategoryWithPrismaCategoryName1WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName1Field()
}

type categoryWithPrismaCategoryName1EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName1EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName1EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName1EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryName1EqualsParam) categoryName1Field() {}

func (categoryWithPrismaCategoryName1SetParam) settable()  {}
func (categoryWithPrismaCategoryName1EqualsParam) equals() {}

type categoryWithPrismaCategoryName1EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName1EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName1EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName1EqualsUniqueParam) categoryModel()      {}
func (p categoryWithPrismaCategoryName1EqualsUniqueParam) categoryName1Field() {}

func (categoryWithPrismaCategoryName1EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryName1EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryID2EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryID2Field()
}

type CategoryWithPrismaCategoryID2SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID2Field()
}

type categoryWithPrismaCategoryID2SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID2SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID2SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID2SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryID2SetParam) categoryID2Field() {}

type CategoryWithPrismaCategoryID2WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID2Field()
}

type categoryWithPrismaCategoryID2EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID2EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID2EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID2EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryID2EqualsParam) categoryID2Field() {}

func (categoryWithPrismaCategoryID2SetParam) settable()  {}
func (categoryWithPrismaCategoryID2EqualsParam) equals() {}

type categoryWithPrismaCategoryID2EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID2EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID2EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID2EqualsUniqueParam) categoryModel()    {}
func (p categoryWithPrismaCategoryID2EqualsUniqueParam) categoryID2Field() {}

func (categoryWithPrismaCategoryID2EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryID2EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryName2EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryName2Field()
}

type CategoryWithPrismaCategoryName2SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName2Field()
}

type categoryWithPrismaCategoryName2SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName2SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName2SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName2SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryName2SetParam) categoryName2Field() {}

type CategoryWithPrismaCategoryName2WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName2Field()
}

type categoryWithPrismaCategoryName2EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName2EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName2EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName2EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryName2EqualsParam) categoryName2Field() {}

func (categoryWithPrismaCategoryName2SetParam) settable()  {}
func (categoryWithPrismaCategoryName2EqualsParam) equals() {}

type categoryWithPrismaCategoryName2EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName2EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName2EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName2EqualsUniqueParam) categoryModel()      {}
func (p categoryWithPrismaCategoryName2EqualsUniqueParam) categoryName2Field() {}

func (categoryWithPrismaCategoryName2EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryName2EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryID3EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryID3Field()
}

type CategoryWithPrismaCategoryID3SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID3Field()
}

type categoryWithPrismaCategoryID3SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID3SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID3SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID3SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryID3SetParam) categoryID3Field() {}

type CategoryWithPrismaCategoryID3WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID3Field()
}

type categoryWithPrismaCategoryID3EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID3EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID3EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID3EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryID3EqualsParam) categoryID3Field() {}

func (categoryWithPrismaCategoryID3SetParam) settable()  {}
func (categoryWithPrismaCategoryID3EqualsParam) equals() {}

type categoryWithPrismaCategoryID3EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID3EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID3EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID3EqualsUniqueParam) categoryModel()    {}
func (p categoryWithPrismaCategoryID3EqualsUniqueParam) categoryID3Field() {}

func (categoryWithPrismaCategoryID3EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryID3EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryName3EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryName3Field()
}

type CategoryWithPrismaCategoryName3SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName3Field()
}

type categoryWithPrismaCategoryName3SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName3SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName3SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName3SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryName3SetParam) categoryName3Field() {}

type CategoryWithPrismaCategoryName3WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName3Field()
}

type categoryWithPrismaCategoryName3EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName3EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName3EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName3EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryName3EqualsParam) categoryName3Field() {}

func (categoryWithPrismaCategoryName3SetParam) settable()  {}
func (categoryWithPrismaCategoryName3EqualsParam) equals() {}

type categoryWithPrismaCategoryName3EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName3EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName3EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName3EqualsUniqueParam) categoryModel()      {}
func (p categoryWithPrismaCategoryName3EqualsUniqueParam) categoryName3Field() {}

func (categoryWithPrismaCategoryName3EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryName3EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryID4EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryID4Field()
}

type CategoryWithPrismaCategoryID4SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID4Field()
}

type categoryWithPrismaCategoryID4SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID4SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID4SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID4SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryID4SetParam) categoryID4Field() {}

type CategoryWithPrismaCategoryID4WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID4Field()
}

type categoryWithPrismaCategoryID4EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID4EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID4EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID4EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryID4EqualsParam) categoryID4Field() {}

func (categoryWithPrismaCategoryID4SetParam) settable()  {}
func (categoryWithPrismaCategoryID4EqualsParam) equals() {}

type categoryWithPrismaCategoryID4EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID4EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID4EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID4EqualsUniqueParam) categoryModel()    {}
func (p categoryWithPrismaCategoryID4EqualsUniqueParam) categoryID4Field() {}

func (categoryWithPrismaCategoryID4EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryID4EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryName4EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryName4Field()
}

type CategoryWithPrismaCategoryName4SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName4Field()
}

type categoryWithPrismaCategoryName4SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName4SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName4SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName4SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryName4SetParam) categoryName4Field() {}

type CategoryWithPrismaCategoryName4WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName4Field()
}

type categoryWithPrismaCategoryName4EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName4EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName4EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName4EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryName4EqualsParam) categoryName4Field() {}

func (categoryWithPrismaCategoryName4SetParam) settable()  {}
func (categoryWithPrismaCategoryName4EqualsParam) equals() {}

type categoryWithPrismaCategoryName4EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName4EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName4EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName4EqualsUniqueParam) categoryModel()      {}
func (p categoryWithPrismaCategoryName4EqualsUniqueParam) categoryName4Field() {}

func (categoryWithPrismaCategoryName4EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryName4EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryID5EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryID5Field()
}

type CategoryWithPrismaCategoryID5SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID5Field()
}

type categoryWithPrismaCategoryID5SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID5SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID5SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID5SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryID5SetParam) categoryID5Field() {}

type CategoryWithPrismaCategoryID5WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryID5Field()
}

type categoryWithPrismaCategoryID5EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID5EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID5EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID5EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryID5EqualsParam) categoryID5Field() {}

func (categoryWithPrismaCategoryID5SetParam) settable()  {}
func (categoryWithPrismaCategoryID5EqualsParam) equals() {}

type categoryWithPrismaCategoryID5EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryID5EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryID5EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryID5EqualsUniqueParam) categoryModel()    {}
func (p categoryWithPrismaCategoryID5EqualsUniqueParam) categoryID5Field() {}

func (categoryWithPrismaCategoryID5EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryID5EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryName5EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryName5Field()
}

type CategoryWithPrismaCategoryName5SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName5Field()
}

type categoryWithPrismaCategoryName5SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName5SetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName5SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName5SetParam) categoryModel() {}

func (p categoryWithPrismaCategoryName5SetParam) categoryName5Field() {}

type CategoryWithPrismaCategoryName5WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryName5Field()
}

type categoryWithPrismaCategoryName5EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName5EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName5EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName5EqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryName5EqualsParam) categoryName5Field() {}

func (categoryWithPrismaCategoryName5SetParam) settable()  {}
func (categoryWithPrismaCategoryName5EqualsParam) equals() {}

type categoryWithPrismaCategoryName5EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryName5EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryName5EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryName5EqualsUniqueParam) categoryModel()      {}
func (p categoryWithPrismaCategoryName5EqualsUniqueParam) categoryName5Field() {}

func (categoryWithPrismaCategoryName5EqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryName5EqualsUniqueParam) equals() {}

type CategoryWithPrismaCategoryGroupCategoriesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryModel()
	categoryGroupCategoriesField()
}

type CategoryWithPrismaCategoryGroupCategoriesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryGroupCategoriesField()
}

type categoryWithPrismaCategoryGroupCategoriesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryGroupCategoriesSetParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryGroupCategoriesSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryGroupCategoriesSetParam) categoryModel() {}

func (p categoryWithPrismaCategoryGroupCategoriesSetParam) categoryGroupCategoriesField() {}

type CategoryWithPrismaCategoryGroupCategoriesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryModel()
	categoryGroupCategoriesField()
}

type categoryWithPrismaCategoryGroupCategoriesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryGroupCategoriesEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryGroupCategoriesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryGroupCategoriesEqualsParam) categoryModel() {}

func (p categoryWithPrismaCategoryGroupCategoriesEqualsParam) categoryGroupCategoriesField() {}

func (categoryWithPrismaCategoryGroupCategoriesSetParam) settable()  {}
func (categoryWithPrismaCategoryGroupCategoriesEqualsParam) equals() {}

type categoryWithPrismaCategoryGroupCategoriesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryWithPrismaCategoryGroupCategoriesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryWithPrismaCategoryGroupCategoriesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryWithPrismaCategoryGroupCategoriesEqualsUniqueParam) categoryModel()                {}
func (p categoryWithPrismaCategoryGroupCategoriesEqualsUniqueParam) categoryGroupCategoriesField() {}

func (categoryWithPrismaCategoryGroupCategoriesEqualsUniqueParam) unique() {}
func (categoryWithPrismaCategoryGroupCategoriesEqualsUniqueParam) equals() {}

type categoryGroupActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var categoryGroupOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "level"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type CategoryGroupRelationWith interface {
	getQuery() builder.Query
	with()
	categoryGroupRelation()
}

type CategoryGroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
}

type categoryGroupDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupDefaultParam) field() builder.Field {
	return p.data
}

func (p categoryGroupDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupDefaultParam) categoryGroupModel() {}

type CategoryGroupOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
}

type categoryGroupOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupOrderByParam) field() builder.Field {
	return p.data
}

func (p categoryGroupOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupOrderByParam) categoryGroupModel() {}

type CategoryGroupCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	isCursor()
}

type categoryGroupCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCursorParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCursorParam) isCursor() {}

func (p categoryGroupCursorParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCursorParam) categoryGroupModel() {}

type CategoryGroupParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	categoryGroupModel()
}

type categoryGroupParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupParamUnique) categoryGroupModel() {}

func (categoryGroupParamUnique) unique() {}

func (p categoryGroupParamUnique) field() builder.Field {
	return p.data
}

func (p categoryGroupParamUnique) getQuery() builder.Query {
	return p.query
}

type CategoryGroupEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupModel()
}

type categoryGroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupEqualsParam) categoryGroupModel() {}

func (categoryGroupEqualsParam) equals() {}

func (p categoryGroupEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupEqualsParam) getQuery() builder.Query {
	return p.query
}

type CategoryGroupEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	categoryGroupModel()
}

type categoryGroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupEqualsUniqueParam) categoryGroupModel() {}

func (categoryGroupEqualsUniqueParam) unique() {}
func (categoryGroupEqualsUniqueParam) equals() {}

func (p categoryGroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type CategoryGroupSetParam interface {
	field() builder.Field
	settable()
	categoryGroupModel()
}

type categoryGroupSetParam struct {
	data builder.Field
}

func (categoryGroupSetParam) settable() {}

func (p categoryGroupSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupSetParam) categoryGroupModel() {}

type CategoryGroupWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupModel()
	idField()
}

type CategoryGroupWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	idField()
}

type categoryGroupWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaIDSetParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaIDSetParam) idField() {}

type CategoryGroupWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	idField()
}

type categoryGroupWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaIDEqualsParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaIDEqualsParam) idField() {}

func (categoryGroupWithPrismaIDSetParam) settable()  {}
func (categoryGroupWithPrismaIDEqualsParam) equals() {}

type categoryGroupWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaIDEqualsUniqueParam) categoryGroupModel() {}
func (p categoryGroupWithPrismaIDEqualsUniqueParam) idField()            {}

func (categoryGroupWithPrismaIDEqualsUniqueParam) unique() {}
func (categoryGroupWithPrismaIDEqualsUniqueParam) equals() {}

type CategoryGroupWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupModel()
	nameField()
}

type CategoryGroupWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	nameField()
}

type categoryGroupWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaNameSetParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaNameSetParam) nameField() {}

type CategoryGroupWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	nameField()
}

type categoryGroupWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaNameEqualsParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaNameEqualsParam) nameField() {}

func (categoryGroupWithPrismaNameSetParam) settable()  {}
func (categoryGroupWithPrismaNameEqualsParam) equals() {}

type categoryGroupWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaNameEqualsUniqueParam) categoryGroupModel() {}
func (p categoryGroupWithPrismaNameEqualsUniqueParam) nameField()          {}

func (categoryGroupWithPrismaNameEqualsUniqueParam) unique() {}
func (categoryGroupWithPrismaNameEqualsUniqueParam) equals() {}

type CategoryGroupWithPrismaLevelEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupModel()
	levelField()
}

type CategoryGroupWithPrismaLevelSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	levelField()
}

type categoryGroupWithPrismaLevelSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaLevelSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaLevelSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaLevelSetParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaLevelSetParam) levelField() {}

type CategoryGroupWithPrismaLevelWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	levelField()
}

type categoryGroupWithPrismaLevelEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaLevelEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaLevelEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaLevelEqualsParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaLevelEqualsParam) levelField() {}

func (categoryGroupWithPrismaLevelSetParam) settable()  {}
func (categoryGroupWithPrismaLevelEqualsParam) equals() {}

type categoryGroupWithPrismaLevelEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaLevelEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaLevelEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaLevelEqualsUniqueParam) categoryGroupModel() {}
func (p categoryGroupWithPrismaLevelEqualsUniqueParam) levelField()         {}

func (categoryGroupWithPrismaLevelEqualsUniqueParam) unique() {}
func (categoryGroupWithPrismaLevelEqualsUniqueParam) equals() {}

type CategoryGroupWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupModel()
	createdAtField()
}

type CategoryGroupWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	createdAtField()
}

type categoryGroupWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaCreatedAtSetParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaCreatedAtSetParam) createdAtField() {}

type CategoryGroupWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	createdAtField()
}

type categoryGroupWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaCreatedAtEqualsParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (categoryGroupWithPrismaCreatedAtSetParam) settable()  {}
func (categoryGroupWithPrismaCreatedAtEqualsParam) equals() {}

type categoryGroupWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaCreatedAtEqualsUniqueParam) categoryGroupModel() {}
func (p categoryGroupWithPrismaCreatedAtEqualsUniqueParam) createdAtField()     {}

func (categoryGroupWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (categoryGroupWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type CategoryGroupWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupModel()
	updatedAtField()
}

type CategoryGroupWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	updatedAtField()
}

type categoryGroupWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaUpdatedAtSetParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaUpdatedAtSetParam) updatedAtField() {}

type CategoryGroupWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	updatedAtField()
}

type categoryGroupWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaUpdatedAtEqualsParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (categoryGroupWithPrismaUpdatedAtSetParam) settable()  {}
func (categoryGroupWithPrismaUpdatedAtEqualsParam) equals() {}

type categoryGroupWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaUpdatedAtEqualsUniqueParam) categoryGroupModel() {}
func (p categoryGroupWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()     {}

func (categoryGroupWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (categoryGroupWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type CategoryGroupWithPrismaCategoryGroupCategoriesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupModel()
	categoryGroupCategoriesField()
}

type CategoryGroupWithPrismaCategoryGroupCategoriesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	categoryGroupCategoriesField()
}

type categoryGroupWithPrismaCategoryGroupCategoriesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesSetParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaCategoryGroupCategoriesSetParam) categoryGroupCategoriesField() {}

type CategoryGroupWithPrismaCategoryGroupCategoriesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupModel()
	categoryGroupCategoriesField()
}

type categoryGroupWithPrismaCategoryGroupCategoriesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsParam) categoryGroupModel() {}

func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsParam) categoryGroupCategoriesField() {}

func (categoryGroupWithPrismaCategoryGroupCategoriesSetParam) settable()  {}
func (categoryGroupWithPrismaCategoryGroupCategoriesEqualsParam) equals() {}

type categoryGroupWithPrismaCategoryGroupCategoriesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsUniqueParam) categoryGroupModel() {}
func (p categoryGroupWithPrismaCategoryGroupCategoriesEqualsUniqueParam) categoryGroupCategoriesField() {
}

func (categoryGroupWithPrismaCategoryGroupCategoriesEqualsUniqueParam) unique() {}
func (categoryGroupWithPrismaCategoryGroupCategoriesEqualsUniqueParam) equals() {}

type categoryGroupCategoryActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var categoryGroupCategoryOutput = []builder.Output{
	{Name: "categoryId1"},
	{Name: "categoryId2"},
	{Name: "categoryId3"},
	{Name: "categoryId4"},
	{Name: "categoryId5"},
	{Name: "categoryGroupId"},
}

type CategoryGroupCategoryRelationWith interface {
	getQuery() builder.Query
	with()
	categoryGroupCategoryRelation()
}

type CategoryGroupCategoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
}

type categoryGroupCategoryDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryDefaultParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryDefaultParam) categoryGroupCategoryModel() {}

type CategoryGroupCategoryOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
}

type categoryGroupCategoryOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryOrderByParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryOrderByParam) categoryGroupCategoryModel() {}

type CategoryGroupCategoryCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	isCursor()
}

type categoryGroupCategoryCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryCursorParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryCursorParam) isCursor() {}

func (p categoryGroupCategoryCursorParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryCursorParam) categoryGroupCategoryModel() {}

type CategoryGroupCategoryParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	categoryGroupCategoryModel()
}

type categoryGroupCategoryParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryParamUnique) categoryGroupCategoryModel() {}

func (categoryGroupCategoryParamUnique) unique() {}

func (p categoryGroupCategoryParamUnique) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryParamUnique) getQuery() builder.Query {
	return p.query
}

type CategoryGroupCategoryEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
}

type categoryGroupCategoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryEqualsParam) categoryGroupCategoryModel() {}

func (categoryGroupCategoryEqualsParam) equals() {}

func (p categoryGroupCategoryEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryEqualsParam) getQuery() builder.Query {
	return p.query
}

type CategoryGroupCategoryEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	categoryGroupCategoryModel()
}

type categoryGroupCategoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryEqualsUniqueParam) categoryGroupCategoryModel() {}

func (categoryGroupCategoryEqualsUniqueParam) unique() {}
func (categoryGroupCategoryEqualsUniqueParam) equals() {}

func (p categoryGroupCategoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type CategoryGroupCategorySetParam interface {
	field() builder.Field
	settable()
	categoryGroupCategoryModel()
}

type categoryGroupCategorySetParam struct {
	data builder.Field
}

func (categoryGroupCategorySetParam) settable() {}

func (p categoryGroupCategorySetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategorySetParam) categoryGroupCategoryModel() {}

type CategoryGroupCategoryWithPrismaCategoryID1EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryID1Field()
}

type CategoryGroupCategoryWithPrismaCategoryID1SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID1Field()
}

type categoryGroupCategoryWithPrismaCategoryID1SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID1SetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID1SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID1SetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID1SetParam) categoryID1Field() {}

type CategoryGroupCategoryWithPrismaCategoryID1WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID1Field()
}

type categoryGroupCategoryWithPrismaCategoryID1EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID1EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID1EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID1EqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID1EqualsParam) categoryID1Field() {}

func (categoryGroupCategoryWithPrismaCategoryID1SetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryID1EqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryID1EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID1EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID1EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID1EqualsUniqueParam) categoryGroupCategoryModel() {}
func (p categoryGroupCategoryWithPrismaCategoryID1EqualsUniqueParam) categoryID1Field()           {}

func (categoryGroupCategoryWithPrismaCategoryID1EqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryID1EqualsUniqueParam) equals() {}

type CategoryGroupCategoryWithPrismaCategoryID2EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryID2Field()
}

type CategoryGroupCategoryWithPrismaCategoryID2SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID2Field()
}

type categoryGroupCategoryWithPrismaCategoryID2SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID2SetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID2SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID2SetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID2SetParam) categoryID2Field() {}

type CategoryGroupCategoryWithPrismaCategoryID2WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID2Field()
}

type categoryGroupCategoryWithPrismaCategoryID2EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID2EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID2EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID2EqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID2EqualsParam) categoryID2Field() {}

func (categoryGroupCategoryWithPrismaCategoryID2SetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryID2EqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryID2EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID2EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID2EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID2EqualsUniqueParam) categoryGroupCategoryModel() {}
func (p categoryGroupCategoryWithPrismaCategoryID2EqualsUniqueParam) categoryID2Field()           {}

func (categoryGroupCategoryWithPrismaCategoryID2EqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryID2EqualsUniqueParam) equals() {}

type CategoryGroupCategoryWithPrismaCategoryID3EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryID3Field()
}

type CategoryGroupCategoryWithPrismaCategoryID3SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID3Field()
}

type categoryGroupCategoryWithPrismaCategoryID3SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID3SetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID3SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID3SetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID3SetParam) categoryID3Field() {}

type CategoryGroupCategoryWithPrismaCategoryID3WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID3Field()
}

type categoryGroupCategoryWithPrismaCategoryID3EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID3EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID3EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID3EqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID3EqualsParam) categoryID3Field() {}

func (categoryGroupCategoryWithPrismaCategoryID3SetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryID3EqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryID3EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID3EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID3EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID3EqualsUniqueParam) categoryGroupCategoryModel() {}
func (p categoryGroupCategoryWithPrismaCategoryID3EqualsUniqueParam) categoryID3Field()           {}

func (categoryGroupCategoryWithPrismaCategoryID3EqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryID3EqualsUniqueParam) equals() {}

type CategoryGroupCategoryWithPrismaCategoryID4EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryID4Field()
}

type CategoryGroupCategoryWithPrismaCategoryID4SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID4Field()
}

type categoryGroupCategoryWithPrismaCategoryID4SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID4SetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID4SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID4SetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID4SetParam) categoryID4Field() {}

type CategoryGroupCategoryWithPrismaCategoryID4WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID4Field()
}

type categoryGroupCategoryWithPrismaCategoryID4EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID4EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID4EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID4EqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID4EqualsParam) categoryID4Field() {}

func (categoryGroupCategoryWithPrismaCategoryID4SetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryID4EqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryID4EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID4EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID4EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID4EqualsUniqueParam) categoryGroupCategoryModel() {}
func (p categoryGroupCategoryWithPrismaCategoryID4EqualsUniqueParam) categoryID4Field()           {}

func (categoryGroupCategoryWithPrismaCategoryID4EqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryID4EqualsUniqueParam) equals() {}

type CategoryGroupCategoryWithPrismaCategoryID5EqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryID5Field()
}

type CategoryGroupCategoryWithPrismaCategoryID5SetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID5Field()
}

type categoryGroupCategoryWithPrismaCategoryID5SetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID5SetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID5SetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID5SetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID5SetParam) categoryID5Field() {}

type CategoryGroupCategoryWithPrismaCategoryID5WhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryID5Field()
}

type categoryGroupCategoryWithPrismaCategoryID5EqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID5EqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID5EqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID5EqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryID5EqualsParam) categoryID5Field() {}

func (categoryGroupCategoryWithPrismaCategoryID5SetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryID5EqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryID5EqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryID5EqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryID5EqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryID5EqualsUniqueParam) categoryGroupCategoryModel() {}
func (p categoryGroupCategoryWithPrismaCategoryID5EqualsUniqueParam) categoryID5Field()           {}

func (categoryGroupCategoryWithPrismaCategoryID5EqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryID5EqualsUniqueParam) equals() {}

type CategoryGroupCategoryWithPrismaCategoryGroupIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryGroupIDField()
}

type CategoryGroupCategoryWithPrismaCategoryGroupIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryGroupIDField()
}

type categoryGroupCategoryWithPrismaCategoryGroupIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDSetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDSetParam) categoryGroupIDField() {}

type CategoryGroupCategoryWithPrismaCategoryGroupIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryGroupIDField()
}

type categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam) categoryGroupIDField() {}

func (categoryGroupCategoryWithPrismaCategoryGroupIDSetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryGroupIDEqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryGroupIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsUniqueParam) categoryGroupCategoryModel() {
}
func (p categoryGroupCategoryWithPrismaCategoryGroupIDEqualsUniqueParam) categoryGroupIDField() {}

func (categoryGroupCategoryWithPrismaCategoryGroupIDEqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryGroupIDEqualsUniqueParam) equals() {}

type CategoryGroupCategoryWithPrismaCategoryEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryField()
}

type CategoryGroupCategoryWithPrismaCategorySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryField()
}

type categoryGroupCategoryWithPrismaCategorySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategorySetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategorySetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategorySetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategorySetParam) categoryField() {}

type CategoryGroupCategoryWithPrismaCategoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryField()
}

type categoryGroupCategoryWithPrismaCategoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryEqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryEqualsParam) categoryField() {}

func (categoryGroupCategoryWithPrismaCategorySetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryEqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryEqualsUniqueParam) categoryGroupCategoryModel() {}
func (p categoryGroupCategoryWithPrismaCategoryEqualsUniqueParam) categoryField()              {}

func (categoryGroupCategoryWithPrismaCategoryEqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryEqualsUniqueParam) equals() {}

type CategoryGroupCategoryWithPrismaCategoryGroupEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	categoryGroupCategoryModel()
	categoryGroupField()
}

type CategoryGroupCategoryWithPrismaCategoryGroupSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryGroupField()
}

type categoryGroupCategoryWithPrismaCategoryGroupSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupSetParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryGroupSetParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupSetParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryGroupSetParam) categoryGroupField() {}

type CategoryGroupCategoryWithPrismaCategoryGroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	categoryGroupCategoryModel()
	categoryGroupField()
}

type categoryGroupCategoryWithPrismaCategoryGroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsParam) categoryGroupCategoryModel() {}

func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsParam) categoryGroupField() {}

func (categoryGroupCategoryWithPrismaCategoryGroupSetParam) settable()  {}
func (categoryGroupCategoryWithPrismaCategoryGroupEqualsParam) equals() {}

type categoryGroupCategoryWithPrismaCategoryGroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsUniqueParam) categoryGroupCategoryModel() {}
func (p categoryGroupCategoryWithPrismaCategoryGroupEqualsUniqueParam) categoryGroupField()         {}

func (categoryGroupCategoryWithPrismaCategoryGroupEqualsUniqueParam) unique() {}
func (categoryGroupCategoryWithPrismaCategoryGroupEqualsUniqueParam) equals() {}

type storeActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var storeOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "salesFloorArea"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type StoreRelationWith interface {
	getQuery() builder.Query
	with()
	storeRelation()
}

type StoreWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
}

type storeDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeDefaultParam) field() builder.Field {
	return p.data
}

func (p storeDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p storeDefaultParam) storeModel() {}

type StoreOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
}

type storeOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeOrderByParam) field() builder.Field {
	return p.data
}

func (p storeOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p storeOrderByParam) storeModel() {}

type StoreCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	isCursor()
}

type storeCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeCursorParam) field() builder.Field {
	return p.data
}

func (p storeCursorParam) isCursor() {}

func (p storeCursorParam) getQuery() builder.Query {
	return p.query
}

func (p storeCursorParam) storeModel() {}

type StoreParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	storeModel()
}

type storeParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p storeParamUnique) storeModel() {}

func (storeParamUnique) unique() {}

func (p storeParamUnique) field() builder.Field {
	return p.data
}

func (p storeParamUnique) getQuery() builder.Query {
	return p.query
}

type StoreEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeModel()
}

type storeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeEqualsParam) storeModel() {}

func (storeEqualsParam) equals() {}

func (p storeEqualsParam) field() builder.Field {
	return p.data
}

func (p storeEqualsParam) getQuery() builder.Query {
	return p.query
}

type StoreEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	storeModel()
}

type storeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeEqualsUniqueParam) storeModel() {}

func (storeEqualsUniqueParam) unique() {}
func (storeEqualsUniqueParam) equals() {}

func (p storeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type StoreSetParam interface {
	field() builder.Field
	settable()
	storeModel()
}

type storeSetParam struct {
	data builder.Field
}

func (storeSetParam) settable() {}

func (p storeSetParam) field() builder.Field {
	return p.data
}

func (p storeSetParam) storeModel() {}

type StoreWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeModel()
	idField()
}

type StoreWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	idField()
}

type storeWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaIDSetParam) storeModel() {}

func (p storeWithPrismaIDSetParam) idField() {}

type StoreWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	idField()
}

type storeWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaIDEqualsParam) storeModel() {}

func (p storeWithPrismaIDEqualsParam) idField() {}

func (storeWithPrismaIDSetParam) settable()  {}
func (storeWithPrismaIDEqualsParam) equals() {}

type storeWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaIDEqualsUniqueParam) storeModel() {}
func (p storeWithPrismaIDEqualsUniqueParam) idField()    {}

func (storeWithPrismaIDEqualsUniqueParam) unique() {}
func (storeWithPrismaIDEqualsUniqueParam) equals() {}

type StoreWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeModel()
	nameField()
}

type StoreWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	nameField()
}

type storeWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaNameSetParam) storeModel() {}

func (p storeWithPrismaNameSetParam) nameField() {}

type StoreWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	nameField()
}

type storeWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaNameEqualsParam) storeModel() {}

func (p storeWithPrismaNameEqualsParam) nameField() {}

func (storeWithPrismaNameSetParam) settable()  {}
func (storeWithPrismaNameEqualsParam) equals() {}

type storeWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaNameEqualsUniqueParam) storeModel() {}
func (p storeWithPrismaNameEqualsUniqueParam) nameField()  {}

func (storeWithPrismaNameEqualsUniqueParam) unique() {}
func (storeWithPrismaNameEqualsUniqueParam) equals() {}

type StoreWithPrismaSalesFloorAreaEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeModel()
	salesFloorAreaField()
}

type StoreWithPrismaSalesFloorAreaSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	salesFloorAreaField()
}

type storeWithPrismaSalesFloorAreaSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaSalesFloorAreaSetParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaSalesFloorAreaSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaSalesFloorAreaSetParam) storeModel() {}

func (p storeWithPrismaSalesFloorAreaSetParam) salesFloorAreaField() {}

type StoreWithPrismaSalesFloorAreaWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	salesFloorAreaField()
}

type storeWithPrismaSalesFloorAreaEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaSalesFloorAreaEqualsParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaSalesFloorAreaEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaSalesFloorAreaEqualsParam) storeModel() {}

func (p storeWithPrismaSalesFloorAreaEqualsParam) salesFloorAreaField() {}

func (storeWithPrismaSalesFloorAreaSetParam) settable()  {}
func (storeWithPrismaSalesFloorAreaEqualsParam) equals() {}

type storeWithPrismaSalesFloorAreaEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaSalesFloorAreaEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaSalesFloorAreaEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaSalesFloorAreaEqualsUniqueParam) storeModel()          {}
func (p storeWithPrismaSalesFloorAreaEqualsUniqueParam) salesFloorAreaField() {}

func (storeWithPrismaSalesFloorAreaEqualsUniqueParam) unique() {}
func (storeWithPrismaSalesFloorAreaEqualsUniqueParam) equals() {}

type StoreWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeModel()
	createdAtField()
}

type StoreWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	createdAtField()
}

type storeWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaCreatedAtSetParam) storeModel() {}

func (p storeWithPrismaCreatedAtSetParam) createdAtField() {}

type StoreWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	createdAtField()
}

type storeWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaCreatedAtEqualsParam) storeModel() {}

func (p storeWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (storeWithPrismaCreatedAtSetParam) settable()  {}
func (storeWithPrismaCreatedAtEqualsParam) equals() {}

type storeWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaCreatedAtEqualsUniqueParam) storeModel()     {}
func (p storeWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (storeWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (storeWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type StoreWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeModel()
	updatedAtField()
}

type StoreWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	updatedAtField()
}

type storeWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaUpdatedAtSetParam) storeModel() {}

func (p storeWithPrismaUpdatedAtSetParam) updatedAtField() {}

type StoreWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	updatedAtField()
}

type storeWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaUpdatedAtEqualsParam) storeModel() {}

func (p storeWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (storeWithPrismaUpdatedAtSetParam) settable()  {}
func (storeWithPrismaUpdatedAtEqualsParam) equals() {}

type storeWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaUpdatedAtEqualsUniqueParam) storeModel()     {}
func (p storeWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (storeWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (storeWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type StoreWithPrismaUserStoreEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeModel()
	userStoreField()
}

type StoreWithPrismaUserStoreSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	userStoreField()
}

type storeWithPrismaUserStoreSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaUserStoreSetParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaUserStoreSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaUserStoreSetParam) storeModel() {}

func (p storeWithPrismaUserStoreSetParam) userStoreField() {}

type StoreWithPrismaUserStoreWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeModel()
	userStoreField()
}

type storeWithPrismaUserStoreEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaUserStoreEqualsParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaUserStoreEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaUserStoreEqualsParam) storeModel() {}

func (p storeWithPrismaUserStoreEqualsParam) userStoreField() {}

func (storeWithPrismaUserStoreSetParam) settable()  {}
func (storeWithPrismaUserStoreEqualsParam) equals() {}

type storeWithPrismaUserStoreEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeWithPrismaUserStoreEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeWithPrismaUserStoreEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeWithPrismaUserStoreEqualsUniqueParam) storeModel()     {}
func (p storeWithPrismaUserStoreEqualsUniqueParam) userStoreField() {}

func (storeWithPrismaUserStoreEqualsUniqueParam) unique() {}
func (storeWithPrismaUserStoreEqualsUniqueParam) equals() {}

type userStoreActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userStoreOutput = []builder.Output{
	{Name: "email"},
	{Name: "name"},
	{Name: "storeId"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type UserStoreRelationWith interface {
	getQuery() builder.Query
	with()
	userStoreRelation()
}

type UserStoreWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
}

type userStoreDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreDefaultParam) field() builder.Field {
	return p.data
}

func (p userStoreDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreDefaultParam) userStoreModel() {}

type UserStoreOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
}

type userStoreOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreOrderByParam) field() builder.Field {
	return p.data
}

func (p userStoreOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreOrderByParam) userStoreModel() {}

type UserStoreCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	isCursor()
}

type userStoreCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreCursorParam) field() builder.Field {
	return p.data
}

func (p userStoreCursorParam) isCursor() {}

func (p userStoreCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreCursorParam) userStoreModel() {}

type UserStoreParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userStoreModel()
}

type userStoreParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreParamUnique) userStoreModel() {}

func (userStoreParamUnique) unique() {}

func (p userStoreParamUnique) field() builder.Field {
	return p.data
}

func (p userStoreParamUnique) getQuery() builder.Query {
	return p.query
}

type UserStoreEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userStoreModel()
}

type userStoreEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreEqualsParam) userStoreModel() {}

func (userStoreEqualsParam) equals() {}

func (p userStoreEqualsParam) field() builder.Field {
	return p.data
}

func (p userStoreEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserStoreEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userStoreModel()
}

type userStoreEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreEqualsUniqueParam) userStoreModel() {}

func (userStoreEqualsUniqueParam) unique() {}
func (userStoreEqualsUniqueParam) equals() {}

func (p userStoreEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userStoreEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserStoreSetParam interface {
	field() builder.Field
	settable()
	userStoreModel()
}

type userStoreSetParam struct {
	data builder.Field
}

func (userStoreSetParam) settable() {}

func (p userStoreSetParam) field() builder.Field {
	return p.data
}

func (p userStoreSetParam) userStoreModel() {}

type UserStoreWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userStoreModel()
	emailField()
}

type UserStoreWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	emailField()
}

type userStoreWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaEmailSetParam) userStoreModel() {}

func (p userStoreWithPrismaEmailSetParam) emailField() {}

type UserStoreWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	emailField()
}

type userStoreWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaEmailEqualsParam) userStoreModel() {}

func (p userStoreWithPrismaEmailEqualsParam) emailField() {}

func (userStoreWithPrismaEmailSetParam) settable()  {}
func (userStoreWithPrismaEmailEqualsParam) equals() {}

type userStoreWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaEmailEqualsUniqueParam) userStoreModel() {}
func (p userStoreWithPrismaEmailEqualsUniqueParam) emailField()     {}

func (userStoreWithPrismaEmailEqualsUniqueParam) unique() {}
func (userStoreWithPrismaEmailEqualsUniqueParam) equals() {}

type UserStoreWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userStoreModel()
	nameField()
}

type UserStoreWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	nameField()
}

type userStoreWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaNameSetParam) userStoreModel() {}

func (p userStoreWithPrismaNameSetParam) nameField() {}

type UserStoreWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	nameField()
}

type userStoreWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaNameEqualsParam) userStoreModel() {}

func (p userStoreWithPrismaNameEqualsParam) nameField() {}

func (userStoreWithPrismaNameSetParam) settable()  {}
func (userStoreWithPrismaNameEqualsParam) equals() {}

type userStoreWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaNameEqualsUniqueParam) userStoreModel() {}
func (p userStoreWithPrismaNameEqualsUniqueParam) nameField()      {}

func (userStoreWithPrismaNameEqualsUniqueParam) unique() {}
func (userStoreWithPrismaNameEqualsUniqueParam) equals() {}

type UserStoreWithPrismaStoreIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userStoreModel()
	storeIDField()
}

type UserStoreWithPrismaStoreIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	storeIDField()
}

type userStoreWithPrismaStoreIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaStoreIDSetParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaStoreIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaStoreIDSetParam) userStoreModel() {}

func (p userStoreWithPrismaStoreIDSetParam) storeIDField() {}

type UserStoreWithPrismaStoreIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	storeIDField()
}

type userStoreWithPrismaStoreIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaStoreIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaStoreIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaStoreIDEqualsParam) userStoreModel() {}

func (p userStoreWithPrismaStoreIDEqualsParam) storeIDField() {}

func (userStoreWithPrismaStoreIDSetParam) settable()  {}
func (userStoreWithPrismaStoreIDEqualsParam) equals() {}

type userStoreWithPrismaStoreIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaStoreIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaStoreIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaStoreIDEqualsUniqueParam) userStoreModel() {}
func (p userStoreWithPrismaStoreIDEqualsUniqueParam) storeIDField()   {}

func (userStoreWithPrismaStoreIDEqualsUniqueParam) unique() {}
func (userStoreWithPrismaStoreIDEqualsUniqueParam) equals() {}

type UserStoreWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userStoreModel()
	createdAtField()
}

type UserStoreWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	createdAtField()
}

type userStoreWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaCreatedAtSetParam) userStoreModel() {}

func (p userStoreWithPrismaCreatedAtSetParam) createdAtField() {}

type UserStoreWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	createdAtField()
}

type userStoreWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaCreatedAtEqualsParam) userStoreModel() {}

func (p userStoreWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userStoreWithPrismaCreatedAtSetParam) settable()  {}
func (userStoreWithPrismaCreatedAtEqualsParam) equals() {}

type userStoreWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaCreatedAtEqualsUniqueParam) userStoreModel() {}
func (p userStoreWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userStoreWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userStoreWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserStoreWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userStoreModel()
	updatedAtField()
}

type UserStoreWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	updatedAtField()
}

type userStoreWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaUpdatedAtSetParam) userStoreModel() {}

func (p userStoreWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserStoreWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	updatedAtField()
}

type userStoreWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaUpdatedAtEqualsParam) userStoreModel() {}

func (p userStoreWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userStoreWithPrismaUpdatedAtSetParam) settable()  {}
func (userStoreWithPrismaUpdatedAtEqualsParam) equals() {}

type userStoreWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaUpdatedAtEqualsUniqueParam) userStoreModel() {}
func (p userStoreWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userStoreWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userStoreWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UserStoreWithPrismaStoreEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userStoreModel()
	storeField()
}

type UserStoreWithPrismaStoreSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	storeField()
}

type userStoreWithPrismaStoreSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaStoreSetParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaStoreSetParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaStoreSetParam) userStoreModel() {}

func (p userStoreWithPrismaStoreSetParam) storeField() {}

type UserStoreWithPrismaStoreWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userStoreModel()
	storeField()
}

type userStoreWithPrismaStoreEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaStoreEqualsParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaStoreEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaStoreEqualsParam) userStoreModel() {}

func (p userStoreWithPrismaStoreEqualsParam) storeField() {}

func (userStoreWithPrismaStoreSetParam) settable()  {}
func (userStoreWithPrismaStoreEqualsParam) equals() {}

type userStoreWithPrismaStoreEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userStoreWithPrismaStoreEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userStoreWithPrismaStoreEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userStoreWithPrismaStoreEqualsUniqueParam) userStoreModel() {}
func (p userStoreWithPrismaStoreEqualsUniqueParam) storeField()     {}

func (userStoreWithPrismaStoreEqualsUniqueParam) unique() {}
func (userStoreWithPrismaStoreEqualsUniqueParam) equals() {}

type holidayActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var holidayOutput = []builder.Output{
	{Name: "date"},
	{Name: "name"},
}

type HolidayRelationWith interface {
	getQuery() builder.Query
	with()
	holidayRelation()
}

type HolidayWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	holidayModel()
}

type holidayDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayDefaultParam) field() builder.Field {
	return p.data
}

func (p holidayDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p holidayDefaultParam) holidayModel() {}

type HolidayOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	holidayModel()
}

type holidayOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayOrderByParam) field() builder.Field {
	return p.data
}

func (p holidayOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p holidayOrderByParam) holidayModel() {}

type HolidayCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	holidayModel()
	isCursor()
}

type holidayCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayCursorParam) field() builder.Field {
	return p.data
}

func (p holidayCursorParam) isCursor() {}

func (p holidayCursorParam) getQuery() builder.Query {
	return p.query
}

func (p holidayCursorParam) holidayModel() {}

type HolidayParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	holidayModel()
}

type holidayParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p holidayParamUnique) holidayModel() {}

func (holidayParamUnique) unique() {}

func (p holidayParamUnique) field() builder.Field {
	return p.data
}

func (p holidayParamUnique) getQuery() builder.Query {
	return p.query
}

type HolidayEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	holidayModel()
}

type holidayEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayEqualsParam) holidayModel() {}

func (holidayEqualsParam) equals() {}

func (p holidayEqualsParam) field() builder.Field {
	return p.data
}

func (p holidayEqualsParam) getQuery() builder.Query {
	return p.query
}

type HolidayEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	holidayModel()
}

type holidayEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayEqualsUniqueParam) holidayModel() {}

func (holidayEqualsUniqueParam) unique() {}
func (holidayEqualsUniqueParam) equals() {}

func (p holidayEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p holidayEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type HolidaySetParam interface {
	field() builder.Field
	settable()
	holidayModel()
}

type holidaySetParam struct {
	data builder.Field
}

func (holidaySetParam) settable() {}

func (p holidaySetParam) field() builder.Field {
	return p.data
}

func (p holidaySetParam) holidayModel() {}

type HolidayWithPrismaDateEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	holidayModel()
	dateField()
}

type HolidayWithPrismaDateSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	holidayModel()
	dateField()
}

type holidayWithPrismaDateSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayWithPrismaDateSetParam) field() builder.Field {
	return p.data
}

func (p holidayWithPrismaDateSetParam) getQuery() builder.Query {
	return p.query
}

func (p holidayWithPrismaDateSetParam) holidayModel() {}

func (p holidayWithPrismaDateSetParam) dateField() {}

type HolidayWithPrismaDateWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	holidayModel()
	dateField()
}

type holidayWithPrismaDateEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayWithPrismaDateEqualsParam) field() builder.Field {
	return p.data
}

func (p holidayWithPrismaDateEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p holidayWithPrismaDateEqualsParam) holidayModel() {}

func (p holidayWithPrismaDateEqualsParam) dateField() {}

func (holidayWithPrismaDateSetParam) settable()  {}
func (holidayWithPrismaDateEqualsParam) equals() {}

type holidayWithPrismaDateEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayWithPrismaDateEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p holidayWithPrismaDateEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p holidayWithPrismaDateEqualsUniqueParam) holidayModel() {}
func (p holidayWithPrismaDateEqualsUniqueParam) dateField()    {}

func (holidayWithPrismaDateEqualsUniqueParam) unique() {}
func (holidayWithPrismaDateEqualsUniqueParam) equals() {}

type HolidayWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	holidayModel()
	nameField()
}

type HolidayWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	holidayModel()
	nameField()
}

type holidayWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p holidayWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p holidayWithPrismaNameSetParam) holidayModel() {}

func (p holidayWithPrismaNameSetParam) nameField() {}

type HolidayWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	holidayModel()
	nameField()
}

type holidayWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p holidayWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p holidayWithPrismaNameEqualsParam) holidayModel() {}

func (p holidayWithPrismaNameEqualsParam) nameField() {}

func (holidayWithPrismaNameSetParam) settable()  {}
func (holidayWithPrismaNameEqualsParam) equals() {}

type holidayWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p holidayWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p holidayWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p holidayWithPrismaNameEqualsUniqueParam) holidayModel() {}
func (p holidayWithPrismaNameEqualsUniqueParam) nameField()    {}

func (holidayWithPrismaNameEqualsUniqueParam) unique() {}
func (holidayWithPrismaNameEqualsUniqueParam) equals() {}

type storeStatusActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var storeStatusOutput = []builder.Output{
	{Name: "storeId"},
	{Name: "date"},
	{Name: "isOpen"},
	{Name: "isExisting"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type StoreStatusRelationWith interface {
	getQuery() builder.Query
	with()
	storeStatusRelation()
}

type StoreStatusWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
}

type storeStatusDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusDefaultParam) field() builder.Field {
	return p.data
}

func (p storeStatusDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusDefaultParam) storeStatusModel() {}

type StoreStatusOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
}

type storeStatusOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusOrderByParam) field() builder.Field {
	return p.data
}

func (p storeStatusOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusOrderByParam) storeStatusModel() {}

type StoreStatusCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	isCursor()
}

type storeStatusCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusCursorParam) field() builder.Field {
	return p.data
}

func (p storeStatusCursorParam) isCursor() {}

func (p storeStatusCursorParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusCursorParam) storeStatusModel() {}

type StoreStatusParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	storeStatusModel()
}

type storeStatusParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusParamUnique) storeStatusModel() {}

func (storeStatusParamUnique) unique() {}

func (p storeStatusParamUnique) field() builder.Field {
	return p.data
}

func (p storeStatusParamUnique) getQuery() builder.Query {
	return p.query
}

type StoreStatusEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeStatusModel()
}

type storeStatusEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusEqualsParam) storeStatusModel() {}

func (storeStatusEqualsParam) equals() {}

func (p storeStatusEqualsParam) field() builder.Field {
	return p.data
}

func (p storeStatusEqualsParam) getQuery() builder.Query {
	return p.query
}

type StoreStatusEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	storeStatusModel()
}

type storeStatusEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusEqualsUniqueParam) storeStatusModel() {}

func (storeStatusEqualsUniqueParam) unique() {}
func (storeStatusEqualsUniqueParam) equals() {}

func (p storeStatusEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeStatusEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type StoreStatusSetParam interface {
	field() builder.Field
	settable()
	storeStatusModel()
}

type storeStatusSetParam struct {
	data builder.Field
}

func (storeStatusSetParam) settable() {}

func (p storeStatusSetParam) field() builder.Field {
	return p.data
}

func (p storeStatusSetParam) storeStatusModel() {}

type StoreStatusWithPrismaStoreIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeStatusModel()
	storeIDField()
}

type StoreStatusWithPrismaStoreIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	storeIDField()
}

type storeStatusWithPrismaStoreIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaStoreIDSetParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaStoreIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaStoreIDSetParam) storeStatusModel() {}

func (p storeStatusWithPrismaStoreIDSetParam) storeIDField() {}

type StoreStatusWithPrismaStoreIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	storeIDField()
}

type storeStatusWithPrismaStoreIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaStoreIDEqualsParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaStoreIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaStoreIDEqualsParam) storeStatusModel() {}

func (p storeStatusWithPrismaStoreIDEqualsParam) storeIDField() {}

func (storeStatusWithPrismaStoreIDSetParam) settable()  {}
func (storeStatusWithPrismaStoreIDEqualsParam) equals() {}

type storeStatusWithPrismaStoreIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaStoreIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaStoreIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaStoreIDEqualsUniqueParam) storeStatusModel() {}
func (p storeStatusWithPrismaStoreIDEqualsUniqueParam) storeIDField()     {}

func (storeStatusWithPrismaStoreIDEqualsUniqueParam) unique() {}
func (storeStatusWithPrismaStoreIDEqualsUniqueParam) equals() {}

type StoreStatusWithPrismaDateEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeStatusModel()
	dateField()
}

type StoreStatusWithPrismaDateSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	dateField()
}

type storeStatusWithPrismaDateSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaDateSetParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaDateSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaDateSetParam) storeStatusModel() {}

func (p storeStatusWithPrismaDateSetParam) dateField() {}

type StoreStatusWithPrismaDateWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	dateField()
}

type storeStatusWithPrismaDateEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaDateEqualsParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaDateEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaDateEqualsParam) storeStatusModel() {}

func (p storeStatusWithPrismaDateEqualsParam) dateField() {}

func (storeStatusWithPrismaDateSetParam) settable()  {}
func (storeStatusWithPrismaDateEqualsParam) equals() {}

type storeStatusWithPrismaDateEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaDateEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaDateEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaDateEqualsUniqueParam) storeStatusModel() {}
func (p storeStatusWithPrismaDateEqualsUniqueParam) dateField()        {}

func (storeStatusWithPrismaDateEqualsUniqueParam) unique() {}
func (storeStatusWithPrismaDateEqualsUniqueParam) equals() {}

type StoreStatusWithPrismaIsOpenEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeStatusModel()
	isOpenField()
}

type StoreStatusWithPrismaIsOpenSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	isOpenField()
}

type storeStatusWithPrismaIsOpenSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaIsOpenSetParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaIsOpenSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaIsOpenSetParam) storeStatusModel() {}

func (p storeStatusWithPrismaIsOpenSetParam) isOpenField() {}

type StoreStatusWithPrismaIsOpenWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	isOpenField()
}

type storeStatusWithPrismaIsOpenEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaIsOpenEqualsParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaIsOpenEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaIsOpenEqualsParam) storeStatusModel() {}

func (p storeStatusWithPrismaIsOpenEqualsParam) isOpenField() {}

func (storeStatusWithPrismaIsOpenSetParam) settable()  {}
func (storeStatusWithPrismaIsOpenEqualsParam) equals() {}

type storeStatusWithPrismaIsOpenEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaIsOpenEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaIsOpenEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaIsOpenEqualsUniqueParam) storeStatusModel() {}
func (p storeStatusWithPrismaIsOpenEqualsUniqueParam) isOpenField()      {}

func (storeStatusWithPrismaIsOpenEqualsUniqueParam) unique() {}
func (storeStatusWithPrismaIsOpenEqualsUniqueParam) equals() {}

type StoreStatusWithPrismaIsExistingEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeStatusModel()
	isExistingField()
}

type StoreStatusWithPrismaIsExistingSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	isExistingField()
}

type storeStatusWithPrismaIsExistingSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaIsExistingSetParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaIsExistingSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaIsExistingSetParam) storeStatusModel() {}

func (p storeStatusWithPrismaIsExistingSetParam) isExistingField() {}

type StoreStatusWithPrismaIsExistingWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	isExistingField()
}

type storeStatusWithPrismaIsExistingEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaIsExistingEqualsParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaIsExistingEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaIsExistingEqualsParam) storeStatusModel() {}

func (p storeStatusWithPrismaIsExistingEqualsParam) isExistingField() {}

func (storeStatusWithPrismaIsExistingSetParam) settable()  {}
func (storeStatusWithPrismaIsExistingEqualsParam) equals() {}

type storeStatusWithPrismaIsExistingEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaIsExistingEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaIsExistingEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaIsExistingEqualsUniqueParam) storeStatusModel() {}
func (p storeStatusWithPrismaIsExistingEqualsUniqueParam) isExistingField()  {}

func (storeStatusWithPrismaIsExistingEqualsUniqueParam) unique() {}
func (storeStatusWithPrismaIsExistingEqualsUniqueParam) equals() {}

type StoreStatusWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeStatusModel()
	createdAtField()
}

type StoreStatusWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	createdAtField()
}

type storeStatusWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaCreatedAtSetParam) storeStatusModel() {}

func (p storeStatusWithPrismaCreatedAtSetParam) createdAtField() {}

type StoreStatusWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	createdAtField()
}

type storeStatusWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaCreatedAtEqualsParam) storeStatusModel() {}

func (p storeStatusWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (storeStatusWithPrismaCreatedAtSetParam) settable()  {}
func (storeStatusWithPrismaCreatedAtEqualsParam) equals() {}

type storeStatusWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaCreatedAtEqualsUniqueParam) storeStatusModel() {}
func (p storeStatusWithPrismaCreatedAtEqualsUniqueParam) createdAtField()   {}

func (storeStatusWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (storeStatusWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type StoreStatusWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	storeStatusModel()
	updatedAtField()
}

type StoreStatusWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	updatedAtField()
}

type storeStatusWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaUpdatedAtSetParam) storeStatusModel() {}

func (p storeStatusWithPrismaUpdatedAtSetParam) updatedAtField() {}

type StoreStatusWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	storeStatusModel()
	updatedAtField()
}

type storeStatusWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaUpdatedAtEqualsParam) storeStatusModel() {}

func (p storeStatusWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (storeStatusWithPrismaUpdatedAtSetParam) settable()  {}
func (storeStatusWithPrismaUpdatedAtEqualsParam) equals() {}

type storeStatusWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p storeStatusWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p storeStatusWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p storeStatusWithPrismaUpdatedAtEqualsUniqueParam) storeStatusModel() {}
func (p storeStatusWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()   {}

func (storeStatusWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (storeStatusWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_uid UserWithPrismaUIDSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _uid.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single accessKey.
func (r accessKeyActions) CreateOne(
	_name AccessKeyWithPrismaNameSetParam,
	_value AccessKeyWithPrismaValueSetParam,

	optional ...AccessKeySetParam,
) accessKeyCreateOne {
	var v accessKeyCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "AccessKey"
	v.query.Outputs = accessKeyOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _value.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r accessKeyCreateOne) With(params ...AccessKeyRelationWith) accessKeyCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type accessKeyCreateOne struct {
	query builder.Query
}

func (p accessKeyCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p accessKeyCreateOne) accessKeyModel() {}

func (r accessKeyCreateOne) Exec(ctx context.Context) (*AccessKeyModel, error) {
	var v AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r accessKeyCreateOne) Tx() AccessKeyUniqueTxResult {
	v := newAccessKeyUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single import.
func (r importActions) CreateOne(
	_resourceType ImportWithPrismaResourceTypeSetParam,
	_status ImportWithPrismaStatusSetParam,
	_objectKey ImportWithPrismaObjectKeySetParam,

	optional ...ImportSetParam,
) importCreateOne {
	var v importCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Import"
	v.query.Outputs = importOutput

	var fields []builder.Field

	fields = append(fields, _resourceType.field())
	fields = append(fields, _status.field())
	fields = append(fields, _objectKey.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r importCreateOne) With(params ...ImportRelationWith) importCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type importCreateOne struct {
	query builder.Query
}

func (p importCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p importCreateOne) importModel() {}

func (r importCreateOne) Exec(ctx context.Context) (*ImportModel, error) {
	var v ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r importCreateOne) Tx() ImportUniqueTxResult {
	v := newImportUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single product.
func (r productActions) CreateOne(
	_id ProductWithPrismaIDSetParam,
	_name ProductWithPrismaNameSetParam,

	optional ...ProductSetParam,
) productCreateOne {
	var v productCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Product"
	v.query.Outputs = productOutput

	var fields []builder.Field

	fields = append(fields, _id.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r productCreateOne) With(params ...ProductRelationWith) productCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type productCreateOne struct {
	query builder.Query
}

func (p productCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p productCreateOne) productModel() {}

func (r productCreateOne) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productCreateOne) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single category.
func (r categoryActions) CreateOne(

	optional ...CategorySetParam,
) categoryCreateOne {
	var v categoryCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Category"
	v.query.Outputs = categoryOutput

	var fields []builder.Field

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r categoryCreateOne) With(params ...CategoryRelationWith) categoryCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type categoryCreateOne struct {
	query builder.Query
}

func (p categoryCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p categoryCreateOne) categoryModel() {}

func (r categoryCreateOne) Exec(ctx context.Context) (*CategoryModel, error) {
	var v CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryCreateOne) Tx() CategoryUniqueTxResult {
	v := newCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single categoryGroup.
func (r categoryGroupActions) CreateOne(
	_id CategoryGroupWithPrismaIDSetParam,
	_name CategoryGroupWithPrismaNameSetParam,
	_level CategoryGroupWithPrismaLevelSetParam,

	optional ...CategoryGroupSetParam,
) categoryGroupCreateOne {
	var v categoryGroupCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "CategoryGroup"
	v.query.Outputs = categoryGroupOutput

	var fields []builder.Field

	fields = append(fields, _id.field())
	fields = append(fields, _name.field())
	fields = append(fields, _level.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r categoryGroupCreateOne) With(params ...CategoryGroupRelationWith) categoryGroupCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type categoryGroupCreateOne struct {
	query builder.Query
}

func (p categoryGroupCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p categoryGroupCreateOne) categoryGroupModel() {}

func (r categoryGroupCreateOne) Exec(ctx context.Context) (*CategoryGroupModel, error) {
	var v CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCreateOne) Tx() CategoryGroupUniqueTxResult {
	v := newCategoryGroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single categoryGroupCategory.
func (r categoryGroupCategoryActions) CreateOne(
	_category CategoryGroupCategoryWithPrismaCategorySetParam,
	_categoryGroup CategoryGroupCategoryWithPrismaCategoryGroupSetParam,

	optional ...CategoryGroupCategorySetParam,
) categoryGroupCategoryCreateOne {
	var v categoryGroupCategoryCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "CategoryGroupCategory"
	v.query.Outputs = categoryGroupCategoryOutput

	var fields []builder.Field

	fields = append(fields, _category.field())
	fields = append(fields, _categoryGroup.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r categoryGroupCategoryCreateOne) With(params ...CategoryGroupCategoryRelationWith) categoryGroupCategoryCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type categoryGroupCategoryCreateOne struct {
	query builder.Query
}

func (p categoryGroupCategoryCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p categoryGroupCategoryCreateOne) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryCreateOne) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryCreateOne) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single store.
func (r storeActions) CreateOne(
	_id StoreWithPrismaIDSetParam,
	_name StoreWithPrismaNameSetParam,

	optional ...StoreSetParam,
) storeCreateOne {
	var v storeCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Store"
	v.query.Outputs = storeOutput

	var fields []builder.Field

	fields = append(fields, _id.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r storeCreateOne) With(params ...StoreRelationWith) storeCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type storeCreateOne struct {
	query builder.Query
}

func (p storeCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p storeCreateOne) storeModel() {}

func (r storeCreateOne) Exec(ctx context.Context) (*StoreModel, error) {
	var v StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeCreateOne) Tx() StoreUniqueTxResult {
	v := newStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single userStore.
func (r userStoreActions) CreateOne(
	_email UserStoreWithPrismaEmailSetParam,
	_name UserStoreWithPrismaNameSetParam,
	_store UserStoreWithPrismaStoreSetParam,

	optional ...UserStoreSetParam,
) userStoreCreateOne {
	var v userStoreCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "UserStore"
	v.query.Outputs = userStoreOutput

	var fields []builder.Field

	fields = append(fields, _email.field())
	fields = append(fields, _name.field())
	fields = append(fields, _store.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userStoreCreateOne) With(params ...UserStoreRelationWith) userStoreCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userStoreCreateOne struct {
	query builder.Query
}

func (p userStoreCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userStoreCreateOne) userStoreModel() {}

func (r userStoreCreateOne) Exec(ctx context.Context) (*UserStoreModel, error) {
	var v UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreCreateOne) Tx() UserStoreUniqueTxResult {
	v := newUserStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single holiday.
func (r holidayActions) CreateOne(
	_date HolidayWithPrismaDateSetParam,
	_name HolidayWithPrismaNameSetParam,

	optional ...HolidaySetParam,
) holidayCreateOne {
	var v holidayCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Holiday"
	v.query.Outputs = holidayOutput

	var fields []builder.Field

	fields = append(fields, _date.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r holidayCreateOne) With(params ...HolidayRelationWith) holidayCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type holidayCreateOne struct {
	query builder.Query
}

func (p holidayCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p holidayCreateOne) holidayModel() {}

func (r holidayCreateOne) Exec(ctx context.Context) (*HolidayModel, error) {
	var v HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r holidayCreateOne) Tx() HolidayUniqueTxResult {
	v := newHolidayUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single storeStatus.
func (r storeStatusActions) CreateOne(
	_storeID StoreStatusWithPrismaStoreIDSetParam,
	_date StoreStatusWithPrismaDateSetParam,

	optional ...StoreStatusSetParam,
) storeStatusCreateOne {
	var v storeStatusCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "StoreStatus"
	v.query.Outputs = storeStatusOutput

	var fields []builder.Field

	fields = append(fields, _storeID.field())
	fields = append(fields, _date.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r storeStatusCreateOne) With(params ...StoreStatusRelationWith) storeStatusCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type storeStatusCreateOne struct {
	query builder.Query
}

func (p storeStatusCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p storeStatusCreateOne) storeStatusModel() {}

func (r storeStatusCreateOne) Exec(ctx context.Context) (*StoreStatusModel, error) {
	var v StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeStatusCreateOne) Tx() StoreStatusUniqueTxResult {
	v := newStoreStatusUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Select(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Omit(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) Select(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) Omit(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) Select(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) Omit(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type accessKeyFindUnique struct {
	query builder.Query
}

func (r accessKeyFindUnique) getQuery() builder.Query {
	return r.query
}

func (r accessKeyFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r accessKeyFindUnique) with()              {}
func (r accessKeyFindUnique) accessKeyModel()    {}
func (r accessKeyFindUnique) accessKeyRelation() {}

func (r accessKeyActions) FindUnique(
	params AccessKeyEqualsUniqueWhereParam,
) accessKeyFindUnique {
	var v accessKeyFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "AccessKey"
	v.query.Outputs = accessKeyOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r accessKeyFindUnique) With(params ...AccessKeyRelationWith) accessKeyFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r accessKeyFindUnique) Select(params ...accessKeyPrismaFields) accessKeyFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r accessKeyFindUnique) Omit(params ...accessKeyPrismaFields) accessKeyFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range accessKeyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r accessKeyFindUnique) Exec(ctx context.Context) (
	*AccessKeyModel,
	error,
) {
	var v *AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r accessKeyFindUnique) ExecInner(ctx context.Context) (
	*InnerAccessKey,
	error,
) {
	var v *InnerAccessKey
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r accessKeyFindUnique) Update(params ...AccessKeySetParam) accessKeyUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "AccessKey"

	var v accessKeyUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type accessKeyUpdateUnique struct {
	query builder.Query
}

func (r accessKeyUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r accessKeyUpdateUnique) accessKeyModel() {}

func (r accessKeyUpdateUnique) Exec(ctx context.Context) (*AccessKeyModel, error) {
	var v AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r accessKeyUpdateUnique) Tx() AccessKeyUniqueTxResult {
	v := newAccessKeyUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r accessKeyFindUnique) Delete() accessKeyDeleteUnique {
	var v accessKeyDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "AccessKey"

	return v
}

type accessKeyDeleteUnique struct {
	query builder.Query
}

func (r accessKeyDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p accessKeyDeleteUnique) accessKeyModel() {}

func (r accessKeyDeleteUnique) Exec(ctx context.Context) (*AccessKeyModel, error) {
	var v AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r accessKeyDeleteUnique) Tx() AccessKeyUniqueTxResult {
	v := newAccessKeyUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type accessKeyFindFirst struct {
	query builder.Query
}

func (r accessKeyFindFirst) getQuery() builder.Query {
	return r.query
}

func (r accessKeyFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r accessKeyFindFirst) with()              {}
func (r accessKeyFindFirst) accessKeyModel()    {}
func (r accessKeyFindFirst) accessKeyRelation() {}

func (r accessKeyActions) FindFirst(
	params ...AccessKeyWhereParam,
) accessKeyFindFirst {
	var v accessKeyFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "AccessKey"
	v.query.Outputs = accessKeyOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r accessKeyFindFirst) With(params ...AccessKeyRelationWith) accessKeyFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r accessKeyFindFirst) Select(params ...accessKeyPrismaFields) accessKeyFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r accessKeyFindFirst) Omit(params ...accessKeyPrismaFields) accessKeyFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range accessKeyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r accessKeyFindFirst) OrderBy(params ...AccessKeyOrderByParam) accessKeyFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r accessKeyFindFirst) Skip(count int) accessKeyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r accessKeyFindFirst) Take(count int) accessKeyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r accessKeyFindFirst) Cursor(cursor AccessKeyCursorParam) accessKeyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r accessKeyFindFirst) Exec(ctx context.Context) (
	*AccessKeyModel,
	error,
) {
	var v *AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r accessKeyFindFirst) ExecInner(ctx context.Context) (
	*InnerAccessKey,
	error,
) {
	var v *InnerAccessKey
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type accessKeyFindMany struct {
	query builder.Query
}

func (r accessKeyFindMany) getQuery() builder.Query {
	return r.query
}

func (r accessKeyFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r accessKeyFindMany) with()              {}
func (r accessKeyFindMany) accessKeyModel()    {}
func (r accessKeyFindMany) accessKeyRelation() {}

func (r accessKeyActions) FindMany(
	params ...AccessKeyWhereParam,
) accessKeyFindMany {
	var v accessKeyFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "AccessKey"
	v.query.Outputs = accessKeyOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r accessKeyFindMany) With(params ...AccessKeyRelationWith) accessKeyFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r accessKeyFindMany) Select(params ...accessKeyPrismaFields) accessKeyFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r accessKeyFindMany) Omit(params ...accessKeyPrismaFields) accessKeyFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range accessKeyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r accessKeyFindMany) OrderBy(params ...AccessKeyOrderByParam) accessKeyFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r accessKeyFindMany) Skip(count int) accessKeyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r accessKeyFindMany) Take(count int) accessKeyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r accessKeyFindMany) Cursor(cursor AccessKeyCursorParam) accessKeyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r accessKeyFindMany) Exec(ctx context.Context) (
	[]AccessKeyModel,
	error,
) {
	var v []AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r accessKeyFindMany) ExecInner(ctx context.Context) (
	[]InnerAccessKey,
	error,
) {
	var v []InnerAccessKey
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r accessKeyFindMany) Update(params ...AccessKeySetParam) accessKeyUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "AccessKey"

	r.query.Outputs = countOutput

	var v accessKeyUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type accessKeyUpdateMany struct {
	query builder.Query
}

func (r accessKeyUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r accessKeyUpdateMany) accessKeyModel() {}

func (r accessKeyUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r accessKeyUpdateMany) Tx() AccessKeyManyTxResult {
	v := newAccessKeyManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r accessKeyFindMany) Delete() accessKeyDeleteMany {
	var v accessKeyDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "AccessKey"

	v.query.Outputs = countOutput

	return v
}

type accessKeyDeleteMany struct {
	query builder.Query
}

func (r accessKeyDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p accessKeyDeleteMany) accessKeyModel() {}

func (r accessKeyDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r accessKeyDeleteMany) Tx() AccessKeyManyTxResult {
	v := newAccessKeyManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type importFindUnique struct {
	query builder.Query
}

func (r importFindUnique) getQuery() builder.Query {
	return r.query
}

func (r importFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r importFindUnique) with()           {}
func (r importFindUnique) importModel()    {}
func (r importFindUnique) importRelation() {}

func (r importActions) FindUnique(
	params ImportEqualsUniqueWhereParam,
) importFindUnique {
	var v importFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Import"
	v.query.Outputs = importOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r importFindUnique) With(params ...ImportRelationWith) importFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r importFindUnique) Select(params ...importPrismaFields) importFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r importFindUnique) Omit(params ...importPrismaFields) importFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range importOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r importFindUnique) Exec(ctx context.Context) (
	*ImportModel,
	error,
) {
	var v *ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r importFindUnique) ExecInner(ctx context.Context) (
	*InnerImport,
	error,
) {
	var v *InnerImport
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r importFindUnique) Update(params ...ImportSetParam) importUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Import"

	var v importUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type importUpdateUnique struct {
	query builder.Query
}

func (r importUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r importUpdateUnique) importModel() {}

func (r importUpdateUnique) Exec(ctx context.Context) (*ImportModel, error) {
	var v ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r importUpdateUnique) Tx() ImportUniqueTxResult {
	v := newImportUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r importFindUnique) Delete() importDeleteUnique {
	var v importDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Import"

	return v
}

type importDeleteUnique struct {
	query builder.Query
}

func (r importDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p importDeleteUnique) importModel() {}

func (r importDeleteUnique) Exec(ctx context.Context) (*ImportModel, error) {
	var v ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r importDeleteUnique) Tx() ImportUniqueTxResult {
	v := newImportUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type importFindFirst struct {
	query builder.Query
}

func (r importFindFirst) getQuery() builder.Query {
	return r.query
}

func (r importFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r importFindFirst) with()           {}
func (r importFindFirst) importModel()    {}
func (r importFindFirst) importRelation() {}

func (r importActions) FindFirst(
	params ...ImportWhereParam,
) importFindFirst {
	var v importFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Import"
	v.query.Outputs = importOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r importFindFirst) With(params ...ImportRelationWith) importFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r importFindFirst) Select(params ...importPrismaFields) importFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r importFindFirst) Omit(params ...importPrismaFields) importFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range importOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r importFindFirst) OrderBy(params ...ImportOrderByParam) importFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r importFindFirst) Skip(count int) importFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r importFindFirst) Take(count int) importFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r importFindFirst) Cursor(cursor ImportCursorParam) importFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r importFindFirst) Exec(ctx context.Context) (
	*ImportModel,
	error,
) {
	var v *ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r importFindFirst) ExecInner(ctx context.Context) (
	*InnerImport,
	error,
) {
	var v *InnerImport
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type importFindMany struct {
	query builder.Query
}

func (r importFindMany) getQuery() builder.Query {
	return r.query
}

func (r importFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r importFindMany) with()           {}
func (r importFindMany) importModel()    {}
func (r importFindMany) importRelation() {}

func (r importActions) FindMany(
	params ...ImportWhereParam,
) importFindMany {
	var v importFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Import"
	v.query.Outputs = importOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r importFindMany) With(params ...ImportRelationWith) importFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r importFindMany) Select(params ...importPrismaFields) importFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r importFindMany) Omit(params ...importPrismaFields) importFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range importOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r importFindMany) OrderBy(params ...ImportOrderByParam) importFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r importFindMany) Skip(count int) importFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r importFindMany) Take(count int) importFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r importFindMany) Cursor(cursor ImportCursorParam) importFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r importFindMany) Exec(ctx context.Context) (
	[]ImportModel,
	error,
) {
	var v []ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r importFindMany) ExecInner(ctx context.Context) (
	[]InnerImport,
	error,
) {
	var v []InnerImport
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r importFindMany) Update(params ...ImportSetParam) importUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Import"

	r.query.Outputs = countOutput

	var v importUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type importUpdateMany struct {
	query builder.Query
}

func (r importUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r importUpdateMany) importModel() {}

func (r importUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r importUpdateMany) Tx() ImportManyTxResult {
	v := newImportManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r importFindMany) Delete() importDeleteMany {
	var v importDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Import"

	v.query.Outputs = countOutput

	return v
}

type importDeleteMany struct {
	query builder.Query
}

func (r importDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p importDeleteMany) importModel() {}

func (r importDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r importDeleteMany) Tx() ImportManyTxResult {
	v := newImportManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productFindUnique struct {
	query builder.Query
}

func (r productFindUnique) getQuery() builder.Query {
	return r.query
}

func (r productFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productFindUnique) with()            {}
func (r productFindUnique) productModel()    {}
func (r productFindUnique) productRelation() {}

func (r productActions) FindUnique(
	params ProductEqualsUniqueWhereParam,
) productFindUnique {
	var v productFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Product"
	v.query.Outputs = productOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r productFindUnique) With(params ...ProductRelationWith) productFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productFindUnique) Select(params ...productPrismaFields) productFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindUnique) Omit(params ...productPrismaFields) productFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindUnique) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productFindUnique) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productFindUnique) Update(params ...ProductSetParam) productUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Product"

	var v productUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productUpdateUnique struct {
	query builder.Query
}

func (r productUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r productUpdateUnique) productModel() {}

func (r productUpdateUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productUpdateUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productFindUnique) Delete() productDeleteUnique {
	var v productDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Product"

	return v
}

type productDeleteUnique struct {
	query builder.Query
}

func (r productDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p productDeleteUnique) productModel() {}

func (r productDeleteUnique) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productDeleteUnique) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productFindFirst struct {
	query builder.Query
}

func (r productFindFirst) getQuery() builder.Query {
	return r.query
}

func (r productFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r productFindFirst) with()            {}
func (r productFindFirst) productModel()    {}
func (r productFindFirst) productRelation() {}

func (r productActions) FindFirst(
	params ...ProductWhereParam,
) productFindFirst {
	var v productFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Product"
	v.query.Outputs = productOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r productFindFirst) With(params ...ProductRelationWith) productFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productFindFirst) Select(params ...productPrismaFields) productFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindFirst) Omit(params ...productPrismaFields) productFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindFirst) OrderBy(params ...ProductOrderByParam) productFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productFindFirst) Skip(count int) productFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productFindFirst) Take(count int) productFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productFindFirst) Cursor(cursor ProductCursorParam) productFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productFindFirst) Exec(ctx context.Context) (
	*ProductModel,
	error,
) {
	var v *ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r productFindFirst) ExecInner(ctx context.Context) (
	*InnerProduct,
	error,
) {
	var v *InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type productFindMany struct {
	query builder.Query
}

func (r productFindMany) getQuery() builder.Query {
	return r.query
}

func (r productFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productFindMany) with()            {}
func (r productFindMany) productModel()    {}
func (r productFindMany) productRelation() {}

func (r productActions) FindMany(
	params ...ProductWhereParam,
) productFindMany {
	var v productFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Product"
	v.query.Outputs = productOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r productFindMany) With(params ...ProductRelationWith) productFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r productFindMany) Select(params ...productPrismaFields) productFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindMany) Omit(params ...productPrismaFields) productFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range productOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r productFindMany) OrderBy(params ...ProductOrderByParam) productFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r productFindMany) Skip(count int) productFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r productFindMany) Take(count int) productFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r productFindMany) Cursor(cursor ProductCursorParam) productFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r productFindMany) Exec(ctx context.Context) (
	[]ProductModel,
	error,
) {
	var v []ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productFindMany) ExecInner(ctx context.Context) (
	[]InnerProduct,
	error,
) {
	var v []InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r productFindMany) Update(params ...ProductSetParam) productUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Product"

	r.query.Outputs = countOutput

	var v productUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type productUpdateMany struct {
	query builder.Query
}

func (r productUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r productUpdateMany) productModel() {}

func (r productUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productUpdateMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r productFindMany) Delete() productDeleteMany {
	var v productDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Product"

	v.query.Outputs = countOutput

	return v
}

type productDeleteMany struct {
	query builder.Query
}

func (r productDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p productDeleteMany) productModel() {}

func (r productDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productDeleteMany) Tx() ProductManyTxResult {
	v := newProductManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryToCategoryGroupCategoriesFindUnique struct {
	query builder.Query
}

func (r categoryToCategoryGroupCategoriesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesFindUnique) with()             {}
func (r categoryToCategoryGroupCategoriesFindUnique) categoryModel()    {}
func (r categoryToCategoryGroupCategoriesFindUnique) categoryRelation() {}

func (r categoryToCategoryGroupCategoriesFindUnique) With(params ...CategoryGroupCategoryRelationWith) categoryToCategoryGroupCategoriesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryToCategoryGroupCategoriesFindUnique) Select(params ...categoryPrismaFields) categoryToCategoryGroupCategoriesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryToCategoryGroupCategoriesFindUnique) Omit(params ...categoryPrismaFields) categoryToCategoryGroupCategoriesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryToCategoryGroupCategoriesFindUnique) Exec(ctx context.Context) (
	*CategoryModel,
	error,
) {
	var v *CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryToCategoryGroupCategoriesFindUnique) ExecInner(ctx context.Context) (
	*InnerCategory,
	error,
) {
	var v *InnerCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryToCategoryGroupCategoriesFindUnique) Update(params ...CategorySetParam) categoryToCategoryGroupCategoriesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Category"

	var v categoryToCategoryGroupCategoriesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryToCategoryGroupCategoriesUpdateUnique struct {
	query builder.Query
}

func (r categoryToCategoryGroupCategoriesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesUpdateUnique) categoryModel() {}

func (r categoryToCategoryGroupCategoriesUpdateUnique) Exec(ctx context.Context) (*CategoryModel, error) {
	var v CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryToCategoryGroupCategoriesUpdateUnique) Tx() CategoryUniqueTxResult {
	v := newCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryToCategoryGroupCategoriesFindUnique) Delete() categoryToCategoryGroupCategoriesDeleteUnique {
	var v categoryToCategoryGroupCategoriesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Category"

	return v
}

type categoryToCategoryGroupCategoriesDeleteUnique struct {
	query builder.Query
}

func (r categoryToCategoryGroupCategoriesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryToCategoryGroupCategoriesDeleteUnique) categoryModel() {}

func (r categoryToCategoryGroupCategoriesDeleteUnique) Exec(ctx context.Context) (*CategoryModel, error) {
	var v CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryToCategoryGroupCategoriesDeleteUnique) Tx() CategoryUniqueTxResult {
	v := newCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryToCategoryGroupCategoriesFindFirst struct {
	query builder.Query
}

func (r categoryToCategoryGroupCategoriesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesFindFirst) with()             {}
func (r categoryToCategoryGroupCategoriesFindFirst) categoryModel()    {}
func (r categoryToCategoryGroupCategoriesFindFirst) categoryRelation() {}

func (r categoryToCategoryGroupCategoriesFindFirst) With(params ...CategoryGroupCategoryRelationWith) categoryToCategoryGroupCategoriesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryToCategoryGroupCategoriesFindFirst) Select(params ...categoryPrismaFields) categoryToCategoryGroupCategoriesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryToCategoryGroupCategoriesFindFirst) Omit(params ...categoryPrismaFields) categoryToCategoryGroupCategoriesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryToCategoryGroupCategoriesFindFirst) OrderBy(params ...CategoryGroupCategoryOrderByParam) categoryToCategoryGroupCategoriesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryToCategoryGroupCategoriesFindFirst) Skip(count int) categoryToCategoryGroupCategoriesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryToCategoryGroupCategoriesFindFirst) Take(count int) categoryToCategoryGroupCategoriesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryToCategoryGroupCategoriesFindFirst) Cursor(cursor CategoryCursorParam) categoryToCategoryGroupCategoriesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryToCategoryGroupCategoriesFindFirst) Exec(ctx context.Context) (
	*CategoryModel,
	error,
) {
	var v *CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryToCategoryGroupCategoriesFindFirst) ExecInner(ctx context.Context) (
	*InnerCategory,
	error,
) {
	var v *InnerCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type categoryToCategoryGroupCategoriesFindMany struct {
	query builder.Query
}

func (r categoryToCategoryGroupCategoriesFindMany) getQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesFindMany) with()             {}
func (r categoryToCategoryGroupCategoriesFindMany) categoryModel()    {}
func (r categoryToCategoryGroupCategoriesFindMany) categoryRelation() {}

func (r categoryToCategoryGroupCategoriesFindMany) With(params ...CategoryGroupCategoryRelationWith) categoryToCategoryGroupCategoriesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryToCategoryGroupCategoriesFindMany) Select(params ...categoryPrismaFields) categoryToCategoryGroupCategoriesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryToCategoryGroupCategoriesFindMany) Omit(params ...categoryPrismaFields) categoryToCategoryGroupCategoriesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryToCategoryGroupCategoriesFindMany) OrderBy(params ...CategoryGroupCategoryOrderByParam) categoryToCategoryGroupCategoriesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryToCategoryGroupCategoriesFindMany) Skip(count int) categoryToCategoryGroupCategoriesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryToCategoryGroupCategoriesFindMany) Take(count int) categoryToCategoryGroupCategoriesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryToCategoryGroupCategoriesFindMany) Cursor(cursor CategoryCursorParam) categoryToCategoryGroupCategoriesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryToCategoryGroupCategoriesFindMany) Exec(ctx context.Context) (
	[]CategoryModel,
	error,
) {
	var v []CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryToCategoryGroupCategoriesFindMany) ExecInner(ctx context.Context) (
	[]InnerCategory,
	error,
) {
	var v []InnerCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryToCategoryGroupCategoriesFindMany) Update(params ...CategorySetParam) categoryToCategoryGroupCategoriesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Category"

	r.query.Outputs = countOutput

	var v categoryToCategoryGroupCategoriesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryToCategoryGroupCategoriesUpdateMany struct {
	query builder.Query
}

func (r categoryToCategoryGroupCategoriesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryToCategoryGroupCategoriesUpdateMany) categoryModel() {}

func (r categoryToCategoryGroupCategoriesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryToCategoryGroupCategoriesUpdateMany) Tx() CategoryManyTxResult {
	v := newCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryToCategoryGroupCategoriesFindMany) Delete() categoryToCategoryGroupCategoriesDeleteMany {
	var v categoryToCategoryGroupCategoriesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Category"

	v.query.Outputs = countOutput

	return v
}

type categoryToCategoryGroupCategoriesDeleteMany struct {
	query builder.Query
}

func (r categoryToCategoryGroupCategoriesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryToCategoryGroupCategoriesDeleteMany) categoryModel() {}

func (r categoryToCategoryGroupCategoriesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryToCategoryGroupCategoriesDeleteMany) Tx() CategoryManyTxResult {
	v := newCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryFindUnique struct {
	query builder.Query
}

func (r categoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r categoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryFindUnique) with()             {}
func (r categoryFindUnique) categoryModel()    {}
func (r categoryFindUnique) categoryRelation() {}

func (r categoryActions) FindUnique(
	params CategoryEqualsUniqueWhereParam,
) categoryFindUnique {
	var v categoryFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Category"
	v.query.Outputs = categoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r categoryFindUnique) With(params ...CategoryRelationWith) categoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryFindUnique) Select(params ...categoryPrismaFields) categoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryFindUnique) Omit(params ...categoryPrismaFields) categoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryFindUnique) Exec(ctx context.Context) (
	*CategoryModel,
	error,
) {
	var v *CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryFindUnique) ExecInner(ctx context.Context) (
	*InnerCategory,
	error,
) {
	var v *InnerCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryFindUnique) Update(params ...CategorySetParam) categoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Category"

	var v categoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryUpdateUnique struct {
	query builder.Query
}

func (r categoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryUpdateUnique) categoryModel() {}

func (r categoryUpdateUnique) Exec(ctx context.Context) (*CategoryModel, error) {
	var v CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryUpdateUnique) Tx() CategoryUniqueTxResult {
	v := newCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryFindUnique) Delete() categoryDeleteUnique {
	var v categoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Category"

	return v
}

type categoryDeleteUnique struct {
	query builder.Query
}

func (r categoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryDeleteUnique) categoryModel() {}

func (r categoryDeleteUnique) Exec(ctx context.Context) (*CategoryModel, error) {
	var v CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryDeleteUnique) Tx() CategoryUniqueTxResult {
	v := newCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryFindFirst struct {
	query builder.Query
}

func (r categoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r categoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryFindFirst) with()             {}
func (r categoryFindFirst) categoryModel()    {}
func (r categoryFindFirst) categoryRelation() {}

func (r categoryActions) FindFirst(
	params ...CategoryWhereParam,
) categoryFindFirst {
	var v categoryFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Category"
	v.query.Outputs = categoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryFindFirst) With(params ...CategoryRelationWith) categoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryFindFirst) Select(params ...categoryPrismaFields) categoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryFindFirst) Omit(params ...categoryPrismaFields) categoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryFindFirst) OrderBy(params ...CategoryOrderByParam) categoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryFindFirst) Skip(count int) categoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryFindFirst) Take(count int) categoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryFindFirst) Cursor(cursor CategoryCursorParam) categoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryFindFirst) Exec(ctx context.Context) (
	*CategoryModel,
	error,
) {
	var v *CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryFindFirst) ExecInner(ctx context.Context) (
	*InnerCategory,
	error,
) {
	var v *InnerCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type categoryFindMany struct {
	query builder.Query
}

func (r categoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r categoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryFindMany) with()             {}
func (r categoryFindMany) categoryModel()    {}
func (r categoryFindMany) categoryRelation() {}

func (r categoryActions) FindMany(
	params ...CategoryWhereParam,
) categoryFindMany {
	var v categoryFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Category"
	v.query.Outputs = categoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryFindMany) With(params ...CategoryRelationWith) categoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryFindMany) Select(params ...categoryPrismaFields) categoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryFindMany) Omit(params ...categoryPrismaFields) categoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryFindMany) OrderBy(params ...CategoryOrderByParam) categoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryFindMany) Skip(count int) categoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryFindMany) Take(count int) categoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryFindMany) Cursor(cursor CategoryCursorParam) categoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryFindMany) Exec(ctx context.Context) (
	[]CategoryModel,
	error,
) {
	var v []CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryFindMany) ExecInner(ctx context.Context) (
	[]InnerCategory,
	error,
) {
	var v []InnerCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryFindMany) Update(params ...CategorySetParam) categoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Category"

	r.query.Outputs = countOutput

	var v categoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryUpdateMany struct {
	query builder.Query
}

func (r categoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryUpdateMany) categoryModel() {}

func (r categoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryUpdateMany) Tx() CategoryManyTxResult {
	v := newCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryFindMany) Delete() categoryDeleteMany {
	var v categoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Category"

	v.query.Outputs = countOutput

	return v
}

type categoryDeleteMany struct {
	query builder.Query
}

func (r categoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryDeleteMany) categoryModel() {}

func (r categoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryDeleteMany) Tx() CategoryManyTxResult {
	v := newCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupToCategoryGroupCategoriesFindUnique struct {
	query builder.Query
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) with()                  {}
func (r categoryGroupToCategoryGroupCategoriesFindUnique) categoryGroupModel()    {}
func (r categoryGroupToCategoryGroupCategoriesFindUnique) categoryGroupRelation() {}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) With(params ...CategoryGroupCategoryRelationWith) categoryGroupToCategoryGroupCategoriesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) Select(params ...categoryGroupPrismaFields) categoryGroupToCategoryGroupCategoriesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) Omit(params ...categoryGroupPrismaFields) categoryGroupToCategoryGroupCategoriesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) Exec(ctx context.Context) (
	*CategoryGroupModel,
	error,
) {
	var v *CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) ExecInner(ctx context.Context) (
	*InnerCategoryGroup,
	error,
) {
	var v *InnerCategoryGroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) Update(params ...CategoryGroupSetParam) categoryGroupToCategoryGroupCategoriesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "CategoryGroup"

	var v categoryGroupToCategoryGroupCategoriesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupToCategoryGroupCategoriesUpdateUnique struct {
	query builder.Query
}

func (r categoryGroupToCategoryGroupCategoriesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesUpdateUnique) categoryGroupModel() {}

func (r categoryGroupToCategoryGroupCategoriesUpdateUnique) Exec(ctx context.Context) (*CategoryGroupModel, error) {
	var v CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupToCategoryGroupCategoriesUpdateUnique) Tx() CategoryGroupUniqueTxResult {
	v := newCategoryGroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupToCategoryGroupCategoriesFindUnique) Delete() categoryGroupToCategoryGroupCategoriesDeleteUnique {
	var v categoryGroupToCategoryGroupCategoriesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "CategoryGroup"

	return v
}

type categoryGroupToCategoryGroupCategoriesDeleteUnique struct {
	query builder.Query
}

func (r categoryGroupToCategoryGroupCategoriesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupToCategoryGroupCategoriesDeleteUnique) categoryGroupModel() {}

func (r categoryGroupToCategoryGroupCategoriesDeleteUnique) Exec(ctx context.Context) (*CategoryGroupModel, error) {
	var v CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupToCategoryGroupCategoriesDeleteUnique) Tx() CategoryGroupUniqueTxResult {
	v := newCategoryGroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupToCategoryGroupCategoriesFindFirst struct {
	query builder.Query
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) with()                  {}
func (r categoryGroupToCategoryGroupCategoriesFindFirst) categoryGroupModel()    {}
func (r categoryGroupToCategoryGroupCategoriesFindFirst) categoryGroupRelation() {}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) With(params ...CategoryGroupCategoryRelationWith) categoryGroupToCategoryGroupCategoriesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) Select(params ...categoryGroupPrismaFields) categoryGroupToCategoryGroupCategoriesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) Omit(params ...categoryGroupPrismaFields) categoryGroupToCategoryGroupCategoriesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) OrderBy(params ...CategoryGroupCategoryOrderByParam) categoryGroupToCategoryGroupCategoriesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) Skip(count int) categoryGroupToCategoryGroupCategoriesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) Take(count int) categoryGroupToCategoryGroupCategoriesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) Cursor(cursor CategoryGroupCursorParam) categoryGroupToCategoryGroupCategoriesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) Exec(ctx context.Context) (
	*CategoryGroupModel,
	error,
) {
	var v *CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupToCategoryGroupCategoriesFindFirst) ExecInner(ctx context.Context) (
	*InnerCategoryGroup,
	error,
) {
	var v *InnerCategoryGroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type categoryGroupToCategoryGroupCategoriesFindMany struct {
	query builder.Query
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) with()                  {}
func (r categoryGroupToCategoryGroupCategoriesFindMany) categoryGroupModel()    {}
func (r categoryGroupToCategoryGroupCategoriesFindMany) categoryGroupRelation() {}

func (r categoryGroupToCategoryGroupCategoriesFindMany) With(params ...CategoryGroupCategoryRelationWith) categoryGroupToCategoryGroupCategoriesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Select(params ...categoryGroupPrismaFields) categoryGroupToCategoryGroupCategoriesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Omit(params ...categoryGroupPrismaFields) categoryGroupToCategoryGroupCategoriesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) OrderBy(params ...CategoryGroupCategoryOrderByParam) categoryGroupToCategoryGroupCategoriesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Skip(count int) categoryGroupToCategoryGroupCategoriesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Take(count int) categoryGroupToCategoryGroupCategoriesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Cursor(cursor CategoryGroupCursorParam) categoryGroupToCategoryGroupCategoriesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Exec(ctx context.Context) (
	[]CategoryGroupModel,
	error,
) {
	var v []CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) ExecInner(ctx context.Context) (
	[]InnerCategoryGroup,
	error,
) {
	var v []InnerCategoryGroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Update(params ...CategoryGroupSetParam) categoryGroupToCategoryGroupCategoriesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "CategoryGroup"

	r.query.Outputs = countOutput

	var v categoryGroupToCategoryGroupCategoriesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupToCategoryGroupCategoriesUpdateMany struct {
	query builder.Query
}

func (r categoryGroupToCategoryGroupCategoriesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupToCategoryGroupCategoriesUpdateMany) categoryGroupModel() {}

func (r categoryGroupToCategoryGroupCategoriesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupToCategoryGroupCategoriesUpdateMany) Tx() CategoryGroupManyTxResult {
	v := newCategoryGroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupToCategoryGroupCategoriesFindMany) Delete() categoryGroupToCategoryGroupCategoriesDeleteMany {
	var v categoryGroupToCategoryGroupCategoriesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "CategoryGroup"

	v.query.Outputs = countOutput

	return v
}

type categoryGroupToCategoryGroupCategoriesDeleteMany struct {
	query builder.Query
}

func (r categoryGroupToCategoryGroupCategoriesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupToCategoryGroupCategoriesDeleteMany) categoryGroupModel() {}

func (r categoryGroupToCategoryGroupCategoriesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupToCategoryGroupCategoriesDeleteMany) Tx() CategoryGroupManyTxResult {
	v := newCategoryGroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupFindUnique struct {
	query builder.Query
}

func (r categoryGroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupFindUnique) with()                  {}
func (r categoryGroupFindUnique) categoryGroupModel()    {}
func (r categoryGroupFindUnique) categoryGroupRelation() {}

func (r categoryGroupActions) FindUnique(
	params CategoryGroupEqualsUniqueWhereParam,
) categoryGroupFindUnique {
	var v categoryGroupFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "CategoryGroup"
	v.query.Outputs = categoryGroupOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r categoryGroupFindUnique) With(params ...CategoryGroupRelationWith) categoryGroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupFindUnique) Select(params ...categoryGroupPrismaFields) categoryGroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupFindUnique) Omit(params ...categoryGroupPrismaFields) categoryGroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupFindUnique) Exec(ctx context.Context) (
	*CategoryGroupModel,
	error,
) {
	var v *CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupFindUnique) ExecInner(ctx context.Context) (
	*InnerCategoryGroup,
	error,
) {
	var v *InnerCategoryGroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupFindUnique) Update(params ...CategoryGroupSetParam) categoryGroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "CategoryGroup"

	var v categoryGroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupUpdateUnique struct {
	query builder.Query
}

func (r categoryGroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupUpdateUnique) categoryGroupModel() {}

func (r categoryGroupUpdateUnique) Exec(ctx context.Context) (*CategoryGroupModel, error) {
	var v CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupUpdateUnique) Tx() CategoryGroupUniqueTxResult {
	v := newCategoryGroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupFindUnique) Delete() categoryGroupDeleteUnique {
	var v categoryGroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "CategoryGroup"

	return v
}

type categoryGroupDeleteUnique struct {
	query builder.Query
}

func (r categoryGroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupDeleteUnique) categoryGroupModel() {}

func (r categoryGroupDeleteUnique) Exec(ctx context.Context) (*CategoryGroupModel, error) {
	var v CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupDeleteUnique) Tx() CategoryGroupUniqueTxResult {
	v := newCategoryGroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupFindFirst struct {
	query builder.Query
}

func (r categoryGroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupFindFirst) with()                  {}
func (r categoryGroupFindFirst) categoryGroupModel()    {}
func (r categoryGroupFindFirst) categoryGroupRelation() {}

func (r categoryGroupActions) FindFirst(
	params ...CategoryGroupWhereParam,
) categoryGroupFindFirst {
	var v categoryGroupFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "CategoryGroup"
	v.query.Outputs = categoryGroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryGroupFindFirst) With(params ...CategoryGroupRelationWith) categoryGroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupFindFirst) Select(params ...categoryGroupPrismaFields) categoryGroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupFindFirst) Omit(params ...categoryGroupPrismaFields) categoryGroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupFindFirst) OrderBy(params ...CategoryGroupOrderByParam) categoryGroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupFindFirst) Skip(count int) categoryGroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupFindFirst) Take(count int) categoryGroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupFindFirst) Cursor(cursor CategoryGroupCursorParam) categoryGroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupFindFirst) Exec(ctx context.Context) (
	*CategoryGroupModel,
	error,
) {
	var v *CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupFindFirst) ExecInner(ctx context.Context) (
	*InnerCategoryGroup,
	error,
) {
	var v *InnerCategoryGroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type categoryGroupFindMany struct {
	query builder.Query
}

func (r categoryGroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupFindMany) with()                  {}
func (r categoryGroupFindMany) categoryGroupModel()    {}
func (r categoryGroupFindMany) categoryGroupRelation() {}

func (r categoryGroupActions) FindMany(
	params ...CategoryGroupWhereParam,
) categoryGroupFindMany {
	var v categoryGroupFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "CategoryGroup"
	v.query.Outputs = categoryGroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryGroupFindMany) With(params ...CategoryGroupRelationWith) categoryGroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupFindMany) Select(params ...categoryGroupPrismaFields) categoryGroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupFindMany) Omit(params ...categoryGroupPrismaFields) categoryGroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupFindMany) OrderBy(params ...CategoryGroupOrderByParam) categoryGroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupFindMany) Skip(count int) categoryGroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupFindMany) Take(count int) categoryGroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupFindMany) Cursor(cursor CategoryGroupCursorParam) categoryGroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupFindMany) Exec(ctx context.Context) (
	[]CategoryGroupModel,
	error,
) {
	var v []CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupFindMany) ExecInner(ctx context.Context) (
	[]InnerCategoryGroup,
	error,
) {
	var v []InnerCategoryGroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupFindMany) Update(params ...CategoryGroupSetParam) categoryGroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "CategoryGroup"

	r.query.Outputs = countOutput

	var v categoryGroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupUpdateMany struct {
	query builder.Query
}

func (r categoryGroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupUpdateMany) categoryGroupModel() {}

func (r categoryGroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupUpdateMany) Tx() CategoryGroupManyTxResult {
	v := newCategoryGroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupFindMany) Delete() categoryGroupDeleteMany {
	var v categoryGroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "CategoryGroup"

	v.query.Outputs = countOutput

	return v
}

type categoryGroupDeleteMany struct {
	query builder.Query
}

func (r categoryGroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupDeleteMany) categoryGroupModel() {}

func (r categoryGroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupDeleteMany) Tx() CategoryGroupManyTxResult {
	v := newCategoryGroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupCategoryToCategoryFindUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryFindUnique) with()                          {}
func (r categoryGroupCategoryToCategoryFindUnique) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryToCategoryFindUnique) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryToCategoryFindUnique) With(params ...CategoryRelationWith) categoryGroupCategoryToCategoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryToCategoryFindUnique) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryFindUnique) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryFindUnique) Exec(ctx context.Context) (
	*CategoryGroupCategoryModel,
	error,
) {
	var v *CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryFindUnique) ExecInner(ctx context.Context) (
	*InnerCategoryGroupCategory,
	error,
) {
	var v *InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryFindUnique) Update(params ...CategoryGroupCategorySetParam) categoryGroupCategoryToCategoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "CategoryGroupCategory"

	var v categoryGroupCategoryToCategoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupCategoryToCategoryUpdateUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryUpdateUnique) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryUpdateUnique) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryUpdateUnique) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupCategoryToCategoryFindUnique) Delete() categoryGroupCategoryToCategoryDeleteUnique {
	var v categoryGroupCategoryToCategoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "CategoryGroupCategory"

	return v
}

type categoryGroupCategoryToCategoryDeleteUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupCategoryToCategoryDeleteUnique) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryDeleteUnique) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryDeleteUnique) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupCategoryToCategoryFindFirst struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryFindFirst) with()                          {}
func (r categoryGroupCategoryToCategoryFindFirst) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryToCategoryFindFirst) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryToCategoryFindFirst) With(params ...CategoryRelationWith) categoryGroupCategoryToCategoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryToCategoryFindFirst) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryFindFirst) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryFindFirst) OrderBy(params ...CategoryOrderByParam) categoryGroupCategoryToCategoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupCategoryToCategoryFindFirst) Skip(count int) categoryGroupCategoryToCategoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryFindFirst) Take(count int) categoryGroupCategoryToCategoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryFindFirst) Cursor(cursor CategoryGroupCategoryCursorParam) categoryGroupCategoryToCategoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupCategoryToCategoryFindFirst) Exec(ctx context.Context) (
	*CategoryGroupCategoryModel,
	error,
) {
	var v *CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryFindFirst) ExecInner(ctx context.Context) (
	*InnerCategoryGroupCategory,
	error,
) {
	var v *InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type categoryGroupCategoryToCategoryFindMany struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryFindMany) with()                          {}
func (r categoryGroupCategoryToCategoryFindMany) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryToCategoryFindMany) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryToCategoryFindMany) With(params ...CategoryRelationWith) categoryGroupCategoryToCategoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryToCategoryFindMany) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryFindMany) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryFindMany) OrderBy(params ...CategoryOrderByParam) categoryGroupCategoryToCategoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupCategoryToCategoryFindMany) Skip(count int) categoryGroupCategoryToCategoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryFindMany) Take(count int) categoryGroupCategoryToCategoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryFindMany) Cursor(cursor CategoryGroupCategoryCursorParam) categoryGroupCategoryToCategoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupCategoryToCategoryFindMany) Exec(ctx context.Context) (
	[]CategoryGroupCategoryModel,
	error,
) {
	var v []CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryFindMany) ExecInner(ctx context.Context) (
	[]InnerCategoryGroupCategory,
	error,
) {
	var v []InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryFindMany) Update(params ...CategoryGroupCategorySetParam) categoryGroupCategoryToCategoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "CategoryGroupCategory"

	r.query.Outputs = countOutput

	var v categoryGroupCategoryToCategoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupCategoryToCategoryUpdateMany struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryUpdateMany) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryUpdateMany) Tx() CategoryGroupCategoryManyTxResult {
	v := newCategoryGroupCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupCategoryToCategoryFindMany) Delete() categoryGroupCategoryToCategoryDeleteMany {
	var v categoryGroupCategoryToCategoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "CategoryGroupCategory"

	v.query.Outputs = countOutput

	return v
}

type categoryGroupCategoryToCategoryDeleteMany struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupCategoryToCategoryDeleteMany) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryDeleteMany) Tx() CategoryGroupCategoryManyTxResult {
	v := newCategoryGroupCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupCategoryToCategoryGroupFindUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) with()                          {}
func (r categoryGroupCategoryToCategoryGroupFindUnique) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryToCategoryGroupFindUnique) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryToCategoryGroupFindUnique) With(params ...CategoryGroupRelationWith) categoryGroupCategoryToCategoryGroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryGroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryGroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) Exec(ctx context.Context) (
	*CategoryGroupCategoryModel,
	error,
) {
	var v *CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) ExecInner(ctx context.Context) (
	*InnerCategoryGroupCategory,
	error,
) {
	var v *InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) Update(params ...CategoryGroupCategorySetParam) categoryGroupCategoryToCategoryGroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "CategoryGroupCategory"

	var v categoryGroupCategoryToCategoryGroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupCategoryToCategoryGroupUpdateUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryGroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupUpdateUnique) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryGroupUpdateUnique) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryGroupUpdateUnique) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupCategoryToCategoryGroupFindUnique) Delete() categoryGroupCategoryToCategoryGroupDeleteUnique {
	var v categoryGroupCategoryToCategoryGroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "CategoryGroupCategory"

	return v
}

type categoryGroupCategoryToCategoryGroupDeleteUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryGroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupCategoryToCategoryGroupDeleteUnique) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryGroupDeleteUnique) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryGroupDeleteUnique) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupCategoryToCategoryGroupFindFirst struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) with()                          {}
func (r categoryGroupCategoryToCategoryGroupFindFirst) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryToCategoryGroupFindFirst) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryToCategoryGroupFindFirst) With(params ...CategoryGroupRelationWith) categoryGroupCategoryToCategoryGroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryGroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryGroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) OrderBy(params ...CategoryGroupOrderByParam) categoryGroupCategoryToCategoryGroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) Skip(count int) categoryGroupCategoryToCategoryGroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) Take(count int) categoryGroupCategoryToCategoryGroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) Cursor(cursor CategoryGroupCategoryCursorParam) categoryGroupCategoryToCategoryGroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) Exec(ctx context.Context) (
	*CategoryGroupCategoryModel,
	error,
) {
	var v *CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryGroupFindFirst) ExecInner(ctx context.Context) (
	*InnerCategoryGroupCategory,
	error,
) {
	var v *InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type categoryGroupCategoryToCategoryGroupFindMany struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryGroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupFindMany) with()                          {}
func (r categoryGroupCategoryToCategoryGroupFindMany) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryToCategoryGroupFindMany) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryToCategoryGroupFindMany) With(params ...CategoryGroupRelationWith) categoryGroupCategoryToCategoryGroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryGroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryToCategoryGroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindMany) OrderBy(params ...CategoryGroupOrderByParam) categoryGroupCategoryToCategoryGroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Skip(count int) categoryGroupCategoryToCategoryGroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Take(count int) categoryGroupCategoryToCategoryGroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Cursor(cursor CategoryGroupCategoryCursorParam) categoryGroupCategoryToCategoryGroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Exec(ctx context.Context) (
	[]CategoryGroupCategoryModel,
	error,
) {
	var v []CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryGroupFindMany) ExecInner(ctx context.Context) (
	[]InnerCategoryGroupCategory,
	error,
) {
	var v []InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Update(params ...CategoryGroupCategorySetParam) categoryGroupCategoryToCategoryGroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "CategoryGroupCategory"

	r.query.Outputs = countOutput

	var v categoryGroupCategoryToCategoryGroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupCategoryToCategoryGroupUpdateMany struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryGroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryToCategoryGroupUpdateMany) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryGroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryGroupUpdateMany) Tx() CategoryGroupCategoryManyTxResult {
	v := newCategoryGroupCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupCategoryToCategoryGroupFindMany) Delete() categoryGroupCategoryToCategoryGroupDeleteMany {
	var v categoryGroupCategoryToCategoryGroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "CategoryGroupCategory"

	v.query.Outputs = countOutput

	return v
}

type categoryGroupCategoryToCategoryGroupDeleteMany struct {
	query builder.Query
}

func (r categoryGroupCategoryToCategoryGroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupCategoryToCategoryGroupDeleteMany) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryToCategoryGroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryToCategoryGroupDeleteMany) Tx() CategoryGroupCategoryManyTxResult {
	v := newCategoryGroupCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupCategoryFindUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryFindUnique) with()                          {}
func (r categoryGroupCategoryFindUnique) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryFindUnique) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryActions) FindUnique(
	params CategoryGroupCategoryEqualsUniqueWhereParam,
) categoryGroupCategoryFindUnique {
	var v categoryGroupCategoryFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "CategoryGroupCategory"
	v.query.Outputs = categoryGroupCategoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r categoryGroupCategoryFindUnique) With(params ...CategoryGroupCategoryRelationWith) categoryGroupCategoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryFindUnique) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryFindUnique) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryFindUnique) Exec(ctx context.Context) (
	*CategoryGroupCategoryModel,
	error,
) {
	var v *CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryFindUnique) ExecInner(ctx context.Context) (
	*InnerCategoryGroupCategory,
	error,
) {
	var v *InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryFindUnique) Update(params ...CategoryGroupCategorySetParam) categoryGroupCategoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "CategoryGroupCategory"

	var v categoryGroupCategoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupCategoryUpdateUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryUpdateUnique) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryUpdateUnique) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryUpdateUnique) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupCategoryFindUnique) Delete() categoryGroupCategoryDeleteUnique {
	var v categoryGroupCategoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "CategoryGroupCategory"

	return v
}

type categoryGroupCategoryDeleteUnique struct {
	query builder.Query
}

func (r categoryGroupCategoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupCategoryDeleteUnique) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryDeleteUnique) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryDeleteUnique) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupCategoryFindFirst struct {
	query builder.Query
}

func (r categoryGroupCategoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryFindFirst) with()                          {}
func (r categoryGroupCategoryFindFirst) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryFindFirst) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryActions) FindFirst(
	params ...CategoryGroupCategoryWhereParam,
) categoryGroupCategoryFindFirst {
	var v categoryGroupCategoryFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "CategoryGroupCategory"
	v.query.Outputs = categoryGroupCategoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryGroupCategoryFindFirst) With(params ...CategoryGroupCategoryRelationWith) categoryGroupCategoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryFindFirst) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryFindFirst) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryFindFirst) OrderBy(params ...CategoryGroupCategoryOrderByParam) categoryGroupCategoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupCategoryFindFirst) Skip(count int) categoryGroupCategoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryFindFirst) Take(count int) categoryGroupCategoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryFindFirst) Cursor(cursor CategoryGroupCategoryCursorParam) categoryGroupCategoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupCategoryFindFirst) Exec(ctx context.Context) (
	*CategoryGroupCategoryModel,
	error,
) {
	var v *CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r categoryGroupCategoryFindFirst) ExecInner(ctx context.Context) (
	*InnerCategoryGroupCategory,
	error,
) {
	var v *InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type categoryGroupCategoryFindMany struct {
	query builder.Query
}

func (r categoryGroupCategoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryFindMany) with()                          {}
func (r categoryGroupCategoryFindMany) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryFindMany) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryActions) FindMany(
	params ...CategoryGroupCategoryWhereParam,
) categoryGroupCategoryFindMany {
	var v categoryGroupCategoryFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "CategoryGroupCategory"
	v.query.Outputs = categoryGroupCategoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r categoryGroupCategoryFindMany) With(params ...CategoryGroupCategoryRelationWith) categoryGroupCategoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r categoryGroupCategoryFindMany) Select(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryFindMany) Omit(params ...categoryGroupCategoryPrismaFields) categoryGroupCategoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range categoryGroupCategoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r categoryGroupCategoryFindMany) OrderBy(params ...CategoryGroupCategoryOrderByParam) categoryGroupCategoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r categoryGroupCategoryFindMany) Skip(count int) categoryGroupCategoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryFindMany) Take(count int) categoryGroupCategoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r categoryGroupCategoryFindMany) Cursor(cursor CategoryGroupCategoryCursorParam) categoryGroupCategoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r categoryGroupCategoryFindMany) Exec(ctx context.Context) (
	[]CategoryGroupCategoryModel,
	error,
) {
	var v []CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupCategoryFindMany) ExecInner(ctx context.Context) (
	[]InnerCategoryGroupCategory,
	error,
) {
	var v []InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r categoryGroupCategoryFindMany) Update(params ...CategoryGroupCategorySetParam) categoryGroupCategoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "CategoryGroupCategory"

	r.query.Outputs = countOutput

	var v categoryGroupCategoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type categoryGroupCategoryUpdateMany struct {
	query builder.Query
}

func (r categoryGroupCategoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryUpdateMany) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryUpdateMany) Tx() CategoryGroupCategoryManyTxResult {
	v := newCategoryGroupCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r categoryGroupCategoryFindMany) Delete() categoryGroupCategoryDeleteMany {
	var v categoryGroupCategoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "CategoryGroupCategory"

	v.query.Outputs = countOutput

	return v
}

type categoryGroupCategoryDeleteMany struct {
	query builder.Query
}

func (r categoryGroupCategoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p categoryGroupCategoryDeleteMany) categoryGroupCategoryModel() {}

func (r categoryGroupCategoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryDeleteMany) Tx() CategoryGroupCategoryManyTxResult {
	v := newCategoryGroupCategoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeToUserStoreFindUnique struct {
	query builder.Query
}

func (r storeToUserStoreFindUnique) getQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreFindUnique) with()          {}
func (r storeToUserStoreFindUnique) storeModel()    {}
func (r storeToUserStoreFindUnique) storeRelation() {}

func (r storeToUserStoreFindUnique) With(params ...UserStoreRelationWith) storeToUserStoreFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeToUserStoreFindUnique) Select(params ...storePrismaFields) storeToUserStoreFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeToUserStoreFindUnique) Omit(params ...storePrismaFields) storeToUserStoreFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeToUserStoreFindUnique) Exec(ctx context.Context) (
	*StoreModel,
	error,
) {
	var v *StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeToUserStoreFindUnique) ExecInner(ctx context.Context) (
	*InnerStore,
	error,
) {
	var v *InnerStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeToUserStoreFindUnique) Update(params ...StoreSetParam) storeToUserStoreUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Store"

	var v storeToUserStoreUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type storeToUserStoreUpdateUnique struct {
	query builder.Query
}

func (r storeToUserStoreUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreUpdateUnique) storeModel() {}

func (r storeToUserStoreUpdateUnique) Exec(ctx context.Context) (*StoreModel, error) {
	var v StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeToUserStoreUpdateUnique) Tx() StoreUniqueTxResult {
	v := newStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r storeToUserStoreFindUnique) Delete() storeToUserStoreDeleteUnique {
	var v storeToUserStoreDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Store"

	return v
}

type storeToUserStoreDeleteUnique struct {
	query builder.Query
}

func (r storeToUserStoreDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p storeToUserStoreDeleteUnique) storeModel() {}

func (r storeToUserStoreDeleteUnique) Exec(ctx context.Context) (*StoreModel, error) {
	var v StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeToUserStoreDeleteUnique) Tx() StoreUniqueTxResult {
	v := newStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeToUserStoreFindFirst struct {
	query builder.Query
}

func (r storeToUserStoreFindFirst) getQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreFindFirst) with()          {}
func (r storeToUserStoreFindFirst) storeModel()    {}
func (r storeToUserStoreFindFirst) storeRelation() {}

func (r storeToUserStoreFindFirst) With(params ...UserStoreRelationWith) storeToUserStoreFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeToUserStoreFindFirst) Select(params ...storePrismaFields) storeToUserStoreFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeToUserStoreFindFirst) Omit(params ...storePrismaFields) storeToUserStoreFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeToUserStoreFindFirst) OrderBy(params ...UserStoreOrderByParam) storeToUserStoreFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r storeToUserStoreFindFirst) Skip(count int) storeToUserStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r storeToUserStoreFindFirst) Take(count int) storeToUserStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r storeToUserStoreFindFirst) Cursor(cursor StoreCursorParam) storeToUserStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r storeToUserStoreFindFirst) Exec(ctx context.Context) (
	*StoreModel,
	error,
) {
	var v *StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeToUserStoreFindFirst) ExecInner(ctx context.Context) (
	*InnerStore,
	error,
) {
	var v *InnerStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type storeToUserStoreFindMany struct {
	query builder.Query
}

func (r storeToUserStoreFindMany) getQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreFindMany) with()          {}
func (r storeToUserStoreFindMany) storeModel()    {}
func (r storeToUserStoreFindMany) storeRelation() {}

func (r storeToUserStoreFindMany) With(params ...UserStoreRelationWith) storeToUserStoreFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeToUserStoreFindMany) Select(params ...storePrismaFields) storeToUserStoreFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeToUserStoreFindMany) Omit(params ...storePrismaFields) storeToUserStoreFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeToUserStoreFindMany) OrderBy(params ...UserStoreOrderByParam) storeToUserStoreFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r storeToUserStoreFindMany) Skip(count int) storeToUserStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r storeToUserStoreFindMany) Take(count int) storeToUserStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r storeToUserStoreFindMany) Cursor(cursor StoreCursorParam) storeToUserStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r storeToUserStoreFindMany) Exec(ctx context.Context) (
	[]StoreModel,
	error,
) {
	var v []StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r storeToUserStoreFindMany) ExecInner(ctx context.Context) (
	[]InnerStore,
	error,
) {
	var v []InnerStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r storeToUserStoreFindMany) Update(params ...StoreSetParam) storeToUserStoreUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Store"

	r.query.Outputs = countOutput

	var v storeToUserStoreUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type storeToUserStoreUpdateMany struct {
	query builder.Query
}

func (r storeToUserStoreUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r storeToUserStoreUpdateMany) storeModel() {}

func (r storeToUserStoreUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeToUserStoreUpdateMany) Tx() StoreManyTxResult {
	v := newStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r storeToUserStoreFindMany) Delete() storeToUserStoreDeleteMany {
	var v storeToUserStoreDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Store"

	v.query.Outputs = countOutput

	return v
}

type storeToUserStoreDeleteMany struct {
	query builder.Query
}

func (r storeToUserStoreDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p storeToUserStoreDeleteMany) storeModel() {}

func (r storeToUserStoreDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeToUserStoreDeleteMany) Tx() StoreManyTxResult {
	v := newStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeFindUnique struct {
	query builder.Query
}

func (r storeFindUnique) getQuery() builder.Query {
	return r.query
}

func (r storeFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r storeFindUnique) with()          {}
func (r storeFindUnique) storeModel()    {}
func (r storeFindUnique) storeRelation() {}

func (r storeActions) FindUnique(
	params StoreEqualsUniqueWhereParam,
) storeFindUnique {
	var v storeFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Store"
	v.query.Outputs = storeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r storeFindUnique) With(params ...StoreRelationWith) storeFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeFindUnique) Select(params ...storePrismaFields) storeFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeFindUnique) Omit(params ...storePrismaFields) storeFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeFindUnique) Exec(ctx context.Context) (
	*StoreModel,
	error,
) {
	var v *StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeFindUnique) ExecInner(ctx context.Context) (
	*InnerStore,
	error,
) {
	var v *InnerStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeFindUnique) Update(params ...StoreSetParam) storeUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Store"

	var v storeUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type storeUpdateUnique struct {
	query builder.Query
}

func (r storeUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r storeUpdateUnique) storeModel() {}

func (r storeUpdateUnique) Exec(ctx context.Context) (*StoreModel, error) {
	var v StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeUpdateUnique) Tx() StoreUniqueTxResult {
	v := newStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r storeFindUnique) Delete() storeDeleteUnique {
	var v storeDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Store"

	return v
}

type storeDeleteUnique struct {
	query builder.Query
}

func (r storeDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p storeDeleteUnique) storeModel() {}

func (r storeDeleteUnique) Exec(ctx context.Context) (*StoreModel, error) {
	var v StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeDeleteUnique) Tx() StoreUniqueTxResult {
	v := newStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeFindFirst struct {
	query builder.Query
}

func (r storeFindFirst) getQuery() builder.Query {
	return r.query
}

func (r storeFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r storeFindFirst) with()          {}
func (r storeFindFirst) storeModel()    {}
func (r storeFindFirst) storeRelation() {}

func (r storeActions) FindFirst(
	params ...StoreWhereParam,
) storeFindFirst {
	var v storeFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Store"
	v.query.Outputs = storeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r storeFindFirst) With(params ...StoreRelationWith) storeFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeFindFirst) Select(params ...storePrismaFields) storeFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeFindFirst) Omit(params ...storePrismaFields) storeFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeFindFirst) OrderBy(params ...StoreOrderByParam) storeFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r storeFindFirst) Skip(count int) storeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r storeFindFirst) Take(count int) storeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r storeFindFirst) Cursor(cursor StoreCursorParam) storeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r storeFindFirst) Exec(ctx context.Context) (
	*StoreModel,
	error,
) {
	var v *StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeFindFirst) ExecInner(ctx context.Context) (
	*InnerStore,
	error,
) {
	var v *InnerStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type storeFindMany struct {
	query builder.Query
}

func (r storeFindMany) getQuery() builder.Query {
	return r.query
}

func (r storeFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r storeFindMany) with()          {}
func (r storeFindMany) storeModel()    {}
func (r storeFindMany) storeRelation() {}

func (r storeActions) FindMany(
	params ...StoreWhereParam,
) storeFindMany {
	var v storeFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Store"
	v.query.Outputs = storeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r storeFindMany) With(params ...StoreRelationWith) storeFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeFindMany) Select(params ...storePrismaFields) storeFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeFindMany) Omit(params ...storePrismaFields) storeFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeFindMany) OrderBy(params ...StoreOrderByParam) storeFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r storeFindMany) Skip(count int) storeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r storeFindMany) Take(count int) storeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r storeFindMany) Cursor(cursor StoreCursorParam) storeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r storeFindMany) Exec(ctx context.Context) (
	[]StoreModel,
	error,
) {
	var v []StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r storeFindMany) ExecInner(ctx context.Context) (
	[]InnerStore,
	error,
) {
	var v []InnerStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r storeFindMany) Update(params ...StoreSetParam) storeUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Store"

	r.query.Outputs = countOutput

	var v storeUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type storeUpdateMany struct {
	query builder.Query
}

func (r storeUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r storeUpdateMany) storeModel() {}

func (r storeUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeUpdateMany) Tx() StoreManyTxResult {
	v := newStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r storeFindMany) Delete() storeDeleteMany {
	var v storeDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Store"

	v.query.Outputs = countOutput

	return v
}

type storeDeleteMany struct {
	query builder.Query
}

func (r storeDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p storeDeleteMany) storeModel() {}

func (r storeDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeDeleteMany) Tx() StoreManyTxResult {
	v := newStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userStoreToStoreFindUnique struct {
	query builder.Query
}

func (r userStoreToStoreFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreFindUnique) with()              {}
func (r userStoreToStoreFindUnique) userStoreModel()    {}
func (r userStoreToStoreFindUnique) userStoreRelation() {}

func (r userStoreToStoreFindUnique) With(params ...StoreRelationWith) userStoreToStoreFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userStoreToStoreFindUnique) Select(params ...userStorePrismaFields) userStoreToStoreFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreToStoreFindUnique) Omit(params ...userStorePrismaFields) userStoreToStoreFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userStoreOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreToStoreFindUnique) Exec(ctx context.Context) (
	*UserStoreModel,
	error,
) {
	var v *UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userStoreToStoreFindUnique) ExecInner(ctx context.Context) (
	*InnerUserStore,
	error,
) {
	var v *InnerUserStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userStoreToStoreFindUnique) Update(params ...UserStoreSetParam) userStoreToStoreUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "UserStore"

	var v userStoreToStoreUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userStoreToStoreUpdateUnique struct {
	query builder.Query
}

func (r userStoreToStoreUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreUpdateUnique) userStoreModel() {}

func (r userStoreToStoreUpdateUnique) Exec(ctx context.Context) (*UserStoreModel, error) {
	var v UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreToStoreUpdateUnique) Tx() UserStoreUniqueTxResult {
	v := newUserStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userStoreToStoreFindUnique) Delete() userStoreToStoreDeleteUnique {
	var v userStoreToStoreDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "UserStore"

	return v
}

type userStoreToStoreDeleteUnique struct {
	query builder.Query
}

func (r userStoreToStoreDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userStoreToStoreDeleteUnique) userStoreModel() {}

func (r userStoreToStoreDeleteUnique) Exec(ctx context.Context) (*UserStoreModel, error) {
	var v UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreToStoreDeleteUnique) Tx() UserStoreUniqueTxResult {
	v := newUserStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userStoreToStoreFindFirst struct {
	query builder.Query
}

func (r userStoreToStoreFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreFindFirst) with()              {}
func (r userStoreToStoreFindFirst) userStoreModel()    {}
func (r userStoreToStoreFindFirst) userStoreRelation() {}

func (r userStoreToStoreFindFirst) With(params ...StoreRelationWith) userStoreToStoreFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userStoreToStoreFindFirst) Select(params ...userStorePrismaFields) userStoreToStoreFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreToStoreFindFirst) Omit(params ...userStorePrismaFields) userStoreToStoreFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userStoreOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreToStoreFindFirst) OrderBy(params ...StoreOrderByParam) userStoreToStoreFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userStoreToStoreFindFirst) Skip(count int) userStoreToStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userStoreToStoreFindFirst) Take(count int) userStoreToStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userStoreToStoreFindFirst) Cursor(cursor UserStoreCursorParam) userStoreToStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userStoreToStoreFindFirst) Exec(ctx context.Context) (
	*UserStoreModel,
	error,
) {
	var v *UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userStoreToStoreFindFirst) ExecInner(ctx context.Context) (
	*InnerUserStore,
	error,
) {
	var v *InnerUserStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userStoreToStoreFindMany struct {
	query builder.Query
}

func (r userStoreToStoreFindMany) getQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreFindMany) with()              {}
func (r userStoreToStoreFindMany) userStoreModel()    {}
func (r userStoreToStoreFindMany) userStoreRelation() {}

func (r userStoreToStoreFindMany) With(params ...StoreRelationWith) userStoreToStoreFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userStoreToStoreFindMany) Select(params ...userStorePrismaFields) userStoreToStoreFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreToStoreFindMany) Omit(params ...userStorePrismaFields) userStoreToStoreFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userStoreOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreToStoreFindMany) OrderBy(params ...StoreOrderByParam) userStoreToStoreFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userStoreToStoreFindMany) Skip(count int) userStoreToStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userStoreToStoreFindMany) Take(count int) userStoreToStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userStoreToStoreFindMany) Cursor(cursor UserStoreCursorParam) userStoreToStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userStoreToStoreFindMany) Exec(ctx context.Context) (
	[]UserStoreModel,
	error,
) {
	var v []UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userStoreToStoreFindMany) ExecInner(ctx context.Context) (
	[]InnerUserStore,
	error,
) {
	var v []InnerUserStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userStoreToStoreFindMany) Update(params ...UserStoreSetParam) userStoreToStoreUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "UserStore"

	r.query.Outputs = countOutput

	var v userStoreToStoreUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userStoreToStoreUpdateMany struct {
	query builder.Query
}

func (r userStoreToStoreUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreToStoreUpdateMany) userStoreModel() {}

func (r userStoreToStoreUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreToStoreUpdateMany) Tx() UserStoreManyTxResult {
	v := newUserStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userStoreToStoreFindMany) Delete() userStoreToStoreDeleteMany {
	var v userStoreToStoreDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "UserStore"

	v.query.Outputs = countOutput

	return v
}

type userStoreToStoreDeleteMany struct {
	query builder.Query
}

func (r userStoreToStoreDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userStoreToStoreDeleteMany) userStoreModel() {}

func (r userStoreToStoreDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreToStoreDeleteMany) Tx() UserStoreManyTxResult {
	v := newUserStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userStoreFindUnique struct {
	query builder.Query
}

func (r userStoreFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userStoreFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreFindUnique) with()              {}
func (r userStoreFindUnique) userStoreModel()    {}
func (r userStoreFindUnique) userStoreRelation() {}

func (r userStoreActions) FindUnique(
	params UserStoreEqualsUniqueWhereParam,
) userStoreFindUnique {
	var v userStoreFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "UserStore"
	v.query.Outputs = userStoreOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userStoreFindUnique) With(params ...UserStoreRelationWith) userStoreFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userStoreFindUnique) Select(params ...userStorePrismaFields) userStoreFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreFindUnique) Omit(params ...userStorePrismaFields) userStoreFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userStoreOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreFindUnique) Exec(ctx context.Context) (
	*UserStoreModel,
	error,
) {
	var v *UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userStoreFindUnique) ExecInner(ctx context.Context) (
	*InnerUserStore,
	error,
) {
	var v *InnerUserStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userStoreFindUnique) Update(params ...UserStoreSetParam) userStoreUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "UserStore"

	var v userStoreUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userStoreUpdateUnique struct {
	query builder.Query
}

func (r userStoreUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreUpdateUnique) userStoreModel() {}

func (r userStoreUpdateUnique) Exec(ctx context.Context) (*UserStoreModel, error) {
	var v UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreUpdateUnique) Tx() UserStoreUniqueTxResult {
	v := newUserStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userStoreFindUnique) Delete() userStoreDeleteUnique {
	var v userStoreDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "UserStore"

	return v
}

type userStoreDeleteUnique struct {
	query builder.Query
}

func (r userStoreDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userStoreDeleteUnique) userStoreModel() {}

func (r userStoreDeleteUnique) Exec(ctx context.Context) (*UserStoreModel, error) {
	var v UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreDeleteUnique) Tx() UserStoreUniqueTxResult {
	v := newUserStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userStoreFindFirst struct {
	query builder.Query
}

func (r userStoreFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userStoreFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreFindFirst) with()              {}
func (r userStoreFindFirst) userStoreModel()    {}
func (r userStoreFindFirst) userStoreRelation() {}

func (r userStoreActions) FindFirst(
	params ...UserStoreWhereParam,
) userStoreFindFirst {
	var v userStoreFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "UserStore"
	v.query.Outputs = userStoreOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userStoreFindFirst) With(params ...UserStoreRelationWith) userStoreFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userStoreFindFirst) Select(params ...userStorePrismaFields) userStoreFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreFindFirst) Omit(params ...userStorePrismaFields) userStoreFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userStoreOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreFindFirst) OrderBy(params ...UserStoreOrderByParam) userStoreFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userStoreFindFirst) Skip(count int) userStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userStoreFindFirst) Take(count int) userStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userStoreFindFirst) Cursor(cursor UserStoreCursorParam) userStoreFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userStoreFindFirst) Exec(ctx context.Context) (
	*UserStoreModel,
	error,
) {
	var v *UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userStoreFindFirst) ExecInner(ctx context.Context) (
	*InnerUserStore,
	error,
) {
	var v *InnerUserStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userStoreFindMany struct {
	query builder.Query
}

func (r userStoreFindMany) getQuery() builder.Query {
	return r.query
}

func (r userStoreFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreFindMany) with()              {}
func (r userStoreFindMany) userStoreModel()    {}
func (r userStoreFindMany) userStoreRelation() {}

func (r userStoreActions) FindMany(
	params ...UserStoreWhereParam,
) userStoreFindMany {
	var v userStoreFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "UserStore"
	v.query.Outputs = userStoreOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userStoreFindMany) With(params ...UserStoreRelationWith) userStoreFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userStoreFindMany) Select(params ...userStorePrismaFields) userStoreFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreFindMany) Omit(params ...userStorePrismaFields) userStoreFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userStoreOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userStoreFindMany) OrderBy(params ...UserStoreOrderByParam) userStoreFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userStoreFindMany) Skip(count int) userStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userStoreFindMany) Take(count int) userStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userStoreFindMany) Cursor(cursor UserStoreCursorParam) userStoreFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userStoreFindMany) Exec(ctx context.Context) (
	[]UserStoreModel,
	error,
) {
	var v []UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userStoreFindMany) ExecInner(ctx context.Context) (
	[]InnerUserStore,
	error,
) {
	var v []InnerUserStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userStoreFindMany) Update(params ...UserStoreSetParam) userStoreUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "UserStore"

	r.query.Outputs = countOutput

	var v userStoreUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userStoreUpdateMany struct {
	query builder.Query
}

func (r userStoreUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreUpdateMany) userStoreModel() {}

func (r userStoreUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreUpdateMany) Tx() UserStoreManyTxResult {
	v := newUserStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userStoreFindMany) Delete() userStoreDeleteMany {
	var v userStoreDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "UserStore"

	v.query.Outputs = countOutput

	return v
}

type userStoreDeleteMany struct {
	query builder.Query
}

func (r userStoreDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userStoreDeleteMany) userStoreModel() {}

func (r userStoreDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreDeleteMany) Tx() UserStoreManyTxResult {
	v := newUserStoreManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type holidayFindUnique struct {
	query builder.Query
}

func (r holidayFindUnique) getQuery() builder.Query {
	return r.query
}

func (r holidayFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r holidayFindUnique) with()            {}
func (r holidayFindUnique) holidayModel()    {}
func (r holidayFindUnique) holidayRelation() {}

func (r holidayActions) FindUnique(
	params HolidayEqualsUniqueWhereParam,
) holidayFindUnique {
	var v holidayFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Holiday"
	v.query.Outputs = holidayOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r holidayFindUnique) With(params ...HolidayRelationWith) holidayFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r holidayFindUnique) Select(params ...holidayPrismaFields) holidayFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r holidayFindUnique) Omit(params ...holidayPrismaFields) holidayFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range holidayOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r holidayFindUnique) Exec(ctx context.Context) (
	*HolidayModel,
	error,
) {
	var v *HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r holidayFindUnique) ExecInner(ctx context.Context) (
	*InnerHoliday,
	error,
) {
	var v *InnerHoliday
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r holidayFindUnique) Update(params ...HolidaySetParam) holidayUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Holiday"

	var v holidayUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type holidayUpdateUnique struct {
	query builder.Query
}

func (r holidayUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r holidayUpdateUnique) holidayModel() {}

func (r holidayUpdateUnique) Exec(ctx context.Context) (*HolidayModel, error) {
	var v HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r holidayUpdateUnique) Tx() HolidayUniqueTxResult {
	v := newHolidayUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r holidayFindUnique) Delete() holidayDeleteUnique {
	var v holidayDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Holiday"

	return v
}

type holidayDeleteUnique struct {
	query builder.Query
}

func (r holidayDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p holidayDeleteUnique) holidayModel() {}

func (r holidayDeleteUnique) Exec(ctx context.Context) (*HolidayModel, error) {
	var v HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r holidayDeleteUnique) Tx() HolidayUniqueTxResult {
	v := newHolidayUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type holidayFindFirst struct {
	query builder.Query
}

func (r holidayFindFirst) getQuery() builder.Query {
	return r.query
}

func (r holidayFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r holidayFindFirst) with()            {}
func (r holidayFindFirst) holidayModel()    {}
func (r holidayFindFirst) holidayRelation() {}

func (r holidayActions) FindFirst(
	params ...HolidayWhereParam,
) holidayFindFirst {
	var v holidayFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Holiday"
	v.query.Outputs = holidayOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r holidayFindFirst) With(params ...HolidayRelationWith) holidayFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r holidayFindFirst) Select(params ...holidayPrismaFields) holidayFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r holidayFindFirst) Omit(params ...holidayPrismaFields) holidayFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range holidayOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r holidayFindFirst) OrderBy(params ...HolidayOrderByParam) holidayFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r holidayFindFirst) Skip(count int) holidayFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r holidayFindFirst) Take(count int) holidayFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r holidayFindFirst) Cursor(cursor HolidayCursorParam) holidayFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r holidayFindFirst) Exec(ctx context.Context) (
	*HolidayModel,
	error,
) {
	var v *HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r holidayFindFirst) ExecInner(ctx context.Context) (
	*InnerHoliday,
	error,
) {
	var v *InnerHoliday
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type holidayFindMany struct {
	query builder.Query
}

func (r holidayFindMany) getQuery() builder.Query {
	return r.query
}

func (r holidayFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r holidayFindMany) with()            {}
func (r holidayFindMany) holidayModel()    {}
func (r holidayFindMany) holidayRelation() {}

func (r holidayActions) FindMany(
	params ...HolidayWhereParam,
) holidayFindMany {
	var v holidayFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Holiday"
	v.query.Outputs = holidayOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r holidayFindMany) With(params ...HolidayRelationWith) holidayFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r holidayFindMany) Select(params ...holidayPrismaFields) holidayFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r holidayFindMany) Omit(params ...holidayPrismaFields) holidayFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range holidayOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r holidayFindMany) OrderBy(params ...HolidayOrderByParam) holidayFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r holidayFindMany) Skip(count int) holidayFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r holidayFindMany) Take(count int) holidayFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r holidayFindMany) Cursor(cursor HolidayCursorParam) holidayFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r holidayFindMany) Exec(ctx context.Context) (
	[]HolidayModel,
	error,
) {
	var v []HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r holidayFindMany) ExecInner(ctx context.Context) (
	[]InnerHoliday,
	error,
) {
	var v []InnerHoliday
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r holidayFindMany) Update(params ...HolidaySetParam) holidayUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Holiday"

	r.query.Outputs = countOutput

	var v holidayUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type holidayUpdateMany struct {
	query builder.Query
}

func (r holidayUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r holidayUpdateMany) holidayModel() {}

func (r holidayUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r holidayUpdateMany) Tx() HolidayManyTxResult {
	v := newHolidayManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r holidayFindMany) Delete() holidayDeleteMany {
	var v holidayDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Holiday"

	v.query.Outputs = countOutput

	return v
}

type holidayDeleteMany struct {
	query builder.Query
}

func (r holidayDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p holidayDeleteMany) holidayModel() {}

func (r holidayDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r holidayDeleteMany) Tx() HolidayManyTxResult {
	v := newHolidayManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeStatusFindUnique struct {
	query builder.Query
}

func (r storeStatusFindUnique) getQuery() builder.Query {
	return r.query
}

func (r storeStatusFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r storeStatusFindUnique) with()                {}
func (r storeStatusFindUnique) storeStatusModel()    {}
func (r storeStatusFindUnique) storeStatusRelation() {}

func (r storeStatusActions) FindUnique(
	params StoreStatusEqualsUniqueWhereParam,
) storeStatusFindUnique {
	var v storeStatusFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "StoreStatus"
	v.query.Outputs = storeStatusOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r storeStatusFindUnique) With(params ...StoreStatusRelationWith) storeStatusFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeStatusFindUnique) Select(params ...storeStatusPrismaFields) storeStatusFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeStatusFindUnique) Omit(params ...storeStatusPrismaFields) storeStatusFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeStatusOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeStatusFindUnique) Exec(ctx context.Context) (
	*StoreStatusModel,
	error,
) {
	var v *StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeStatusFindUnique) ExecInner(ctx context.Context) (
	*InnerStoreStatus,
	error,
) {
	var v *InnerStoreStatus
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeStatusFindUnique) Update(params ...StoreStatusSetParam) storeStatusUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "StoreStatus"

	var v storeStatusUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type storeStatusUpdateUnique struct {
	query builder.Query
}

func (r storeStatusUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r storeStatusUpdateUnique) storeStatusModel() {}

func (r storeStatusUpdateUnique) Exec(ctx context.Context) (*StoreStatusModel, error) {
	var v StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeStatusUpdateUnique) Tx() StoreStatusUniqueTxResult {
	v := newStoreStatusUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r storeStatusFindUnique) Delete() storeStatusDeleteUnique {
	var v storeStatusDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "StoreStatus"

	return v
}

type storeStatusDeleteUnique struct {
	query builder.Query
}

func (r storeStatusDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p storeStatusDeleteUnique) storeStatusModel() {}

func (r storeStatusDeleteUnique) Exec(ctx context.Context) (*StoreStatusModel, error) {
	var v StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeStatusDeleteUnique) Tx() StoreStatusUniqueTxResult {
	v := newStoreStatusUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeStatusFindFirst struct {
	query builder.Query
}

func (r storeStatusFindFirst) getQuery() builder.Query {
	return r.query
}

func (r storeStatusFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r storeStatusFindFirst) with()                {}
func (r storeStatusFindFirst) storeStatusModel()    {}
func (r storeStatusFindFirst) storeStatusRelation() {}

func (r storeStatusActions) FindFirst(
	params ...StoreStatusWhereParam,
) storeStatusFindFirst {
	var v storeStatusFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "StoreStatus"
	v.query.Outputs = storeStatusOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r storeStatusFindFirst) With(params ...StoreStatusRelationWith) storeStatusFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeStatusFindFirst) Select(params ...storeStatusPrismaFields) storeStatusFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeStatusFindFirst) Omit(params ...storeStatusPrismaFields) storeStatusFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeStatusOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeStatusFindFirst) OrderBy(params ...StoreStatusOrderByParam) storeStatusFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r storeStatusFindFirst) Skip(count int) storeStatusFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r storeStatusFindFirst) Take(count int) storeStatusFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r storeStatusFindFirst) Cursor(cursor StoreStatusCursorParam) storeStatusFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r storeStatusFindFirst) Exec(ctx context.Context) (
	*StoreStatusModel,
	error,
) {
	var v *StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r storeStatusFindFirst) ExecInner(ctx context.Context) (
	*InnerStoreStatus,
	error,
) {
	var v *InnerStoreStatus
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type storeStatusFindMany struct {
	query builder.Query
}

func (r storeStatusFindMany) getQuery() builder.Query {
	return r.query
}

func (r storeStatusFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r storeStatusFindMany) with()                {}
func (r storeStatusFindMany) storeStatusModel()    {}
func (r storeStatusFindMany) storeStatusRelation() {}

func (r storeStatusActions) FindMany(
	params ...StoreStatusWhereParam,
) storeStatusFindMany {
	var v storeStatusFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "StoreStatus"
	v.query.Outputs = storeStatusOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r storeStatusFindMany) With(params ...StoreStatusRelationWith) storeStatusFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r storeStatusFindMany) Select(params ...storeStatusPrismaFields) storeStatusFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r storeStatusFindMany) Omit(params ...storeStatusPrismaFields) storeStatusFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range storeStatusOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r storeStatusFindMany) OrderBy(params ...StoreStatusOrderByParam) storeStatusFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r storeStatusFindMany) Skip(count int) storeStatusFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r storeStatusFindMany) Take(count int) storeStatusFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r storeStatusFindMany) Cursor(cursor StoreStatusCursorParam) storeStatusFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r storeStatusFindMany) Exec(ctx context.Context) (
	[]StoreStatusModel,
	error,
) {
	var v []StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r storeStatusFindMany) ExecInner(ctx context.Context) (
	[]InnerStoreStatus,
	error,
) {
	var v []InnerStoreStatus
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r storeStatusFindMany) Update(params ...StoreStatusSetParam) storeStatusUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "StoreStatus"

	r.query.Outputs = countOutput

	var v storeStatusUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type storeStatusUpdateMany struct {
	query builder.Query
}

func (r storeStatusUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r storeStatusUpdateMany) storeStatusModel() {}

func (r storeStatusUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeStatusUpdateMany) Tx() StoreStatusManyTxResult {
	v := newStoreStatusManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r storeStatusFindMany) Delete() storeStatusDeleteMany {
	var v storeStatusDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "StoreStatus"

	v.query.Outputs = countOutput

	return v
}

type storeStatusDeleteMany struct {
	query builder.Query
}

func (r storeStatusDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p storeStatusDeleteMany) storeStatusModel() {}

func (r storeStatusDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeStatusDeleteMany) Tx() StoreStatusManyTxResult {
	v := newStoreStatusManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newUserUniqueTxResult() UserUniqueTxResult {
	return UserUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserUniqueTxResult) IsTx() {}

func (r UserUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserManyTxResult() UserManyTxResult {
	return UserManyTxResult{
		result: &transaction.Result{},
	}
}

type UserManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserManyTxResult) IsTx() {}

func (r UserManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newAccessKeyUniqueTxResult() AccessKeyUniqueTxResult {
	return AccessKeyUniqueTxResult{
		result: &transaction.Result{},
	}
}

type AccessKeyUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p AccessKeyUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p AccessKeyUniqueTxResult) IsTx() {}

func (r AccessKeyUniqueTxResult) Result() (v *AccessKeyModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newAccessKeyManyTxResult() AccessKeyManyTxResult {
	return AccessKeyManyTxResult{
		result: &transaction.Result{},
	}
}

type AccessKeyManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p AccessKeyManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p AccessKeyManyTxResult) IsTx() {}

func (r AccessKeyManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newImportUniqueTxResult() ImportUniqueTxResult {
	return ImportUniqueTxResult{
		result: &transaction.Result{},
	}
}

type ImportUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ImportUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ImportUniqueTxResult) IsTx() {}

func (r ImportUniqueTxResult) Result() (v *ImportModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newImportManyTxResult() ImportManyTxResult {
	return ImportManyTxResult{
		result: &transaction.Result{},
	}
}

type ImportManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ImportManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ImportManyTxResult) IsTx() {}

func (r ImportManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newProductUniqueTxResult() ProductUniqueTxResult {
	return ProductUniqueTxResult{
		result: &transaction.Result{},
	}
}

type ProductUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ProductUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ProductUniqueTxResult) IsTx() {}

func (r ProductUniqueTxResult) Result() (v *ProductModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newProductManyTxResult() ProductManyTxResult {
	return ProductManyTxResult{
		result: &transaction.Result{},
	}
}

type ProductManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ProductManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ProductManyTxResult) IsTx() {}

func (r ProductManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCategoryUniqueTxResult() CategoryUniqueTxResult {
	return CategoryUniqueTxResult{
		result: &transaction.Result{},
	}
}

type CategoryUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CategoryUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CategoryUniqueTxResult) IsTx() {}

func (r CategoryUniqueTxResult) Result() (v *CategoryModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCategoryManyTxResult() CategoryManyTxResult {
	return CategoryManyTxResult{
		result: &transaction.Result{},
	}
}

type CategoryManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CategoryManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CategoryManyTxResult) IsTx() {}

func (r CategoryManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCategoryGroupUniqueTxResult() CategoryGroupUniqueTxResult {
	return CategoryGroupUniqueTxResult{
		result: &transaction.Result{},
	}
}

type CategoryGroupUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CategoryGroupUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CategoryGroupUniqueTxResult) IsTx() {}

func (r CategoryGroupUniqueTxResult) Result() (v *CategoryGroupModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCategoryGroupManyTxResult() CategoryGroupManyTxResult {
	return CategoryGroupManyTxResult{
		result: &transaction.Result{},
	}
}

type CategoryGroupManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CategoryGroupManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CategoryGroupManyTxResult) IsTx() {}

func (r CategoryGroupManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCategoryGroupCategoryUniqueTxResult() CategoryGroupCategoryUniqueTxResult {
	return CategoryGroupCategoryUniqueTxResult{
		result: &transaction.Result{},
	}
}

type CategoryGroupCategoryUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CategoryGroupCategoryUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CategoryGroupCategoryUniqueTxResult) IsTx() {}

func (r CategoryGroupCategoryUniqueTxResult) Result() (v *CategoryGroupCategoryModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCategoryGroupCategoryManyTxResult() CategoryGroupCategoryManyTxResult {
	return CategoryGroupCategoryManyTxResult{
		result: &transaction.Result{},
	}
}

type CategoryGroupCategoryManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CategoryGroupCategoryManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CategoryGroupCategoryManyTxResult) IsTx() {}

func (r CategoryGroupCategoryManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newStoreUniqueTxResult() StoreUniqueTxResult {
	return StoreUniqueTxResult{
		result: &transaction.Result{},
	}
}

type StoreUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p StoreUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p StoreUniqueTxResult) IsTx() {}

func (r StoreUniqueTxResult) Result() (v *StoreModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newStoreManyTxResult() StoreManyTxResult {
	return StoreManyTxResult{
		result: &transaction.Result{},
	}
}

type StoreManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p StoreManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p StoreManyTxResult) IsTx() {}

func (r StoreManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserStoreUniqueTxResult() UserStoreUniqueTxResult {
	return UserStoreUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserStoreUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserStoreUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserStoreUniqueTxResult) IsTx() {}

func (r UserStoreUniqueTxResult) Result() (v *UserStoreModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserStoreManyTxResult() UserStoreManyTxResult {
	return UserStoreManyTxResult{
		result: &transaction.Result{},
	}
}

type UserStoreManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserStoreManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserStoreManyTxResult) IsTx() {}

func (r UserStoreManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newHolidayUniqueTxResult() HolidayUniqueTxResult {
	return HolidayUniqueTxResult{
		result: &transaction.Result{},
	}
}

type HolidayUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p HolidayUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p HolidayUniqueTxResult) IsTx() {}

func (r HolidayUniqueTxResult) Result() (v *HolidayModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newHolidayManyTxResult() HolidayManyTxResult {
	return HolidayManyTxResult{
		result: &transaction.Result{},
	}
}

type HolidayManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p HolidayManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p HolidayManyTxResult) IsTx() {}

func (r HolidayManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newStoreStatusUniqueTxResult() StoreStatusUniqueTxResult {
	return StoreStatusUniqueTxResult{
		result: &transaction.Result{},
	}
}

type StoreStatusUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p StoreStatusUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p StoreStatusUniqueTxResult) IsTx() {}

func (r StoreStatusUniqueTxResult) Result() (v *StoreStatusModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newStoreStatusManyTxResult() StoreStatusManyTxResult {
	return StoreStatusManyTxResult{
		result: &transaction.Result{},
	}
}

type StoreStatusManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p StoreStatusManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p StoreStatusManyTxResult) IsTx() {}

func (r StoreStatusManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_uid UserWithPrismaUIDSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _uid.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) CreateOrUpdate(

	_uid UserWithPrismaUIDSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _uid.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type accessKeyUpsertOne struct {
	query builder.Query
}

func (r accessKeyUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r accessKeyUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r accessKeyUpsertOne) with()              {}
func (r accessKeyUpsertOne) accessKeyModel()    {}
func (r accessKeyUpsertOne) accessKeyRelation() {}

func (r accessKeyActions) UpsertOne(
	params AccessKeyEqualsUniqueWhereParam,
) accessKeyUpsertOne {
	var v accessKeyUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "AccessKey"
	v.query.Outputs = accessKeyOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r accessKeyUpsertOne) Create(

	_name AccessKeyWithPrismaNameSetParam,
	_value AccessKeyWithPrismaValueSetParam,

	optional ...AccessKeySetParam,
) accessKeyUpsertOne {
	var v accessKeyUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _value.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r accessKeyUpsertOne) Update(
	params ...AccessKeySetParam,
) accessKeyUpsertOne {
	var v accessKeyUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r accessKeyUpsertOne) CreateOrUpdate(

	_name AccessKeyWithPrismaNameSetParam,
	_value AccessKeyWithPrismaValueSetParam,

	optional ...AccessKeySetParam,
) accessKeyUpsertOne {
	var v accessKeyUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _value.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r accessKeyUpsertOne) Exec(ctx context.Context) (*AccessKeyModel, error) {
	var v AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r accessKeyUpsertOne) Tx() AccessKeyUniqueTxResult {
	v := newAccessKeyUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type importUpsertOne struct {
	query builder.Query
}

func (r importUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r importUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r importUpsertOne) with()           {}
func (r importUpsertOne) importModel()    {}
func (r importUpsertOne) importRelation() {}

func (r importActions) UpsertOne(
	params ImportEqualsUniqueWhereParam,
) importUpsertOne {
	var v importUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Import"
	v.query.Outputs = importOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r importUpsertOne) Create(

	_resourceType ImportWithPrismaResourceTypeSetParam,
	_status ImportWithPrismaStatusSetParam,
	_objectKey ImportWithPrismaObjectKeySetParam,

	optional ...ImportSetParam,
) importUpsertOne {
	var v importUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _resourceType.field())
	fields = append(fields, _status.field())
	fields = append(fields, _objectKey.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r importUpsertOne) Update(
	params ...ImportSetParam,
) importUpsertOne {
	var v importUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r importUpsertOne) CreateOrUpdate(

	_resourceType ImportWithPrismaResourceTypeSetParam,
	_status ImportWithPrismaStatusSetParam,
	_objectKey ImportWithPrismaObjectKeySetParam,

	optional ...ImportSetParam,
) importUpsertOne {
	var v importUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _resourceType.field())
	fields = append(fields, _status.field())
	fields = append(fields, _objectKey.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r importUpsertOne) Exec(ctx context.Context) (*ImportModel, error) {
	var v ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r importUpsertOne) Tx() ImportUniqueTxResult {
	v := newImportUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type productUpsertOne struct {
	query builder.Query
}

func (r productUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r productUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r productUpsertOne) with()            {}
func (r productUpsertOne) productModel()    {}
func (r productUpsertOne) productRelation() {}

func (r productActions) UpsertOne(
	params ProductEqualsUniqueWhereParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Product"
	v.query.Outputs = productOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r productUpsertOne) Create(

	_id ProductWithPrismaIDSetParam,
	_name ProductWithPrismaNameSetParam,

	optional ...ProductSetParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r productUpsertOne) Update(
	params ...ProductSetParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r productUpsertOne) CreateOrUpdate(

	_id ProductWithPrismaIDSetParam,
	_name ProductWithPrismaNameSetParam,

	optional ...ProductSetParam,
) productUpsertOne {
	var v productUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r productUpsertOne) Exec(ctx context.Context) (*ProductModel, error) {
	var v ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r productUpsertOne) Tx() ProductUniqueTxResult {
	v := newProductUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryUpsertOne struct {
	query builder.Query
}

func (r categoryUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r categoryUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryUpsertOne) with()             {}
func (r categoryUpsertOne) categoryModel()    {}
func (r categoryUpsertOne) categoryRelation() {}

func (r categoryActions) UpsertOne(
	params CategoryEqualsUniqueWhereParam,
) categoryUpsertOne {
	var v categoryUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Category"
	v.query.Outputs = categoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r categoryUpsertOne) Create(

	optional ...CategorySetParam,
) categoryUpsertOne {
	var v categoryUpsertOne
	v.query = r.query

	var fields []builder.Field

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r categoryUpsertOne) Update(
	params ...CategorySetParam,
) categoryUpsertOne {
	var v categoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r categoryUpsertOne) CreateOrUpdate(

	optional ...CategorySetParam,
) categoryUpsertOne {
	var v categoryUpsertOne
	v.query = r.query

	var fields []builder.Field

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r categoryUpsertOne) Exec(ctx context.Context) (*CategoryModel, error) {
	var v CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryUpsertOne) Tx() CategoryUniqueTxResult {
	v := newCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupUpsertOne struct {
	query builder.Query
}

func (r categoryGroupUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupUpsertOne) with()                  {}
func (r categoryGroupUpsertOne) categoryGroupModel()    {}
func (r categoryGroupUpsertOne) categoryGroupRelation() {}

func (r categoryGroupActions) UpsertOne(
	params CategoryGroupEqualsUniqueWhereParam,
) categoryGroupUpsertOne {
	var v categoryGroupUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "CategoryGroup"
	v.query.Outputs = categoryGroupOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r categoryGroupUpsertOne) Create(

	_id CategoryGroupWithPrismaIDSetParam,
	_name CategoryGroupWithPrismaNameSetParam,
	_level CategoryGroupWithPrismaLevelSetParam,

	optional ...CategoryGroupSetParam,
) categoryGroupUpsertOne {
	var v categoryGroupUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _name.field())
	fields = append(fields, _level.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r categoryGroupUpsertOne) Update(
	params ...CategoryGroupSetParam,
) categoryGroupUpsertOne {
	var v categoryGroupUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r categoryGroupUpsertOne) CreateOrUpdate(

	_id CategoryGroupWithPrismaIDSetParam,
	_name CategoryGroupWithPrismaNameSetParam,
	_level CategoryGroupWithPrismaLevelSetParam,

	optional ...CategoryGroupSetParam,
) categoryGroupUpsertOne {
	var v categoryGroupUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _name.field())
	fields = append(fields, _level.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r categoryGroupUpsertOne) Exec(ctx context.Context) (*CategoryGroupModel, error) {
	var v CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupUpsertOne) Tx() CategoryGroupUniqueTxResult {
	v := newCategoryGroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type categoryGroupCategoryUpsertOne struct {
	query builder.Query
}

func (r categoryGroupCategoryUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryUpsertOne) with()                          {}
func (r categoryGroupCategoryUpsertOne) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryUpsertOne) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryActions) UpsertOne(
	params CategoryGroupCategoryEqualsUniqueWhereParam,
) categoryGroupCategoryUpsertOne {
	var v categoryGroupCategoryUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "CategoryGroupCategory"
	v.query.Outputs = categoryGroupCategoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r categoryGroupCategoryUpsertOne) Create(

	_category CategoryGroupCategoryWithPrismaCategorySetParam,
	_categoryGroup CategoryGroupCategoryWithPrismaCategoryGroupSetParam,

	optional ...CategoryGroupCategorySetParam,
) categoryGroupCategoryUpsertOne {
	var v categoryGroupCategoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _category.field())
	fields = append(fields, _categoryGroup.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r categoryGroupCategoryUpsertOne) Update(
	params ...CategoryGroupCategorySetParam,
) categoryGroupCategoryUpsertOne {
	var v categoryGroupCategoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r categoryGroupCategoryUpsertOne) CreateOrUpdate(

	_category CategoryGroupCategoryWithPrismaCategorySetParam,
	_categoryGroup CategoryGroupCategoryWithPrismaCategoryGroupSetParam,

	optional ...CategoryGroupCategorySetParam,
) categoryGroupCategoryUpsertOne {
	var v categoryGroupCategoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _category.field())
	fields = append(fields, _categoryGroup.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r categoryGroupCategoryUpsertOne) Exec(ctx context.Context) (*CategoryGroupCategoryModel, error) {
	var v CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r categoryGroupCategoryUpsertOne) Tx() CategoryGroupCategoryUniqueTxResult {
	v := newCategoryGroupCategoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeUpsertOne struct {
	query builder.Query
}

func (r storeUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r storeUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r storeUpsertOne) with()          {}
func (r storeUpsertOne) storeModel()    {}
func (r storeUpsertOne) storeRelation() {}

func (r storeActions) UpsertOne(
	params StoreEqualsUniqueWhereParam,
) storeUpsertOne {
	var v storeUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Store"
	v.query.Outputs = storeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r storeUpsertOne) Create(

	_id StoreWithPrismaIDSetParam,
	_name StoreWithPrismaNameSetParam,

	optional ...StoreSetParam,
) storeUpsertOne {
	var v storeUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r storeUpsertOne) Update(
	params ...StoreSetParam,
) storeUpsertOne {
	var v storeUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r storeUpsertOne) CreateOrUpdate(

	_id StoreWithPrismaIDSetParam,
	_name StoreWithPrismaNameSetParam,

	optional ...StoreSetParam,
) storeUpsertOne {
	var v storeUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _id.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r storeUpsertOne) Exec(ctx context.Context) (*StoreModel, error) {
	var v StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeUpsertOne) Tx() StoreUniqueTxResult {
	v := newStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userStoreUpsertOne struct {
	query builder.Query
}

func (r userStoreUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userStoreUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreUpsertOne) with()              {}
func (r userStoreUpsertOne) userStoreModel()    {}
func (r userStoreUpsertOne) userStoreRelation() {}

func (r userStoreActions) UpsertOne(
	params UserStoreEqualsUniqueWhereParam,
) userStoreUpsertOne {
	var v userStoreUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "UserStore"
	v.query.Outputs = userStoreOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userStoreUpsertOne) Create(

	_email UserStoreWithPrismaEmailSetParam,
	_name UserStoreWithPrismaNameSetParam,
	_store UserStoreWithPrismaStoreSetParam,

	optional ...UserStoreSetParam,
) userStoreUpsertOne {
	var v userStoreUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _email.field())
	fields = append(fields, _name.field())
	fields = append(fields, _store.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userStoreUpsertOne) Update(
	params ...UserStoreSetParam,
) userStoreUpsertOne {
	var v userStoreUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userStoreUpsertOne) CreateOrUpdate(

	_email UserStoreWithPrismaEmailSetParam,
	_name UserStoreWithPrismaNameSetParam,
	_store UserStoreWithPrismaStoreSetParam,

	optional ...UserStoreSetParam,
) userStoreUpsertOne {
	var v userStoreUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _email.field())
	fields = append(fields, _name.field())
	fields = append(fields, _store.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userStoreUpsertOne) Exec(ctx context.Context) (*UserStoreModel, error) {
	var v UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userStoreUpsertOne) Tx() UserStoreUniqueTxResult {
	v := newUserStoreUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type holidayUpsertOne struct {
	query builder.Query
}

func (r holidayUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r holidayUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r holidayUpsertOne) with()            {}
func (r holidayUpsertOne) holidayModel()    {}
func (r holidayUpsertOne) holidayRelation() {}

func (r holidayActions) UpsertOne(
	params HolidayEqualsUniqueWhereParam,
) holidayUpsertOne {
	var v holidayUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Holiday"
	v.query.Outputs = holidayOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r holidayUpsertOne) Create(

	_date HolidayWithPrismaDateSetParam,
	_name HolidayWithPrismaNameSetParam,

	optional ...HolidaySetParam,
) holidayUpsertOne {
	var v holidayUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _date.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r holidayUpsertOne) Update(
	params ...HolidaySetParam,
) holidayUpsertOne {
	var v holidayUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r holidayUpsertOne) CreateOrUpdate(

	_date HolidayWithPrismaDateSetParam,
	_name HolidayWithPrismaNameSetParam,

	optional ...HolidaySetParam,
) holidayUpsertOne {
	var v holidayUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _date.field())
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r holidayUpsertOne) Exec(ctx context.Context) (*HolidayModel, error) {
	var v HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r holidayUpsertOne) Tx() HolidayUniqueTxResult {
	v := newHolidayUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type storeStatusUpsertOne struct {
	query builder.Query
}

func (r storeStatusUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r storeStatusUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r storeStatusUpsertOne) with()                {}
func (r storeStatusUpsertOne) storeStatusModel()    {}
func (r storeStatusUpsertOne) storeStatusRelation() {}

func (r storeStatusActions) UpsertOne(
	params StoreStatusEqualsUniqueWhereParam,
) storeStatusUpsertOne {
	var v storeStatusUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "StoreStatus"
	v.query.Outputs = storeStatusOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r storeStatusUpsertOne) Create(

	_storeID StoreStatusWithPrismaStoreIDSetParam,
	_date StoreStatusWithPrismaDateSetParam,

	optional ...StoreStatusSetParam,
) storeStatusUpsertOne {
	var v storeStatusUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _storeID.field())
	fields = append(fields, _date.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r storeStatusUpsertOne) Update(
	params ...StoreStatusSetParam,
) storeStatusUpsertOne {
	var v storeStatusUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r storeStatusUpsertOne) CreateOrUpdate(

	_storeID StoreStatusWithPrismaStoreIDSetParam,
	_date StoreStatusWithPrismaDateSetParam,

	optional ...StoreStatusSetParam,
) storeStatusUpsertOne {
	var v storeStatusUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _storeID.field())
	fields = append(fields, _date.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r storeStatusUpsertOne) Exec(ctx context.Context) (*StoreStatusModel, error) {
	var v StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r storeStatusUpsertOne) Tx() StoreStatusUniqueTxResult {
	v := newStoreStatusUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template raw.gotpl ---

type userAggregateRaw struct {
	query builder.Query
}

func (r userAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r userAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r userAggregateRaw) with()         {}
func (r userAggregateRaw) userModel()    {}
func (r userAggregateRaw) userRelation() {}

func (r userActions) FindRaw(filter interface{}, options ...interface{}) userAggregateRaw {
	var v userAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "User"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userActions) AggregateRaw(pipeline []interface{}, options ...interface{}) userAggregateRaw {
	var v userAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "User"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userAggregateRaw) Exec(ctx context.Context) ([]UserModel, error) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r userAggregateRaw) ExecInner(ctx context.Context) ([]InnerUser, error) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type accessKeyAggregateRaw struct {
	query builder.Query
}

func (r accessKeyAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r accessKeyAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r accessKeyAggregateRaw) with()              {}
func (r accessKeyAggregateRaw) accessKeyModel()    {}
func (r accessKeyAggregateRaw) accessKeyRelation() {}

func (r accessKeyActions) FindRaw(filter interface{}, options ...interface{}) accessKeyAggregateRaw {
	var v accessKeyAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "AccessKey"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r accessKeyActions) AggregateRaw(pipeline []interface{}, options ...interface{}) accessKeyAggregateRaw {
	var v accessKeyAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "AccessKey"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r accessKeyAggregateRaw) Exec(ctx context.Context) ([]AccessKeyModel, error) {
	var v []AccessKeyModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r accessKeyAggregateRaw) ExecInner(ctx context.Context) ([]InnerAccessKey, error) {
	var v []InnerAccessKey
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type importAggregateRaw struct {
	query builder.Query
}

func (r importAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r importAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r importAggregateRaw) with()           {}
func (r importAggregateRaw) importModel()    {}
func (r importAggregateRaw) importRelation() {}

func (r importActions) FindRaw(filter interface{}, options ...interface{}) importAggregateRaw {
	var v importAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Import"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r importActions) AggregateRaw(pipeline []interface{}, options ...interface{}) importAggregateRaw {
	var v importAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Import"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r importAggregateRaw) Exec(ctx context.Context) ([]ImportModel, error) {
	var v []ImportModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r importAggregateRaw) ExecInner(ctx context.Context) ([]InnerImport, error) {
	var v []InnerImport
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type productAggregateRaw struct {
	query builder.Query
}

func (r productAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r productAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r productAggregateRaw) with()            {}
func (r productAggregateRaw) productModel()    {}
func (r productAggregateRaw) productRelation() {}

func (r productActions) FindRaw(filter interface{}, options ...interface{}) productAggregateRaw {
	var v productAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Product"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r productActions) AggregateRaw(pipeline []interface{}, options ...interface{}) productAggregateRaw {
	var v productAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Product"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r productAggregateRaw) Exec(ctx context.Context) ([]ProductModel, error) {
	var v []ProductModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r productAggregateRaw) ExecInner(ctx context.Context) ([]InnerProduct, error) {
	var v []InnerProduct
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type categoryAggregateRaw struct {
	query builder.Query
}

func (r categoryAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r categoryAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryAggregateRaw) with()             {}
func (r categoryAggregateRaw) categoryModel()    {}
func (r categoryAggregateRaw) categoryRelation() {}

func (r categoryActions) FindRaw(filter interface{}, options ...interface{}) categoryAggregateRaw {
	var v categoryAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Category"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r categoryActions) AggregateRaw(pipeline []interface{}, options ...interface{}) categoryAggregateRaw {
	var v categoryAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Category"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r categoryAggregateRaw) Exec(ctx context.Context) ([]CategoryModel, error) {
	var v []CategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r categoryAggregateRaw) ExecInner(ctx context.Context) ([]InnerCategory, error) {
	var v []InnerCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type categoryGroupAggregateRaw struct {
	query builder.Query
}

func (r categoryGroupAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupAggregateRaw) with()                  {}
func (r categoryGroupAggregateRaw) categoryGroupModel()    {}
func (r categoryGroupAggregateRaw) categoryGroupRelation() {}

func (r categoryGroupActions) FindRaw(filter interface{}, options ...interface{}) categoryGroupAggregateRaw {
	var v categoryGroupAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "CategoryGroup"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r categoryGroupActions) AggregateRaw(pipeline []interface{}, options ...interface{}) categoryGroupAggregateRaw {
	var v categoryGroupAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "CategoryGroup"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r categoryGroupAggregateRaw) Exec(ctx context.Context) ([]CategoryGroupModel, error) {
	var v []CategoryGroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r categoryGroupAggregateRaw) ExecInner(ctx context.Context) ([]InnerCategoryGroup, error) {
	var v []InnerCategoryGroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type categoryGroupCategoryAggregateRaw struct {
	query builder.Query
}

func (r categoryGroupCategoryAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r categoryGroupCategoryAggregateRaw) with()                          {}
func (r categoryGroupCategoryAggregateRaw) categoryGroupCategoryModel()    {}
func (r categoryGroupCategoryAggregateRaw) categoryGroupCategoryRelation() {}

func (r categoryGroupCategoryActions) FindRaw(filter interface{}, options ...interface{}) categoryGroupCategoryAggregateRaw {
	var v categoryGroupCategoryAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "CategoryGroupCategory"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r categoryGroupCategoryActions) AggregateRaw(pipeline []interface{}, options ...interface{}) categoryGroupCategoryAggregateRaw {
	var v categoryGroupCategoryAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "CategoryGroupCategory"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r categoryGroupCategoryAggregateRaw) Exec(ctx context.Context) ([]CategoryGroupCategoryModel, error) {
	var v []CategoryGroupCategoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r categoryGroupCategoryAggregateRaw) ExecInner(ctx context.Context) ([]InnerCategoryGroupCategory, error) {
	var v []InnerCategoryGroupCategory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type storeAggregateRaw struct {
	query builder.Query
}

func (r storeAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r storeAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r storeAggregateRaw) with()          {}
func (r storeAggregateRaw) storeModel()    {}
func (r storeAggregateRaw) storeRelation() {}

func (r storeActions) FindRaw(filter interface{}, options ...interface{}) storeAggregateRaw {
	var v storeAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Store"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r storeActions) AggregateRaw(pipeline []interface{}, options ...interface{}) storeAggregateRaw {
	var v storeAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Store"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r storeAggregateRaw) Exec(ctx context.Context) ([]StoreModel, error) {
	var v []StoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r storeAggregateRaw) ExecInner(ctx context.Context) ([]InnerStore, error) {
	var v []InnerStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type userStoreAggregateRaw struct {
	query builder.Query
}

func (r userStoreAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r userStoreAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r userStoreAggregateRaw) with()              {}
func (r userStoreAggregateRaw) userStoreModel()    {}
func (r userStoreAggregateRaw) userStoreRelation() {}

func (r userStoreActions) FindRaw(filter interface{}, options ...interface{}) userStoreAggregateRaw {
	var v userStoreAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "UserStore"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userStoreActions) AggregateRaw(pipeline []interface{}, options ...interface{}) userStoreAggregateRaw {
	var v userStoreAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "UserStore"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userStoreAggregateRaw) Exec(ctx context.Context) ([]UserStoreModel, error) {
	var v []UserStoreModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r userStoreAggregateRaw) ExecInner(ctx context.Context) ([]InnerUserStore, error) {
	var v []InnerUserStore
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type holidayAggregateRaw struct {
	query builder.Query
}

func (r holidayAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r holidayAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r holidayAggregateRaw) with()            {}
func (r holidayAggregateRaw) holidayModel()    {}
func (r holidayAggregateRaw) holidayRelation() {}

func (r holidayActions) FindRaw(filter interface{}, options ...interface{}) holidayAggregateRaw {
	var v holidayAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Holiday"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r holidayActions) AggregateRaw(pipeline []interface{}, options ...interface{}) holidayAggregateRaw {
	var v holidayAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Holiday"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r holidayAggregateRaw) Exec(ctx context.Context) ([]HolidayModel, error) {
	var v []HolidayModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r holidayAggregateRaw) ExecInner(ctx context.Context) ([]InnerHoliday, error) {
	var v []InnerHoliday
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type storeStatusAggregateRaw struct {
	query builder.Query
}

func (r storeStatusAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r storeStatusAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r storeStatusAggregateRaw) with()                {}
func (r storeStatusAggregateRaw) storeStatusModel()    {}
func (r storeStatusAggregateRaw) storeStatusRelation() {}

func (r storeStatusActions) FindRaw(filter interface{}, options ...interface{}) storeStatusAggregateRaw {
	var v storeStatusAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "StoreStatus"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r storeStatusActions) AggregateRaw(pipeline []interface{}, options ...interface{}) storeStatusAggregateRaw {
	var v storeStatusAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "StoreStatus"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r storeStatusAggregateRaw) Exec(ctx context.Context) ([]StoreStatusModel, error) {
	var v []StoreStatusModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r storeStatusAggregateRaw) ExecInner(ctx context.Context) ([]InnerStoreStatus, error) {
	var v []InnerStoreStatus
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}
